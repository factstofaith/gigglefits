{"ast":null,"code":"/**\n * useDatabasePerformance Hook\n * \n * Custom hook for working with database performance metrics and optimization features\n * Part of the Database Optimization (Phase 4) implementation\n */\nimport { useCallback, useState, useEffect } from 'react';\nimport { useDatabaseMonitoring } from '../contexts/DatabaseMonitoringContext';\nconst useDatabasePerformance = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    metrics,\n    status,\n    lastUpdated,\n    refreshMetrics,\n    getComponentMetrics\n  } = useDatabaseMonitoring();\n  const [componentFilter, setComponentFilter] = useState(options.component || null);\n  const [alertsOnly, setAlertsOnly] = useState(options.alertsOnly || false);\n  const [timeRange, setTimeRange] = useState(options.timeRange || '1h');\n\n  // Filter metrics based on current settings\n  const filteredMetrics = useCallback(() => {\n    if (componentFilter) {\n      return getComponentMetrics(componentFilter);\n    }\n    if (alertsOnly) {\n      const alerts = {};\n\n      // Connection pool alerts\n      if (metrics.connectionPool?.utilization > 80) {\n        alerts.connectionPool = {\n          ...metrics.connectionPool,\n          alert: 'High connection pool utilization'\n        };\n      }\n\n      // Query performance alerts\n      if (metrics.queryPerformance?.slowQueries?.length > 0) {\n        alerts.queryPerformance = {\n          ...metrics.queryPerformance,\n          alert: `${metrics.queryPerformance.slowQueries.length} slow queries detected`\n        };\n      }\n\n      // Index usage alerts\n      if (metrics.indexUsage?.missingIndexes?.length > 0) {\n        alerts.indexUsage = {\n          ...metrics.indexUsage,\n          alert: `${metrics.indexUsage.missingIndexes.length} missing indexes detected`\n        };\n      }\n\n      // Health alerts\n      if (metrics.health?.status !== 'healthy') {\n        alerts.health = {\n          ...metrics.health,\n          alert: `Database health: ${metrics.health.status}`\n        };\n      }\n      return alerts;\n    }\n    return metrics;\n  }, [metrics, componentFilter, alertsOnly, getComponentMetrics]);\n\n  // Get performance score (0-100)\n  const getPerformanceScore = useCallback(() => {\n    if (!metrics) return 0;\n\n    // Calculate weighted score based on various metrics\n    let score = 100;\n\n    // Connection pool metrics (30% weight)\n    if (metrics.connectionPool) {\n      const poolUtilization = metrics.connectionPool.utilization || 0;\n      // Higher utilization reduces score\n      if (poolUtilization > 50) {\n        score -= (poolUtilization - 50) / 50 * 15;\n      }\n\n      // Waiting queries reduce score\n      const waitingQueries = metrics.connectionPool.waitingQueries || 0;\n      if (waitingQueries > 0) {\n        score -= Math.min(15, waitingQueries * 3);\n      }\n    }\n\n    // Query performance metrics (40% weight)\n    if (metrics.queryPerformance) {\n      // Slow queries reduce score\n      const slowQueryCount = metrics.queryPerformance.slowQueries?.length || 0;\n      if (slowQueryCount > 0) {\n        score -= Math.min(20, slowQueryCount * 4);\n      }\n\n      // Low cache hit rate reduces score\n      const cacheHitRate = metrics.queryPerformance.cacheHitRate || 0;\n      if (cacheHitRate < 80) {\n        score -= (80 - cacheHitRate) / 80 * 20;\n      }\n    }\n\n    // Index usage metrics (20% weight)\n    if (metrics.indexUsage) {\n      // Missing indexes reduce score\n      const missingIndexCount = metrics.indexUsage.missingIndexes?.length || 0;\n      if (missingIndexCount > 0) {\n        score -= Math.min(10, missingIndexCount * 2);\n      }\n\n      // Unused indexes reduce score\n      const unusedIndexCount = metrics.indexUsage.unusedIndexes?.length || 0;\n      if (unusedIndexCount > 0) {\n        score -= Math.min(10, unusedIndexCount);\n      }\n    }\n\n    // Health status (10% weight)\n    if (metrics.health && metrics.health.status !== 'healthy') {\n      score -= 10;\n    }\n    return Math.max(0, Math.round(score));\n  }, [metrics]);\n\n  // Get optimization recommendations\n  const getRecommendations = useCallback(() => {\n    const recommendations = [];\n\n    // Connection pool recommendations\n    if (metrics.connectionPool?.utilization > 80) {\n      recommendations.push({\n        component: 'connectionPool',\n        priority: 'high',\n        message: 'Increase connection pool size to handle current load',\n        action: 'increasePoolSize'\n      });\n    } else if (metrics.connectionPool?.utilization < 20 && metrics.connectionPool?.maxConnections > 10) {\n      recommendations.push({\n        component: 'connectionPool',\n        priority: 'medium',\n        message: 'Decrease connection pool size to optimize resource usage',\n        action: 'decreasePoolSize'\n      });\n    }\n\n    // Query performance recommendations\n    if (metrics.queryPerformance?.slowQueries?.length > 0) {\n      recommendations.push({\n        component: 'queryPerformance',\n        priority: 'high',\n        message: `Optimize ${metrics.queryPerformance.slowQueries.length} slow queries`,\n        action: 'optimizeSlowQueries',\n        details: metrics.queryPerformance.slowQueries\n      });\n    }\n    if (metrics.queryPerformance?.cacheHitRate < 50) {\n      recommendations.push({\n        component: 'queryPerformance',\n        priority: 'medium',\n        message: 'Implement query caching to improve performance',\n        action: 'implementCaching'\n      });\n    }\n\n    // Index recommendations\n    if (metrics.indexUsage?.missingIndexes?.length > 0) {\n      recommendations.push({\n        component: 'indexUsage',\n        priority: 'high',\n        message: `Add ${metrics.indexUsage.missingIndexes.length} recommended indexes`,\n        action: 'addMissingIndexes',\n        details: metrics.indexUsage.missingIndexes\n      });\n    }\n    if (metrics.indexUsage?.unusedIndexes?.length > 0) {\n      recommendations.push({\n        component: 'indexUsage',\n        priority: 'low',\n        message: `Remove ${metrics.indexUsage.unusedIndexes.length} unused indexes`,\n        action: 'removeUnusedIndexes',\n        details: metrics.indexUsage.unusedIndexes\n      });\n    }\n    return recommendations.sort((a, b) => {\n      const priorityMap = {\n        high: 0,\n        medium: 1,\n        low: 2\n      };\n      return priorityMap[a.priority] - priorityMap[b.priority];\n    });\n  }, [metrics]);\n\n  // Monitor changes in metrics and refresh based on timeRange\n  useEffect(() => {\n    // Initial refresh\n    refreshMetrics();\n\n    // Set up refresh interval based on timeRange\n    let interval;\n    switch (timeRange) {\n      case '5m':\n        interval = setInterval(refreshMetrics, 5 * 60 * 1000);\n        break;\n      case '1h':\n        interval = setInterval(refreshMetrics, 60 * 60 * 1000);\n        break;\n      case '1d':\n        interval = setInterval(refreshMetrics, 24 * 60 * 60 * 1000);\n        break;\n      default:\n        interval = setInterval(refreshMetrics, 60 * 1000);\n    }\n    return () => {\n      clearInterval(interval);\n    };\n  }, [timeRange, refreshMetrics]);\n  return {\n    metrics: filteredMetrics(),\n    status,\n    lastUpdated,\n    refreshMetrics,\n    componentFilter,\n    setComponentFilter,\n    alertsOnly,\n    setAlertsOnly,\n    timeRange,\n    setTimeRange,\n    performanceScore: getPerformanceScore(),\n    recommendations: getRecommendations()\n  };\n};\nexport default useDatabasePerformance;","map":{"version":3,"names":["useCallback","useState","useEffect","useDatabaseMonitoring","useDatabasePerformance","options","arguments","length","undefined","metrics","status","lastUpdated","refreshMetrics","getComponentMetrics","componentFilter","setComponentFilter","component","alertsOnly","setAlertsOnly","timeRange","setTimeRange","filteredMetrics","alerts","connectionPool","utilization","alert","queryPerformance","slowQueries","indexUsage","missingIndexes","health","getPerformanceScore","score","poolUtilization","waitingQueries","Math","min","slowQueryCount","cacheHitRate","missingIndexCount","unusedIndexCount","unusedIndexes","max","round","getRecommendations","recommendations","push","priority","message","action","maxConnections","details","sort","a","b","priorityMap","high","medium","low","interval","setInterval","clearInterval","performanceScore"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/project/finishline/src/hooks/useDatabasePerformance.js"],"sourcesContent":["/**\n * useDatabasePerformance Hook\n * \n * Custom hook for working with database performance metrics and optimization features\n * Part of the Database Optimization (Phase 4) implementation\n */\nimport { useCallback, useState, useEffect } from 'react';\nimport { useDatabaseMonitoring } from '../contexts/DatabaseMonitoringContext';\n\nconst useDatabasePerformance = (options = {}) => {\n  const { \n    metrics, \n    status, \n    lastUpdated, \n    refreshMetrics,\n    getComponentMetrics\n  } = useDatabaseMonitoring();\n  \n  const [componentFilter, setComponentFilter] = useState(options.component || null);\n  const [alertsOnly, setAlertsOnly] = useState(options.alertsOnly || false);\n  const [timeRange, setTimeRange] = useState(options.timeRange || '1h');\n  \n  // Filter metrics based on current settings\n  const filteredMetrics = useCallback(() => {\n    if (componentFilter) {\n      return getComponentMetrics(componentFilter);\n    }\n    \n    if (alertsOnly) {\n      const alerts = {};\n      \n      // Connection pool alerts\n      if (metrics.connectionPool?.utilization > 80) {\n        alerts.connectionPool = {\n          ...metrics.connectionPool,\n          alert: 'High connection pool utilization'\n        };\n      }\n      \n      // Query performance alerts\n      if (metrics.queryPerformance?.slowQueries?.length > 0) {\n        alerts.queryPerformance = {\n          ...metrics.queryPerformance,\n          alert: `${metrics.queryPerformance.slowQueries.length} slow queries detected`\n        };\n      }\n      \n      // Index usage alerts\n      if (metrics.indexUsage?.missingIndexes?.length > 0) {\n        alerts.indexUsage = {\n          ...metrics.indexUsage,\n          alert: `${metrics.indexUsage.missingIndexes.length} missing indexes detected`\n        };\n      }\n      \n      // Health alerts\n      if (metrics.health?.status !== 'healthy') {\n        alerts.health = {\n          ...metrics.health,\n          alert: `Database health: ${metrics.health.status}`\n        };\n      }\n      \n      return alerts;\n    }\n    \n    return metrics;\n  }, [metrics, componentFilter, alertsOnly, getComponentMetrics]);\n  \n  // Get performance score (0-100)\n  const getPerformanceScore = useCallback(() => {\n    if (!metrics) return 0;\n    \n    // Calculate weighted score based on various metrics\n    let score = 100;\n    \n    // Connection pool metrics (30% weight)\n    if (metrics.connectionPool) {\n      const poolUtilization = metrics.connectionPool.utilization || 0;\n      // Higher utilization reduces score\n      if (poolUtilization > 50) {\n        score -= ((poolUtilization - 50) / 50) * 15;\n      }\n      \n      // Waiting queries reduce score\n      const waitingQueries = metrics.connectionPool.waitingQueries || 0;\n      if (waitingQueries > 0) {\n        score -= Math.min(15, waitingQueries * 3);\n      }\n    }\n    \n    // Query performance metrics (40% weight)\n    if (metrics.queryPerformance) {\n      // Slow queries reduce score\n      const slowQueryCount = metrics.queryPerformance.slowQueries?.length || 0;\n      if (slowQueryCount > 0) {\n        score -= Math.min(20, slowQueryCount * 4);\n      }\n      \n      // Low cache hit rate reduces score\n      const cacheHitRate = metrics.queryPerformance.cacheHitRate || 0;\n      if (cacheHitRate < 80) {\n        score -= ((80 - cacheHitRate) / 80) * 20;\n      }\n    }\n    \n    // Index usage metrics (20% weight)\n    if (metrics.indexUsage) {\n      // Missing indexes reduce score\n      const missingIndexCount = metrics.indexUsage.missingIndexes?.length || 0;\n      if (missingIndexCount > 0) {\n        score -= Math.min(10, missingIndexCount * 2);\n      }\n      \n      // Unused indexes reduce score\n      const unusedIndexCount = metrics.indexUsage.unusedIndexes?.length || 0;\n      if (unusedIndexCount > 0) {\n        score -= Math.min(10, unusedIndexCount);\n      }\n    }\n    \n    // Health status (10% weight)\n    if (metrics.health && metrics.health.status !== 'healthy') {\n      score -= 10;\n    }\n    \n    return Math.max(0, Math.round(score));\n  }, [metrics]);\n  \n  // Get optimization recommendations\n  const getRecommendations = useCallback(() => {\n    const recommendations = [];\n    \n    // Connection pool recommendations\n    if (metrics.connectionPool?.utilization > 80) {\n      recommendations.push({\n        component: 'connectionPool',\n        priority: 'high',\n        message: 'Increase connection pool size to handle current load',\n        action: 'increasePoolSize'\n      });\n    } else if (metrics.connectionPool?.utilization < 20 && \n              metrics.connectionPool?.maxConnections > 10) {\n      recommendations.push({\n        component: 'connectionPool',\n        priority: 'medium',\n        message: 'Decrease connection pool size to optimize resource usage',\n        action: 'decreasePoolSize'\n      });\n    }\n    \n    // Query performance recommendations\n    if (metrics.queryPerformance?.slowQueries?.length > 0) {\n      recommendations.push({\n        component: 'queryPerformance',\n        priority: 'high',\n        message: `Optimize ${metrics.queryPerformance.slowQueries.length} slow queries`,\n        action: 'optimizeSlowQueries',\n        details: metrics.queryPerformance.slowQueries\n      });\n    }\n    \n    if (metrics.queryPerformance?.cacheHitRate < 50) {\n      recommendations.push({\n        component: 'queryPerformance',\n        priority: 'medium',\n        message: 'Implement query caching to improve performance',\n        action: 'implementCaching'\n      });\n    }\n    \n    // Index recommendations\n    if (metrics.indexUsage?.missingIndexes?.length > 0) {\n      recommendations.push({\n        component: 'indexUsage',\n        priority: 'high',\n        message: `Add ${metrics.indexUsage.missingIndexes.length} recommended indexes`,\n        action: 'addMissingIndexes',\n        details: metrics.indexUsage.missingIndexes\n      });\n    }\n    \n    if (metrics.indexUsage?.unusedIndexes?.length > 0) {\n      recommendations.push({\n        component: 'indexUsage',\n        priority: 'low',\n        message: `Remove ${metrics.indexUsage.unusedIndexes.length} unused indexes`,\n        action: 'removeUnusedIndexes',\n        details: metrics.indexUsage.unusedIndexes\n      });\n    }\n    \n    return recommendations.sort((a, b) => {\n      const priorityMap = { high: 0, medium: 1, low: 2 };\n      return priorityMap[a.priority] - priorityMap[b.priority];\n    });\n  }, [metrics]);\n  \n  // Monitor changes in metrics and refresh based on timeRange\n  useEffect(() => {\n    // Initial refresh\n    refreshMetrics();\n    \n    // Set up refresh interval based on timeRange\n    let interval;\n    switch (timeRange) {\n      case '5m':\n        interval = setInterval(refreshMetrics, 5 * 60 * 1000);\n        break;\n      case '1h':\n        interval = setInterval(refreshMetrics, 60 * 60 * 1000);\n        break;\n      case '1d':\n        interval = setInterval(refreshMetrics, 24 * 60 * 60 * 1000);\n        break;\n      default:\n        interval = setInterval(refreshMetrics, 60 * 1000);\n    }\n    \n    return () => {\n      clearInterval(interval);\n    };\n  }, [timeRange, refreshMetrics]);\n  \n  return {\n    metrics: filteredMetrics(),\n    status,\n    lastUpdated,\n    refreshMetrics,\n    componentFilter,\n    setComponentFilter,\n    alertsOnly,\n    setAlertsOnly,\n    timeRange,\n    setTimeRange,\n    performanceScore: getPerformanceScore(),\n    recommendations: getRecommendations()\n  };\n};\n\nexport default useDatabasePerformance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}