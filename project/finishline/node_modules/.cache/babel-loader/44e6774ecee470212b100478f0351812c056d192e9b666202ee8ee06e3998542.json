{"ast":null,"code":"/**\n * Performance Monitoring Utilities\n * \n * Tools for measuring and optimizing component performance.\n * \n * @module utils/performance\n */\n\nimport { useRef, useEffect } from 'react';\n\n/**\n * Function to format performance time in milliseconds\n * \n * @param {number} time - Time in milliseconds\n * @returns {string} Formatted time\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst formatTime = time => {\n  if (time < 1) {\n    return `${(time * 1000).toFixed(2)}μs`;\n  }\n  if (time < 1000) {\n    return `${time.toFixed(2)}ms`;\n  }\n  return `${(time / 1000).toFixed(2)}s`;\n};\n\n/**\n * Performance marker class for measuring operations\n */\nexport class PerformanceMarker {\n  /**\n   * Create a new performance marker\n   * \n   * @param {string} name - Name of the marker\n   */\n  constructor(name) {\n    this.name = name;\n    this.marks = {};\n    this.measures = {};\n  }\n\n  /**\n   * Start a measurement\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {PerformanceMarker} This instance for chaining\n   */\n  start(label = 'default') {\n    if (typeof performance !== 'undefined') {\n      const markName = `${this.name}-${label}-start`;\n      performance.mark(markName);\n      this.marks[label] = {\n        start: markName\n      };\n    }\n    return this;\n  }\n\n  /**\n   * End a measurement and record the result\n   * \n   * @param {string} label - Label for the measurement (should match start label)\n   * @returns {number} Duration in milliseconds\n   */\n  end(label = 'default') {\n    if (typeof performance === 'undefined' || !this.marks[label]) {\n      return 0;\n    }\n    const startMark = this.marks[label].start;\n    const endMark = `${this.name}-${label}-end`;\n    const measureName = `${this.name}-${label}`;\n    performance.mark(endMark);\n    performance.measure(measureName, startMark, endMark);\n    const entries = performance.getEntriesByName(measureName);\n    const duration = entries.length > 0 ? entries[0].duration : 0;\n\n    // Store the measure for later reference\n    this.measures[label] = duration;\n\n    // Clean up marks\n    performance.clearMarks(startMark);\n    performance.clearMarks(endMark);\n    performance.clearMeasures(measureName);\n    return duration;\n  }\n\n  /**\n   * Get the duration of a measurement\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {number} Duration in milliseconds\n   */\n  getDuration(label = 'default') {\n    return this.measures[label] || 0;\n  }\n\n  /**\n   * Format the duration of a measurement as a string\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {string} Formatted duration\n   */\n  getFormattedDuration(label = 'default') {\n    return formatTime(this.getDuration(label));\n  }\n\n  /**\n   * Get all measurements\n   * \n   * @returns {Object} All measurements\n   */\n  getAllMeasures() {\n    return {\n      ...this.measures\n    };\n  }\n\n  /**\n   * Get all measurements formatted as strings\n   * \n   * @returns {Object} All formatted measurements\n   */\n  getAllFormattedMeasures() {\n    const formatted = {};\n    Object.entries(this.measures).forEach(([label, duration]) => {\n      formatted[label] = formatTime(duration);\n    });\n    return formatted;\n  }\n}\n\n/**\n * Create a new performance marker\n * \n * @param {string} name - Name of the marker\n * @returns {PerformanceMarker} New performance marker\n */\nexport const createPerformanceMarker = name => {\n  return new PerformanceMarker(name);\n};\n\n/**\n * Measure execution time of a function\n * \n * @param {Function} fn - Function to measure\n * @param {string} name - Name for the measurement\n * @returns {Function} Wrapped function that measures execution time\n */\nexport const measureFunction = (fn, name) => {\n  if (typeof performance === 'undefined') {\n    return fn;\n  }\n  return (...args) => {\n    const marker = createPerformanceMarker(name || fn.name || 'anonymous');\n    marker.start();\n    const result = fn(...args);\n\n    // Handle promises\n    if (result && typeof result.then === 'function') {\n      return result.then(value => {\n        const duration = marker.end();\n        console.log(`⏱️ ${name || fn.name || 'Anonymous function'} took ${formatTime(duration)}`);\n        return value;\n      });\n    }\n    const duration = marker.end();\n    console.log(`⏱️ ${name || fn.name || 'Anonymous function'} took ${formatTime(duration)}`);\n    return result;\n  };\n};\n\n/**\n * Hook to measure component render time\n * \n * @param {string} componentName - Name of the component\n * @param {Object} [options] - Options\n * @param {boolean} [options.logToConsole=true] - Whether to log to console\n * @param {Function} [options.onMeasure] - Callback when measurement completes\n * @returns {Object} Render measurements\n */\nexport const useRenderTime = (componentName, options = {}) => {\n  const {\n    logToConsole = true,\n    onMeasure\n  } = options;\n  const renderCount = useRef(0);\n  const marker = useRef(new PerformanceMarker(componentName));\n  const measurements = useRef({\n    lastRender: 0,\n    averageRender: 0,\n    totalRender: 0,\n    minRender: Infinity,\n    maxRender: 0\n  });\n\n  // Start timing on render\n  useEffect(() => {\n    marker.current.start('render');\n    return () => {\n      const duration = marker.current.end('render');\n      renderCount.current += 1;\n\n      // Update measurements\n      const mRef = measurements.current;\n      mRef.lastRender = duration;\n      mRef.totalRender += duration;\n      mRef.averageRender = mRef.totalRender / renderCount.current;\n      mRef.minRender = Math.min(mRef.minRender, duration);\n      mRef.maxRender = Math.max(mRef.maxRender, duration);\n      if (logToConsole) {\n        console.log(`⏱️ ${componentName} render #${renderCount.current}: ${formatTime(duration)}`);\n      }\n      if (onMeasure) {\n        onMeasure({\n          componentName,\n          renderCount: renderCount.current,\n          duration,\n          average: mRef.averageRender,\n          min: mRef.minRender,\n          max: mRef.maxRender\n        });\n      }\n    };\n  });\n  return {\n    renderCount: renderCount.current,\n    ...measurements.current\n  };\n};\n\n/**\n * Global performance monitor for tracking application-wide metrics\n */\nexport class PerformanceMonitor {\n  constructor() {\n    this.measurements = {};\n    this.enabled = true;\n    this.logThreshold = 50; // Log renders taking more than 50ms by default\n  }\n\n  /**\n   * Enable or disable performance monitoring\n   * \n   * @param {boolean} enabled - Whether monitoring is enabled\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n\n  /**\n   * Set the threshold for logging slow renders\n   * \n   * @param {number} threshold - Threshold in milliseconds\n   */\n  setLogThreshold(threshold) {\n    this.logThreshold = threshold;\n  }\n\n  /**\n   * Record a component render\n   * \n   * @param {string} componentName - Name of the component\n   * @param {number} duration - Render duration in milliseconds\n   */\n  recordRender(componentName, duration) {\n    if (!this.enabled) return;\n    if (!this.measurements[componentName]) {\n      this.measurements[componentName] = {\n        renderCount: 0,\n        totalRenderTime: 0,\n        averageRenderTime: 0,\n        minRenderTime: Infinity,\n        maxRenderTime: 0,\n        lastRenderTime: 0\n      };\n    }\n    const metrics = this.measurements[componentName];\n    metrics.renderCount += 1;\n    metrics.totalRenderTime += duration;\n    metrics.averageRenderTime = metrics.totalRenderTime / metrics.renderCount;\n    metrics.minRenderTime = Math.min(metrics.minRenderTime, duration);\n    metrics.maxRenderTime = Math.max(metrics.maxRenderTime, duration);\n    metrics.lastRenderTime = duration;\n\n    // Log slow renders\n    if (duration > this.logThreshold) {\n      console.warn(`⚠️ Slow render: ${componentName} took ${formatTime(duration)}`);\n    }\n  }\n\n  /**\n   * Get metrics for a specific component\n   * \n   * @param {string} componentName - Name of the component\n   * @returns {Object|null} Component metrics or null if not found\n   */\n  getComponentMetrics(componentName) {\n    return this.measurements[componentName] || null;\n  }\n\n  /**\n   * Get all component metrics\n   * \n   * @returns {Object} All component metrics\n   */\n  getAllMetrics() {\n    return {\n      ...this.measurements\n    };\n  }\n\n  /**\n   * Get the slowest components by average render time\n   * \n   * @param {number} [limit=5] - Maximum number of components to return\n   * @returns {Array} Array of [componentName, metrics] pairs\n   */\n  getSlowestComponents(limit = 5) {\n    return Object.entries(this.measurements).sort((a, b) => b[1].averageRenderTime - a[1].averageRenderTime).slice(0, limit);\n  }\n\n  /**\n   * Get components with the most renders\n   * \n   * @param {number} [limit=5] - Maximum number of components to return\n   * @returns {Array} Array of [componentName, metrics] pairs\n   */\n  getMostFrequentlyRenderedComponents(limit = 5) {\n    return Object.entries(this.measurements).sort((a, b) => b[1].renderCount - a[1].renderCount).slice(0, limit);\n  }\n\n  /**\n   * Clear all measurements\n   */\n  clear() {\n    this.measurements = {};\n  }\n}\n\n// Create a singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n/**\n * Higher-order component to measure render time\n * \n * @param {React.ComponentType} Component - Component to measure\n * @param {Object} [options] - Options\n * @returns {React.ComponentType} Wrapped component with render time measurement\n */\nexport const withRenderTime = (Component, options = {}) => {\n  const {\n    name = Component.displayName || Component.name || 'Component',\n    logToConsole = true,\n    logThreshold\n  } = options;\n  const WrappedComponent = props => {\n    useRenderTime(name, {\n      logToConsole,\n      onMeasure: ({\n        duration\n      }) => {\n        performanceMonitor.recordRender(name, duration);\n        if (logThreshold && duration > logThreshold) {\n          console.warn(`⚠️ Slow render: ${name} took ${formatTime(duration)}`);\n        }\n      }\n    });\n    return /*#__PURE__*/_jsx(Component, {\n      ...props\n    });\n  };\n  WrappedComponent.displayName = `withRenderTime(${name})`;\n  return WrappedComponent;\n};","map":{"version":3,"names":["useRef","useEffect","jsx","_jsx","formatTime","time","toFixed","PerformanceMarker","constructor","name","marks","measures","start","label","performance","markName","mark","end","startMark","endMark","measureName","measure","entries","getEntriesByName","duration","length","clearMarks","clearMeasures","getDuration","getFormattedDuration","getAllMeasures","getAllFormattedMeasures","formatted","Object","forEach","createPerformanceMarker","measureFunction","fn","args","marker","result","then","value","console","log","useRenderTime","componentName","options","logToConsole","onMeasure","renderCount","measurements","lastRender","averageRender","totalRender","minRender","Infinity","maxRender","current","mRef","Math","min","max","average","PerformanceMonitor","enabled","logThreshold","setEnabled","setLogThreshold","threshold","recordRender","totalRenderTime","averageRenderTime","minRenderTime","maxRenderTime","lastRenderTime","metrics","warn","getComponentMetrics","getAllMetrics","getSlowestComponents","limit","sort","a","b","slice","getMostFrequentlyRenderedComponents","clear","performanceMonitor","withRenderTime","Component","displayName","WrappedComponent","props"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/project/finishline/src/utils/performance.js"],"sourcesContent":["/**\n * Performance Monitoring Utilities\n * \n * Tools for measuring and optimizing component performance.\n * \n * @module utils/performance\n */\n\nimport { useRef, useEffect } from 'react';\n\n/**\n * Function to format performance time in milliseconds\n * \n * @param {number} time - Time in milliseconds\n * @returns {string} Formatted time\n */\nconst formatTime = (time) => {\n  if (time < 1) {\n    return `${(time * 1000).toFixed(2)}μs`;\n  }\n  if (time < 1000) {\n    return `${time.toFixed(2)}ms`;\n  }\n  return `${(time / 1000).toFixed(2)}s`;\n};\n\n/**\n * Performance marker class for measuring operations\n */\nexport class PerformanceMarker {\n  /**\n   * Create a new performance marker\n   * \n   * @param {string} name - Name of the marker\n   */\n  constructor(name) {\n    this.name = name;\n    this.marks = {};\n    this.measures = {};\n  }\n  \n  /**\n   * Start a measurement\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {PerformanceMarker} This instance for chaining\n   */\n  start(label = 'default') {\n    if (typeof performance !== 'undefined') {\n      const markName = `${this.name}-${label}-start`;\n      performance.mark(markName);\n      this.marks[label] = { start: markName };\n    }\n    return this;\n  }\n  \n  /**\n   * End a measurement and record the result\n   * \n   * @param {string} label - Label for the measurement (should match start label)\n   * @returns {number} Duration in milliseconds\n   */\n  end(label = 'default') {\n    if (typeof performance === 'undefined' || !this.marks[label]) {\n      return 0;\n    }\n    \n    const startMark = this.marks[label].start;\n    const endMark = `${this.name}-${label}-end`;\n    const measureName = `${this.name}-${label}`;\n    \n    performance.mark(endMark);\n    performance.measure(measureName, startMark, endMark);\n    \n    const entries = performance.getEntriesByName(measureName);\n    const duration = entries.length > 0 ? entries[0].duration : 0;\n    \n    // Store the measure for later reference\n    this.measures[label] = duration;\n    \n    // Clean up marks\n    performance.clearMarks(startMark);\n    performance.clearMarks(endMark);\n    performance.clearMeasures(measureName);\n    \n    return duration;\n  }\n  \n  /**\n   * Get the duration of a measurement\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {number} Duration in milliseconds\n   */\n  getDuration(label = 'default') {\n    return this.measures[label] || 0;\n  }\n  \n  /**\n   * Format the duration of a measurement as a string\n   * \n   * @param {string} label - Label for the measurement\n   * @returns {string} Formatted duration\n   */\n  getFormattedDuration(label = 'default') {\n    return formatTime(this.getDuration(label));\n  }\n  \n  /**\n   * Get all measurements\n   * \n   * @returns {Object} All measurements\n   */\n  getAllMeasures() {\n    return { ...this.measures };\n  }\n  \n  /**\n   * Get all measurements formatted as strings\n   * \n   * @returns {Object} All formatted measurements\n   */\n  getAllFormattedMeasures() {\n    const formatted = {};\n    Object.entries(this.measures).forEach(([label, duration]) => {\n      formatted[label] = formatTime(duration);\n    });\n    return formatted;\n  }\n}\n\n/**\n * Create a new performance marker\n * \n * @param {string} name - Name of the marker\n * @returns {PerformanceMarker} New performance marker\n */\nexport const createPerformanceMarker = (name) => {\n  return new PerformanceMarker(name);\n};\n\n/**\n * Measure execution time of a function\n * \n * @param {Function} fn - Function to measure\n * @param {string} name - Name for the measurement\n * @returns {Function} Wrapped function that measures execution time\n */\nexport const measureFunction = (fn, name) => {\n  if (typeof performance === 'undefined') {\n    return fn;\n  }\n  \n  return (...args) => {\n    const marker = createPerformanceMarker(name || fn.name || 'anonymous');\n    marker.start();\n    const result = fn(...args);\n    \n    // Handle promises\n    if (result && typeof result.then === 'function') {\n      return result.then((value) => {\n        const duration = marker.end();\n        console.log(`⏱️ ${name || fn.name || 'Anonymous function'} took ${formatTime(duration)}`);\n        return value;\n      });\n    }\n    \n    const duration = marker.end();\n    console.log(`⏱️ ${name || fn.name || 'Anonymous function'} took ${formatTime(duration)}`);\n    return result;\n  };\n};\n\n/**\n * Hook to measure component render time\n * \n * @param {string} componentName - Name of the component\n * @param {Object} [options] - Options\n * @param {boolean} [options.logToConsole=true] - Whether to log to console\n * @param {Function} [options.onMeasure] - Callback when measurement completes\n * @returns {Object} Render measurements\n */\nexport const useRenderTime = (componentName, options = {}) => {\n  const { logToConsole = true, onMeasure } = options;\n  const renderCount = useRef(0);\n  const marker = useRef(new PerformanceMarker(componentName));\n  const measurements = useRef({\n    lastRender: 0,\n    averageRender: 0,\n    totalRender: 0,\n    minRender: Infinity,\n    maxRender: 0,\n  });\n  \n  // Start timing on render\n  useEffect(() => {\n    marker.current.start('render');\n    \n    return () => {\n      const duration = marker.current.end('render');\n      renderCount.current += 1;\n      \n      // Update measurements\n      const mRef = measurements.current;\n      mRef.lastRender = duration;\n      mRef.totalRender += duration;\n      mRef.averageRender = mRef.totalRender / renderCount.current;\n      mRef.minRender = Math.min(mRef.minRender, duration);\n      mRef.maxRender = Math.max(mRef.maxRender, duration);\n      \n      if (logToConsole) {\n        console.log(`⏱️ ${componentName} render #${renderCount.current}: ${formatTime(duration)}`);\n      }\n      \n      if (onMeasure) {\n        onMeasure({\n          componentName,\n          renderCount: renderCount.current,\n          duration,\n          average: mRef.averageRender,\n          min: mRef.minRender,\n          max: mRef.maxRender,\n        });\n      }\n    };\n  });\n  \n  return {\n    renderCount: renderCount.current,\n    ...measurements.current,\n  };\n};\n\n/**\n * Global performance monitor for tracking application-wide metrics\n */\nexport class PerformanceMonitor {\n  constructor() {\n    this.measurements = {};\n    this.enabled = true;\n    this.logThreshold = 50; // Log renders taking more than 50ms by default\n  }\n  \n  /**\n   * Enable or disable performance monitoring\n   * \n   * @param {boolean} enabled - Whether monitoring is enabled\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n  \n  /**\n   * Set the threshold for logging slow renders\n   * \n   * @param {number} threshold - Threshold in milliseconds\n   */\n  setLogThreshold(threshold) {\n    this.logThreshold = threshold;\n  }\n  \n  /**\n   * Record a component render\n   * \n   * @param {string} componentName - Name of the component\n   * @param {number} duration - Render duration in milliseconds\n   */\n  recordRender(componentName, duration) {\n    if (!this.enabled) return;\n    \n    if (!this.measurements[componentName]) {\n      this.measurements[componentName] = {\n        renderCount: 0,\n        totalRenderTime: 0,\n        averageRenderTime: 0,\n        minRenderTime: Infinity,\n        maxRenderTime: 0,\n        lastRenderTime: 0,\n      };\n    }\n    \n    const metrics = this.measurements[componentName];\n    metrics.renderCount += 1;\n    metrics.totalRenderTime += duration;\n    metrics.averageRenderTime = metrics.totalRenderTime / metrics.renderCount;\n    metrics.minRenderTime = Math.min(metrics.minRenderTime, duration);\n    metrics.maxRenderTime = Math.max(metrics.maxRenderTime, duration);\n    metrics.lastRenderTime = duration;\n    \n    // Log slow renders\n    if (duration > this.logThreshold) {\n      console.warn(`⚠️ Slow render: ${componentName} took ${formatTime(duration)}`);\n    }\n  }\n  \n  /**\n   * Get metrics for a specific component\n   * \n   * @param {string} componentName - Name of the component\n   * @returns {Object|null} Component metrics or null if not found\n   */\n  getComponentMetrics(componentName) {\n    return this.measurements[componentName] || null;\n  }\n  \n  /**\n   * Get all component metrics\n   * \n   * @returns {Object} All component metrics\n   */\n  getAllMetrics() {\n    return { ...this.measurements };\n  }\n  \n  /**\n   * Get the slowest components by average render time\n   * \n   * @param {number} [limit=5] - Maximum number of components to return\n   * @returns {Array} Array of [componentName, metrics] pairs\n   */\n  getSlowestComponents(limit = 5) {\n    return Object.entries(this.measurements)\n      .sort((a, b) => b[1].averageRenderTime - a[1].averageRenderTime)\n      .slice(0, limit);\n  }\n  \n  /**\n   * Get components with the most renders\n   * \n   * @param {number} [limit=5] - Maximum number of components to return\n   * @returns {Array} Array of [componentName, metrics] pairs\n   */\n  getMostFrequentlyRenderedComponents(limit = 5) {\n    return Object.entries(this.measurements)\n      .sort((a, b) => b[1].renderCount - a[1].renderCount)\n      .slice(0, limit);\n  }\n  \n  /**\n   * Clear all measurements\n   */\n  clear() {\n    this.measurements = {};\n  }\n}\n\n// Create a singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n/**\n * Higher-order component to measure render time\n * \n * @param {React.ComponentType} Component - Component to measure\n * @param {Object} [options] - Options\n * @returns {React.ComponentType} Wrapped component with render time measurement\n */\nexport const withRenderTime = (Component, options = {}) => {\n  const { \n    name = Component.displayName || Component.name || 'Component',\n    logToConsole = true,\n    logThreshold,\n  } = options;\n  \n  const WrappedComponent = (props) => {\n    useRenderTime(name, {\n      logToConsole,\n      onMeasure: ({ duration }) => {\n        performanceMonitor.recordRender(name, duration);\n        \n        if (logThreshold && duration > logThreshold) {\n          console.warn(`⚠️ Slow render: ${name} took ${formatTime(duration)}`);\n        }\n      },\n    });\n    \n    return <Component {...props} />;\n  };\n  \n  WrappedComponent.displayName = `withRenderTime(${name})`;\n  \n  return WrappedComponent;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}