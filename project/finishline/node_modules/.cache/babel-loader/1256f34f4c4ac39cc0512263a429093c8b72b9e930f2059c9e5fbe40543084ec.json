{"ast":null,"code":"/**\n * Form Validation Utilities\n * \n * Reusable validation functions for forms.\n * \n * @module utils/validation\n */\n\n/**\n * Validate that a value is not empty\n * \n * @param {any} value - The value to validate\n * @param {string} [message='This field is required'] - Error message\n * @returns {string|undefined} Error message if validation fails, undefined otherwise\n */\nexport const required = function (value) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'This field is required';\n  if (value === undefined || value === null || value === '') {\n    return message;\n  }\n  if (Array.isArray(value) && value.length === 0) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a minimum length\n * \n * @param {number} min - Minimum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const minLength = (min, message) => value => {\n  if (value && value.length < min) {\n    return message || `Must be at least ${min} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a maximum length\n * \n * @param {number} max - Maximum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const maxLength = (max, message) => value => {\n  if (value && value.length > max) {\n    return message || `Must be no more than ${max} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches a regular expression\n * \n * @param {RegExp} pattern - Regular expression to match\n * @param {string} message - Error message\n * @returns {Function} Validation function\n */\nexport const pattern = (pattern, message) => value => {\n  if (value && !pattern.test(value)) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value is a valid email address\n * \n * @param {string} [message='Invalid email address'] - Error message\n * @returns {Function} Validation function\n */\nexport const email = function () {\n  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Invalid email address';\n  const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern(emailPattern, message);\n};\n\n/**\n * Validate that a value is a valid URL\n * \n * @param {string} [message='Invalid URL'] - Error message\n * @returns {Function} Validation function\n */\nexport const url = function () {\n  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Invalid URL';\n  const urlPattern = /^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)$/;\n  return pattern(urlPattern, message);\n};\n\n/**\n * Validate that a value is a valid phone number\n * \n * @param {string} [message='Invalid phone number'] - Error message\n * @returns {Function} Validation function\n */\nexport const phone = function () {\n  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Invalid phone number';\n  const phonePattern = /^\\+?[0-9]{10,15}$/;\n  return pattern(phonePattern, message);\n};\n\n/**\n * Validate that a value is a number\n * \n * @param {string} [message='Must be a number'] - Error message\n * @returns {Function} Validation function\n */\nexport const number = function () {\n  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Must be a number';\n  return value => {\n    if (value === '' || value === null || value === undefined) {\n      return undefined;\n    }\n    if (isNaN(Number(value))) {\n      return message;\n    }\n    return undefined;\n  };\n};\n\n/**\n * Validate that a number is within a range\n * \n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const range = (min, max, message) => value => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  const numberValue = Number(value);\n  if (isNaN(numberValue)) {\n    return 'Must be a number';\n  }\n  if (numberValue < min || numberValue > max) {\n    return message || `Must be between ${min} and ${max}`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches another field\n * \n * @param {string} field - Field to match against\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const matches = (field, message) => (value, allValues) => {\n  if (value !== allValues[field]) {\n    return message || `Must match ${field}`;\n  }\n  return undefined;\n};\n\n/**\n * Combine multiple validators\n * \n * @param {...Function} validators - Validators to combine\n * @returns {Function} Combined validation function\n */\nexport const compose = function () {\n  for (var _len = arguments.length, validators = new Array(_len), _key = 0; _key < _len; _key++) {\n    validators[_key] = arguments[_key];\n  }\n  return (value, allValues) => {\n    for (const validator of validators) {\n      const error = validator(value, allValues);\n      if (error) {\n        return error;\n      }\n    }\n    return undefined;\n  };\n};\n\n/**\n * Schema-based form validation\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function\n */\nexport const createValidator = schema => values => {\n  const errors = {};\n  Object.entries(schema).forEach(_ref => {\n    let [field, validators] = _ref;\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  return errors;\n};\n\n/**\n * Create a validator that only validates touched fields\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function that only validates touched fields\n */\nexport const createTouchedValidator = schema => function (values) {\n  let touched = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const errors = {};\n  Object.entries(schema).forEach(_ref2 => {\n    let [field, validators] = _ref2;\n    if (!touched[field]) {\n      return;\n    }\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  return errors;\n};","map":{"version":3,"names":["required","value","message","arguments","length","undefined","Array","isArray","minLength","min","maxLength","max","pattern","test","email","emailPattern","url","urlPattern","phone","phonePattern","number","isNaN","Number","range","numberValue","matches","field","allValues","compose","_len","validators","_key","validator","error","createValidator","schema","values","errors","Object","entries","forEach","_ref","validatorsArray","createTouchedValidator","touched","_ref2"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/project/finishline/src/utils/validation.js"],"sourcesContent":["/**\n * Form Validation Utilities\n * \n * Reusable validation functions for forms.\n * \n * @module utils/validation\n */\n\n/**\n * Validate that a value is not empty\n * \n * @param {any} value - The value to validate\n * @param {string} [message='This field is required'] - Error message\n * @returns {string|undefined} Error message if validation fails, undefined otherwise\n */\nexport const required = (value, message = 'This field is required') => {\n  if (value === undefined || value === null || value === '') {\n    return message;\n  }\n  \n  if (Array.isArray(value) && value.length === 0) {\n    return message;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a value has a minimum length\n * \n * @param {number} min - Minimum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const minLength = (min, message) => (value) => {\n  if (value && value.length < min) {\n    return message || `Must be at least ${min} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a maximum length\n * \n * @param {number} max - Maximum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const maxLength = (max, message) => (value) => {\n  if (value && value.length > max) {\n    return message || `Must be no more than ${max} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches a regular expression\n * \n * @param {RegExp} pattern - Regular expression to match\n * @param {string} message - Error message\n * @returns {Function} Validation function\n */\nexport const pattern = (pattern, message) => (value) => {\n  if (value && !pattern.test(value)) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value is a valid email address\n * \n * @param {string} [message='Invalid email address'] - Error message\n * @returns {Function} Validation function\n */\nexport const email = (message = 'Invalid email address') => {\n  const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern(emailPattern, message);\n};\n\n/**\n * Validate that a value is a valid URL\n * \n * @param {string} [message='Invalid URL'] - Error message\n * @returns {Function} Validation function\n */\nexport const url = (message = 'Invalid URL') => {\n  const urlPattern = /^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)$/;\n  return pattern(urlPattern, message);\n};\n\n/**\n * Validate that a value is a valid phone number\n * \n * @param {string} [message='Invalid phone number'] - Error message\n * @returns {Function} Validation function\n */\nexport const phone = (message = 'Invalid phone number') => {\n  const phonePattern = /^\\+?[0-9]{10,15}$/;\n  return pattern(phonePattern, message);\n};\n\n/**\n * Validate that a value is a number\n * \n * @param {string} [message='Must be a number'] - Error message\n * @returns {Function} Validation function\n */\nexport const number = (message = 'Must be a number') => (value) => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  \n  if (isNaN(Number(value))) {\n    return message;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a number is within a range\n * \n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const range = (min, max, message) => (value) => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  \n  const numberValue = Number(value);\n  \n  if (isNaN(numberValue)) {\n    return 'Must be a number';\n  }\n  \n  if (numberValue < min || numberValue > max) {\n    return message || `Must be between ${min} and ${max}`;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a value matches another field\n * \n * @param {string} field - Field to match against\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const matches = (field, message) => (value, allValues) => {\n  if (value !== allValues[field]) {\n    return message || `Must match ${field}`;\n  }\n  return undefined;\n};\n\n/**\n * Combine multiple validators\n * \n * @param {...Function} validators - Validators to combine\n * @returns {Function} Combined validation function\n */\nexport const compose = (...validators) => (value, allValues) => {\n  for (const validator of validators) {\n    const error = validator(value, allValues);\n    if (error) {\n      return error;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Schema-based form validation\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function\n */\nexport const createValidator = (schema) => (values) => {\n  const errors = {};\n  \n  Object.entries(schema).forEach(([field, validators]) => {\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    \n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  \n  return errors;\n};\n\n/**\n * Create a validator that only validates touched fields\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function that only validates touched fields\n */\nexport const createTouchedValidator = (schema) => (values, touched = {}) => {\n  const errors = {};\n  \n  Object.entries(schema).forEach(([field, validators]) => {\n    if (!touched[field]) {\n      return;\n    }\n    \n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    \n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  \n  return errors;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}