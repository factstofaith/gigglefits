{"ast":null,"code":"/**\n * useForm Hook\n * \n * Custom hook for managing form state with validation.\n * \n * @module hooks/useForm\n */\n\nimport { useState, useCallback, useMemo, useEffect } from 'react';\n\n/**\n * Form validation hook\n *\n * @param {Object} initialValues - Initial form values\n * @param {Function} validate - Validation function\n * @param {Function} [onSubmit] - Submit handler function\n * @param {Object} [options] - Additional options\n * @param {boolean} [options.validateOnChange=true] - Whether to validate on change\n * @param {boolean} [options.validateOnBlur=true] - Whether to validate on blur\n * @param {boolean} [options.validateOnMount=false] - Whether to validate on mount\n * @returns {Object} Form state and handlers\n */\nfunction useForm() {\n  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let validate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => ({});\n  let onSubmit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // Set default options\n  const {\n    validateOnChange = true,\n    validateOnBlur = true,\n    validateOnMount = false\n  } = options;\n\n  // Form state\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [submitCount, setSubmitCount] = useState(0);\n\n  // Track if form has been modified\n  const [dirty, setDirty] = useState(false);\n\n  // Helper to run validation\n  const validateForm = useCallback(() => {\n    const validationErrors = validate(values);\n    setErrors(validationErrors);\n    return validationErrors;\n  }, [values, validate]);\n\n  // Validate on mount if option enabled\n  useEffect(() => {\n    if (validateOnMount) {\n      validateForm();\n    }\n  }, [validateOnMount, validateForm]);\n\n  // Handle field change\n  const handleChange = useCallback(event => {\n    const {\n      name,\n      value,\n      type,\n      checked\n    } = event.target;\n\n    // Get appropriate value based on input type\n    const fieldValue = type === 'checkbox' ? checked : value;\n    setValues(prevValues => ({\n      ...prevValues,\n      [name]: fieldValue\n    }));\n    setDirty(true);\n\n    // Validate on change if enabled\n    if (validateOnChange) {\n      const fieldTouched = {\n        [name]: true\n      };\n      setTouched(prev => ({\n        ...prev,\n        ...fieldTouched\n      }));\n      const validationErrors = validate({\n        ...values,\n        [name]: fieldValue\n      });\n      setErrors(validationErrors);\n    }\n  }, [values, validateOnChange, validate]);\n\n  // Set a field value programmatically\n  const setFieldValue = useCallback((name, value) => {\n    setValues(prevValues => ({\n      ...prevValues,\n      [name]: value\n    }));\n    setDirty(true);\n\n    // Validate on change if enabled\n    if (validateOnChange) {\n      const validationErrors = validate({\n        ...values,\n        [name]: value\n      });\n      setErrors(validationErrors);\n    }\n  }, [values, validateOnChange, validate]);\n\n  // Handle field blur\n  const handleBlur = useCallback(event => {\n    const {\n      name\n    } = event.target;\n    const fieldTouched = {\n      [name]: true\n    };\n    setTouched(prev => ({\n      ...prev,\n      ...fieldTouched\n    }));\n\n    // Validate on blur if enabled\n    if (validateOnBlur) {\n      const validationErrors = validate(values);\n      setErrors(validationErrors);\n    }\n  }, [values, validateOnBlur, validate]);\n\n  // Reset form to initial state or new values\n  const resetForm = useCallback(function () {\n    let newValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialValues;\n    setValues(newValues);\n    setErrors({});\n    setTouched({});\n    setDirty(false);\n    setIsSubmitting(false);\n  }, [initialValues]);\n\n  // Handle form submission\n  const handleSubmit = useCallback(async event => {\n    if (event) {\n      event.preventDefault();\n    }\n    setSubmitCount(prev => prev + 1);\n\n    // Validate all fields\n    const validationErrors = validateForm();\n\n    // Mark all fields as touched\n    const allTouched = Object.keys(values).reduce((touched, field) => ({\n      ...touched,\n      [field]: true\n    }), {});\n    setTouched(allTouched);\n\n    // Check if there are any errors\n    const hasErrors = Object.keys(validationErrors).length > 0;\n    if (!hasErrors) {\n      setIsSubmitting(true);\n      try {\n        await onSubmit(values);\n      } catch (error) {\n        console.error('Form submission error:', error);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n    return !hasErrors;\n  }, [values, validateForm, onSubmit]);\n\n  // Computed flag for whether the form is valid\n  const isValid = useMemo(() => {\n    return Object.keys(errors).length === 0;\n  }, [errors]);\n\n  // Get props for a field\n  const getFieldProps = useCallback(name => {\n    return {\n      name,\n      id: name,\n      value: values[name] || '',\n      onChange: handleChange,\n      onBlur: handleBlur,\n      'aria-invalid': errors[name] ? 'true' : 'false',\n      'aria-describedby': errors[name] ? `${name}-error` : undefined\n    };\n  }, [values, errors, handleChange, handleBlur]);\n\n  // Get meta information for a field\n  const getFieldMeta = useCallback(name => {\n    return {\n      value: values[name],\n      error: errors[name],\n      touched: !!touched[name],\n      isDirty: dirty && values[name] !== initialValues[name]\n    };\n  }, [values, errors, touched, dirty, initialValues]);\n\n  // Get helper methods for a field\n  const getFieldHelpers = useCallback(name => {\n    return {\n      setValue: value => setFieldValue(name, value),\n      setTouched: function () {\n        let isTouched = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        setTouched(prev => ({\n          ...prev,\n          [name]: isTouched\n        }));\n      },\n      setError: error => {\n        setErrors(prev => ({\n          ...prev,\n          [name]: error\n        }));\n      }\n    };\n  }, [setFieldValue]);\n  return {\n    // Form state\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isDirty: dirty,\n    isValid,\n    submitCount,\n    // Form actions\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    setFieldValue,\n    resetForm,\n    // Field helpers\n    getFieldProps,\n    getFieldMeta,\n    getFieldHelpers\n  };\n}\nexport default useForm;","map":{"version":3,"names":["useState","useCallback","useMemo","useEffect","useForm","initialValues","arguments","length","undefined","validate","onSubmit","options","validateOnChange","validateOnBlur","validateOnMount","values","setValues","errors","setErrors","touched","setTouched","isSubmitting","setIsSubmitting","submitCount","setSubmitCount","dirty","setDirty","validateForm","validationErrors","handleChange","event","name","value","type","checked","target","fieldValue","prevValues","fieldTouched","prev","setFieldValue","handleBlur","resetForm","newValues","handleSubmit","preventDefault","allTouched","Object","keys","reduce","field","hasErrors","error","console","isValid","getFieldProps","id","onChange","onBlur","getFieldMeta","isDirty","getFieldHelpers","setValue","isTouched","setError"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/project/finishline/src/hooks/useForm.js"],"sourcesContent":["/**\n * useForm Hook\n * \n * Custom hook for managing form state with validation.\n * \n * @module hooks/useForm\n */\n\nimport { useState, useCallback, useMemo, useEffect } from 'react';\n\n/**\n * Form validation hook\n *\n * @param {Object} initialValues - Initial form values\n * @param {Function} validate - Validation function\n * @param {Function} [onSubmit] - Submit handler function\n * @param {Object} [options] - Additional options\n * @param {boolean} [options.validateOnChange=true] - Whether to validate on change\n * @param {boolean} [options.validateOnBlur=true] - Whether to validate on blur\n * @param {boolean} [options.validateOnMount=false] - Whether to validate on mount\n * @returns {Object} Form state and handlers\n */\nfunction useForm(initialValues = {}, validate = () => ({}), onSubmit = () => {}, options = {}) {\n  // Set default options\n  const {\n    validateOnChange = true,\n    validateOnBlur = true,\n    validateOnMount = false,\n  } = options;\n  \n  // Form state\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [submitCount, setSubmitCount] = useState(0);\n  \n  // Track if form has been modified\n  const [dirty, setDirty] = useState(false);\n  \n  // Helper to run validation\n  const validateForm = useCallback(() => {\n    const validationErrors = validate(values);\n    setErrors(validationErrors);\n    return validationErrors;\n  }, [values, validate]);\n  \n  // Validate on mount if option enabled\n  useEffect(() => {\n    if (validateOnMount) {\n      validateForm();\n    }\n  }, [validateOnMount, validateForm]);\n  \n  // Handle field change\n  const handleChange = useCallback((event) => {\n    const { name, value, type, checked } = event.target;\n    \n    // Get appropriate value based on input type\n    const fieldValue = type === 'checkbox' ? checked : value;\n    \n    setValues(prevValues => ({\n      ...prevValues,\n      [name]: fieldValue,\n    }));\n    \n    setDirty(true);\n    \n    // Validate on change if enabled\n    if (validateOnChange) {\n      const fieldTouched = { [name]: true };\n      setTouched(prev => ({ ...prev, ...fieldTouched }));\n      \n      const validationErrors = validate({\n        ...values,\n        [name]: fieldValue,\n      });\n      \n      setErrors(validationErrors);\n    }\n  }, [values, validateOnChange, validate]);\n  \n  // Set a field value programmatically\n  const setFieldValue = useCallback((name, value) => {\n    setValues(prevValues => ({\n      ...prevValues,\n      [name]: value,\n    }));\n    \n    setDirty(true);\n    \n    // Validate on change if enabled\n    if (validateOnChange) {\n      const validationErrors = validate({\n        ...values,\n        [name]: value,\n      });\n      \n      setErrors(validationErrors);\n    }\n  }, [values, validateOnChange, validate]);\n  \n  // Handle field blur\n  const handleBlur = useCallback((event) => {\n    const { name } = event.target;\n    \n    const fieldTouched = { [name]: true };\n    setTouched(prev => ({ ...prev, ...fieldTouched }));\n    \n    // Validate on blur if enabled\n    if (validateOnBlur) {\n      const validationErrors = validate(values);\n      setErrors(validationErrors);\n    }\n  }, [values, validateOnBlur, validate]);\n  \n  // Reset form to initial state or new values\n  const resetForm = useCallback((newValues = initialValues) => {\n    setValues(newValues);\n    setErrors({});\n    setTouched({});\n    setDirty(false);\n    setIsSubmitting(false);\n  }, [initialValues]);\n  \n  // Handle form submission\n  const handleSubmit = useCallback(async (event) => {\n    if (event) {\n      event.preventDefault();\n    }\n    \n    setSubmitCount(prev => prev + 1);\n    \n    // Validate all fields\n    const validationErrors = validateForm();\n    \n    // Mark all fields as touched\n    const allTouched = Object.keys(values).reduce(\n      (touched, field) => ({ ...touched, [field]: true }),\n      {}\n    );\n    setTouched(allTouched);\n    \n    // Check if there are any errors\n    const hasErrors = Object.keys(validationErrors).length > 0;\n    \n    if (!hasErrors) {\n      setIsSubmitting(true);\n      \n      try {\n        await onSubmit(values);\n      } catch (error) {\n        console.error('Form submission error:', error);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n    \n    return !hasErrors;\n  }, [values, validateForm, onSubmit]);\n  \n  // Computed flag for whether the form is valid\n  const isValid = useMemo(() => {\n    return Object.keys(errors).length === 0;\n  }, [errors]);\n  \n  // Get props for a field\n  const getFieldProps = useCallback((name) => {\n    return {\n      name,\n      id: name,\n      value: values[name] || '',\n      onChange: handleChange,\n      onBlur: handleBlur,\n      'aria-invalid': errors[name] ? 'true' : 'false',\n      'aria-describedby': errors[name] ? `${name}-error` : undefined,\n    };\n  }, [values, errors, handleChange, handleBlur]);\n  \n  // Get meta information for a field\n  const getFieldMeta = useCallback((name) => {\n    return {\n      value: values[name],\n      error: errors[name],\n      touched: !!touched[name],\n      isDirty: dirty && values[name] !== initialValues[name],\n    };\n  }, [values, errors, touched, dirty, initialValues]);\n  \n  // Get helper methods for a field\n  const getFieldHelpers = useCallback((name) => {\n    return {\n      setValue: (value) => setFieldValue(name, value),\n      setTouched: (isTouched = true) => {\n        setTouched(prev => ({ ...prev, [name]: isTouched }));\n      },\n      setError: (error) => {\n        setErrors(prev => ({ ...prev, [name]: error }));\n      },\n    };\n  }, [setFieldValue]);\n  \n  return {\n    // Form state\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isDirty: dirty,\n    isValid,\n    submitCount,\n    \n    // Form actions\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    setFieldValue,\n    resetForm,\n    \n    // Field helpers\n    getFieldProps,\n    getFieldMeta,\n    getFieldHelpers,\n  };\n}\n\nexport default useForm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}