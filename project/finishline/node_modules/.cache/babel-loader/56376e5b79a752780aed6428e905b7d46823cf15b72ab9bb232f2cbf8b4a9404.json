{"ast":null,"code":"/**\n * Form Validation Utilities\n * \n * Reusable validation functions for forms.\n * \n * @module utils/validation\n */\n\n/**\n * Validate that a value is not empty\n * \n * @param {any} value - The value to validate\n * @param {string} [message='This field is required'] - Error message\n * @returns {string|undefined} Error message if validation fails, undefined otherwise\n */\nexport const required = (value, message = 'This field is required') => {\n  if (value === undefined || value === null || value === '') {\n    return message;\n  }\n  if (Array.isArray(value) && value.length === 0) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a minimum length\n * \n * @param {number} min - Minimum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const minLength = (min, message) => value => {\n  if (value && value.length < min) {\n    return message || `Must be at least ${min} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a maximum length\n * \n * @param {number} max - Maximum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const maxLength = (max, message) => value => {\n  if (value && value.length > max) {\n    return message || `Must be no more than ${max} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches a regular expression\n * \n * @param {RegExp} pattern - Regular expression to match\n * @param {string} message - Error message\n * @returns {Function} Validation function\n */\nexport const pattern = (pattern, message) => value => {\n  if (value && !pattern.test(value)) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value is a valid email address\n * \n * @param {string} [message='Invalid email address'] - Error message\n * @returns {Function} Validation function\n */\nexport const email = (message = 'Invalid email address') => {\n  const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern(emailPattern, message);\n};\n\n/**\n * Validate that a value is a valid URL\n * \n * @param {string} [message='Invalid URL'] - Error message\n * @returns {Function} Validation function\n */\nexport const url = (message = 'Invalid URL') => {\n  const urlPattern = /^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)$/;\n  return pattern(urlPattern, message);\n};\n\n/**\n * Validate that a value is a valid phone number\n * \n * @param {string} [message='Invalid phone number'] - Error message\n * @returns {Function} Validation function\n */\nexport const phone = (message = 'Invalid phone number') => {\n  const phonePattern = /^\\+?[0-9]{10,15}$/;\n  return pattern(phonePattern, message);\n};\n\n/**\n * Validate that a value is a number\n * \n * @param {string} [message='Must be a number'] - Error message\n * @returns {Function} Validation function\n */\nexport const number = (message = 'Must be a number') => value => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  if (isNaN(Number(value))) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a number is within a range\n * \n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const range = (min, max, message) => value => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  const numberValue = Number(value);\n  if (isNaN(numberValue)) {\n    return 'Must be a number';\n  }\n  if (numberValue < min || numberValue > max) {\n    return message || `Must be between ${min} and ${max}`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches another field\n * \n * @param {string} field - Field to match against\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const matches = (field, message) => (value, allValues) => {\n  if (value !== allValues[field]) {\n    return message || `Must match ${field}`;\n  }\n  return undefined;\n};\n\n/**\n * Combine multiple validators\n * \n * @param {...Function} validators - Validators to combine\n * @returns {Function} Combined validation function\n */\nexport const compose = (...validators) => (value, allValues) => {\n  for (const validator of validators) {\n    const error = validator(value, allValues);\n    if (error) {\n      return error;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Schema-based form validation\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function\n */\nexport const createValidator = schema => values => {\n  const errors = {};\n  Object.entries(schema).forEach(([field, validators]) => {\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  return errors;\n};\n\n/**\n * Create a validator that only validates touched fields\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function that only validates touched fields\n */\nexport const createTouchedValidator = schema => (values, touched = {}) => {\n  const errors = {};\n  Object.entries(schema).forEach(([field, validators]) => {\n    if (!touched[field]) {\n      return;\n    }\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  return errors;\n};","map":{"version":3,"names":["required","value","message","undefined","Array","isArray","length","minLength","min","maxLength","max","pattern","test","email","emailPattern","url","urlPattern","phone","phonePattern","number","isNaN","Number","range","numberValue","matches","field","allValues","compose","validators","validator","error","createValidator","schema","values","errors","Object","entries","forEach","validatorsArray","createTouchedValidator","touched"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/project/finishline/src/utils/validation.js"],"sourcesContent":["/**\n * Form Validation Utilities\n * \n * Reusable validation functions for forms.\n * \n * @module utils/validation\n */\n\n/**\n * Validate that a value is not empty\n * \n * @param {any} value - The value to validate\n * @param {string} [message='This field is required'] - Error message\n * @returns {string|undefined} Error message if validation fails, undefined otherwise\n */\nexport const required = (value, message = 'This field is required') => {\n  if (value === undefined || value === null || value === '') {\n    return message;\n  }\n  \n  if (Array.isArray(value) && value.length === 0) {\n    return message;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a value has a minimum length\n * \n * @param {number} min - Minimum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const minLength = (min, message) => (value) => {\n  if (value && value.length < min) {\n    return message || `Must be at least ${min} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value has a maximum length\n * \n * @param {number} max - Maximum length\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const maxLength = (max, message) => (value) => {\n  if (value && value.length > max) {\n    return message || `Must be no more than ${max} characters`;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value matches a regular expression\n * \n * @param {RegExp} pattern - Regular expression to match\n * @param {string} message - Error message\n * @returns {Function} Validation function\n */\nexport const pattern = (pattern, message) => (value) => {\n  if (value && !pattern.test(value)) {\n    return message;\n  }\n  return undefined;\n};\n\n/**\n * Validate that a value is a valid email address\n * \n * @param {string} [message='Invalid email address'] - Error message\n * @returns {Function} Validation function\n */\nexport const email = (message = 'Invalid email address') => {\n  const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern(emailPattern, message);\n};\n\n/**\n * Validate that a value is a valid URL\n * \n * @param {string} [message='Invalid URL'] - Error message\n * @returns {Function} Validation function\n */\nexport const url = (message = 'Invalid URL') => {\n  const urlPattern = /^(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)$/;\n  return pattern(urlPattern, message);\n};\n\n/**\n * Validate that a value is a valid phone number\n * \n * @param {string} [message='Invalid phone number'] - Error message\n * @returns {Function} Validation function\n */\nexport const phone = (message = 'Invalid phone number') => {\n  const phonePattern = /^\\+?[0-9]{10,15}$/;\n  return pattern(phonePattern, message);\n};\n\n/**\n * Validate that a value is a number\n * \n * @param {string} [message='Must be a number'] - Error message\n * @returns {Function} Validation function\n */\nexport const number = (message = 'Must be a number') => (value) => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  \n  if (isNaN(Number(value))) {\n    return message;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a number is within a range\n * \n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const range = (min, max, message) => (value) => {\n  if (value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  \n  const numberValue = Number(value);\n  \n  if (isNaN(numberValue)) {\n    return 'Must be a number';\n  }\n  \n  if (numberValue < min || numberValue > max) {\n    return message || `Must be between ${min} and ${max}`;\n  }\n  \n  return undefined;\n};\n\n/**\n * Validate that a value matches another field\n * \n * @param {string} field - Field to match against\n * @param {string} [message] - Error message\n * @returns {Function} Validation function\n */\nexport const matches = (field, message) => (value, allValues) => {\n  if (value !== allValues[field]) {\n    return message || `Must match ${field}`;\n  }\n  return undefined;\n};\n\n/**\n * Combine multiple validators\n * \n * @param {...Function} validators - Validators to combine\n * @returns {Function} Combined validation function\n */\nexport const compose = (...validators) => (value, allValues) => {\n  for (const validator of validators) {\n    const error = validator(value, allValues);\n    if (error) {\n      return error;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Schema-based form validation\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function\n */\nexport const createValidator = (schema) => (values) => {\n  const errors = {};\n  \n  Object.entries(schema).forEach(([field, validators]) => {\n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    \n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  \n  return errors;\n};\n\n/**\n * Create a validator that only validates touched fields\n * \n * @param {Object} schema - Validation schema\n * @returns {Function} Form validation function that only validates touched fields\n */\nexport const createTouchedValidator = (schema) => (values, touched = {}) => {\n  const errors = {};\n  \n  Object.entries(schema).forEach(([field, validators]) => {\n    if (!touched[field]) {\n      return;\n    }\n    \n    const value = values[field];\n    const validatorsArray = Array.isArray(validators) ? validators : [validators];\n    \n    for (const validator of validatorsArray) {\n      const error = validator(value, values);\n      if (error) {\n        errors[field] = error;\n        break;\n      }\n    }\n  });\n  \n  return errors;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}