/**
 * React 18 Compatibility Adapter for react-json-view
 * 
 * This adapter provides a Higher-Order Component (HOC) wrapper for components
 * from the react-json-view library to ensure compatibility with React 18.
 * 
 * Features:
 * - Error boundary to catch and handle rendering errors
 * - Fallback components when rendering fails
 * - Version compatibility layer
 * 
 * Generated by react-compat adapter generator
 */

import React, { useState, useEffect, forwardRef } from 'react';

// Import the original library components
// We use a try-catch to handle potential import errors
let reactJsonView = null;
try {
  reactJsonView = require('react-json-view');
} catch (error) {
  console.warn(`Error importing react-json-view: ${error.message}`);
}

// Error boundary component for catching render errors
class ReactCompatErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.warn(`Error rendering react-json-view component: ${error.message}`);
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback(this.state.error);
      }
      return <div className="react-compat-error">
        <p>Failed to render component</p>
        {this.props.showError && <p className="error-message">{this.state.error?.message}</p>}
      </div>;
    }

    return this.props.children;
  }
}

// Helper function to create adapter HOC
function createAdapter(Component, options = {}) {
  if (!Component) {
    // Return empty component if the original is not available
    return forwardRef((props, ref) => {
      if (options.fallback) {
        return options.fallback(props);
      }
      return null;
    });
  }

  // Create the adapter component
  const AdapterComponent = forwardRef((props, ref) => {
    const [isCompatible, setIsCompatible] = useState(true);
    
    // Check if we're in React 18
    useEffect(() => {
      try {
        // This is a simple check - in real world, you might need more robust detection
        const reactDomVersion = React.version.split('.')[0];
        setIsCompatible(parseInt(reactDomVersion, 10) < 18);
      } catch (error) {
        setIsCompatible(true); // Assume compatible if we can't check
      }
    }, []);
    
    return (
      <ReactCompatErrorBoundary 
        fallback={options.fallback}
        showError={options.showError}
        onError={options.onError}
      >
        <Component {...props} ref={ref} />
      </ReactCompatErrorBoundary>
    );
  });
  
  // Copy over static properties and displayName
  AdapterComponent.displayName = `react-json-viewAdapter(${Component.displayName || Component.name || 'Component'})`;
  
  // Copy static methods if any
  if (Component) {
    Object.keys(Component).forEach(key => {
      if (key !== 'displayName' && typeof Component[key] === 'function') {
        AdapterComponent[key] = Component[key];
      }
    });
  }
  
  return AdapterComponent;
}

// Create fallback components
const defaultFallback = () => (
  <div className="react-compat-fallback">
    Component unavailable
  </div>
);

// Create adapters for each component
const adapters = {};

// ReactJson adapter
export const ReactJsonAdapter = reactJsonView ? createAdapter(reactJsonView.ReactJson, {
  fallback: (error) => <div className="react-compat-fallback-reactjson">
    ReactJson component could not be rendered
    {error && <div className="error-details">{error.message}</div>}
  </div>,
  showError: process.env.NODE_ENV !== 'production'
}) : createAdapter(null, {
  fallback: defaultFallback
});
adapters.ReactJsonAdapter = ReactJsonAdapter;

// Export all adapters
export default adapters;
