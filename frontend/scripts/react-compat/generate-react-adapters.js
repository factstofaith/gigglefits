#!/usr/bin/env node
/**
 * React 18 Adapter Component Generator
 * 
 * This script generates adapter components for libraries with known
 * React 18 compatibility issues. It creates HOC wrappers with error
 * boundaries to safely isolate problematic components.
 * 
 * Usage:
 *   node generate-react-adapters.js [options]
 * 
 * Options:
 *   --dry-run              Preview changes without writing files
 *   --verbose              Show detailed information during execution
 *   --input=<file>         Specify input analysis file (default: analysis_output/react-compat/react-compat-analysis.json)
 *   --output=<dir>         Specify output directory for adapter components (default: src/utils/react-compat-adapters)
 *   --library=<name>       Generate adapter only for specified library
 *   --create-index         Create/update index.js export file
 * 
 * Example:
 *   node generate-react-adapters.js --library=react-json-view
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2);
const DRY_RUN = args.includes('--dry-run');
const VERBOSE = args.includes('--verbose');
const CREATE_INDEX = args.includes('--create-index');
const INPUT_FILE = args.find(arg => arg.startsWith('--input='))?.split('=')[1] || 'analysis_output/react-compat/react-compat-analysis.json';
const OUTPUT_DIR = args.find(arg => arg.startsWith('--output='))?.split('=')[1] || 'src/utils/react-compat-adapters';
const TARGET_LIBRARY = args.find(arg => arg.startsWith('--library='))?.split('=')[1];

// Utility functions
function log(message, type = 'info') {
  const prefix = type === 'error' ? '❌ ' : 
                 type === 'success' ? '✅ ' : 
                 type === 'warning' ? '⚠️ ' : 
                 type === 'info' ? 'ℹ️ ' : '';
  console.log(`${prefix}${message}`);
}

function logVerbose(message) {
  if (VERBOSE) {
    console.log(`   ${message}`);
  }
}

// Create output directory if it doesn't exist
if (!DRY_RUN) {
  try {
    fs.mkdirSync(path.resolve(process.cwd(), OUTPUT_DIR), { recursive: true });
  } catch (error) {
    log(`Error creating output directory: ${error.message}`, 'error');
    process.exit(1);
  }
}

// Load analysis data
function loadAnalysisData() {
  log(`Loading analysis data from ${INPUT_FILE}...`, 'info');
  
  try {
    const analysisPath = path.resolve(process.cwd(), INPUT_FILE);
    if (!fs.existsSync(analysisPath)) {
      log(`Analysis file not found: ${analysisPath}`, 'error');
      log(`Run analyze-react-dependencies.js first to generate analysis data`, 'info');
      process.exit(1);
    }
    
    return JSON.parse(fs.readFileSync(analysisPath, 'utf8'));
  } catch (error) {
    log(`Error loading analysis data: ${error.message}`, 'error');
    process.exit(1);
  }
}

// Template for the React adapter HOC
function generateAdapterTemplate(library, components) {
  const libraryVarName = library.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  const componentsList = components.map(c => `  ${c}`).join(',\n');
  
  return `/**
 * React 18 Compatibility Adapter for ${library}
 * 
 * This adapter provides a Higher-Order Component (HOC) wrapper for components
 * from the ${library} library to ensure compatibility with React 18.
 * 
 * Features:
 * - Error boundary to catch and handle rendering errors
 * - Fallback components when rendering fails
 * - Version compatibility layer
 * 
 * Generated by react-compat adapter generator
 */

import React, { useState, useEffect, forwardRef } from 'react';

// Import the original library components
// We use a try-catch to handle potential import errors
let ${libraryVarName} = null;
try {
  ${libraryVarName} = require('${library}');
} catch (error) {
  console.warn(\`Error importing ${library}: \${error.message}\`);
}

// Error boundary component for catching render errors
class ReactCompatErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.warn(\`Error rendering ${library} component: \${error.message}\`);
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback(this.state.error);
      }
      return <div className="react-compat-error">
        <p>Failed to render component</p>
        {this.props.showError && <p className="error-message">{this.state.error?.message}</p>}
      </div>;
    }

    return this.props.children;
  }
}

// Helper function to create adapter HOC
function createAdapter(Component, options = {}) {
  if (!Component) {
    // Return empty component if the original is not available
    return forwardRef((props, ref) => {
      if (options.fallback) {
        return options.fallback(props);
      }
      return null;
    });
  }

  // Create the adapter component
  const AdapterComponent = forwardRef((props, ref) => {
    const [isCompatible, setIsCompatible] = useState(true);
    
    // Check if we're in React 18
    useEffect(() => {
      try {
        // This is a simple check - in real world, you might need more robust detection
        const reactDomVersion = React.version.split('.')[0];
        setIsCompatible(parseInt(reactDomVersion, 10) < 18);
      } catch (error) {
        setIsCompatible(true); // Assume compatible if we can't check
      }
    }, []);
    
    return (
      <ReactCompatErrorBoundary 
        fallback={options.fallback}
        showError={options.showError}
        onError={options.onError}
      >
        <Component {...props} ref={ref} />
      </ReactCompatErrorBoundary>
    );
  });
  
  // Copy over static properties and displayName
  AdapterComponent.displayName = \`${library}Adapter(\${Component.displayName || Component.name || 'Component'})\`;
  
  // Copy static methods if any
  if (Component) {
    Object.keys(Component).forEach(key => {
      if (key !== 'displayName' && typeof Component[key] === 'function') {
        AdapterComponent[key] = Component[key];
      }
    });
  }
  
  return AdapterComponent;
}

// Create fallback components
const defaultFallback = () => (
  <div className="react-compat-fallback">
    Component unavailable
  </div>
);

// Create adapters for each component
const adapters = {};

${
  components.map(component => {
    return `// ${component} adapter
export const ${component}Adapter = ${libraryVarName} ? createAdapter(${libraryVarName}.${component}, {
  fallback: (error) => <div className="react-compat-fallback-${component.toLowerCase()}">
    ${component} component could not be rendered
    {error && <div className="error-details">{error.message}</div>}
  </div>,
  showError: process.env.NODE_ENV !== 'production'
}) : createAdapter(null, {
  fallback: defaultFallback
});
adapters.${component}Adapter = ${component}Adapter;`;
  }).join('\n\n')
}

// Export all adapters
export default adapters;
`;
}

// Template for the index.js file
function generateIndexTemplate(libraries) {
  return `/**
 * React 18 Compatibility Adapters
 * 
 * This index file exports all adapter components for libraries
 * with React 18 compatibility issues.
 * 
 * Generated by react-compat adapter generator
 */

${
  libraries.map(lib => {
    const libName = lib.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    return `import ${libName}Adapters from './${lib}-adapter';`;
  }).join('\n')
}

// Export all adapters
export {
${
  libraries.map(lib => {
    const libName = lib.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    return `  ${libName}Adapters,`;
  }).join('\n')
}
};

// Export individual adapters for convenience
${
  libraries.map(lib => {
    const libName = lib.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    return `export * from './${lib}-adapter';`;
  }).join('\n')
}
`;
}

// Generate adapter file for a library
function generateLibraryAdapter(library, components) {
  const fileName = `${library}-adapter.js`;
  const filePath = path.resolve(process.cwd(), OUTPUT_DIR, fileName);
  const content = generateAdapterTemplate(library, components);
  
  if (DRY_RUN) {
    log(`Would create adapter for ${library} with ${components.length} components`, 'info');
    logVerbose(`Would write to: ${filePath}`);
    if (VERBOSE) {
      console.log('\n--- Preview of file content ---\n');
      console.log(content.slice(0, 500) + '...');
      console.log('\n--- End of preview ---\n');
    }
    return true;
  }
  
  try {
    fs.writeFileSync(filePath, content, 'utf8');
    log(`Created adapter for ${library} with ${components.length} components`, 'success');
    logVerbose(`Written to: ${filePath}`);
    return true;
  } catch (error) {
    log(`Error creating adapter for ${library}: ${error.message}`, 'error');
    return false;
  }
}

// Create index.js file
function generateIndexFile(libraries) {
  const filePath = path.resolve(process.cwd(), OUTPUT_DIR, 'index.js');
  const content = generateIndexTemplate(libraries);
  
  if (DRY_RUN) {
    log(`Would create index.js with exports for ${libraries.length} libraries`, 'info');
    logVerbose(`Would write to: ${filePath}`);
    if (VERBOSE) {
      console.log('\n--- Preview of file content ---\n');
      console.log(content.slice(0, 500) + '...');
      console.log('\n--- End of preview ---\n');
    }
    return;
  }
  
  try {
    fs.writeFileSync(filePath, content, 'utf8');
    log(`Created index.js with exports for ${libraries.length} libraries`, 'success');
    logVerbose(`Written to: ${filePath}`);
  } catch (error) {
    log(`Error creating index.js: ${error.message}`, 'error');
  }
}

// Main execution
async function main() {
  log(`Starting React adapter component generation ${DRY_RUN ? '(DRY RUN)' : ''}`, 'info');
  
  // Load analysis data
  const analysisData = loadAnalysisData();
  const { componentUsage } = analysisData.codeAnalysis;
  
  // Filter libraries if a target is specified
  const librariesToProcess = TARGET_LIBRARY
    ? Object.keys(componentUsage).filter(lib => lib === TARGET_LIBRARY)
    : Object.keys(componentUsage);
  
  if (librariesToProcess.length === 0) {
    log(`No libraries found to process`, 'warning');
    return;
  }
  
  log(`Processing ${librariesToProcess.length} libraries for adapter generation`, 'info');
  
  const successfulLibraries = [];
  
  // Generate adapter for each library
  for (const library of librariesToProcess) {
    const components = Object.keys(componentUsage[library].components);
    
    if (components.length === 0) {
      log(`Skipping ${library}: No components found`, 'warning');
      continue;
    }
    
    logVerbose(`Found ${components.length} components for ${library}`);
    
    if (generateLibraryAdapter(library, components)) {
      successfulLibraries.push(library);
    }
  }
  
  // Create index.js if requested
  if (CREATE_INDEX && successfulLibraries.length > 0) {
    generateIndexFile(successfulLibraries);
  }
  
  // Summary
  log('\nAdapter Generation Complete!', 'success');
  log(`Libraries processed: ${librariesToProcess.length}`, 'info');
  log(`Adapters generated: ${successfulLibraries.length}`, 'info');
  
  if (!DRY_RUN) {
    log(`\nAdapter components available in ${OUTPUT_DIR}/`, 'info');
  }
}

main().catch(error => {
  log(`Unhandled error: ${error.message}`, 'error');
  process.exit(1);
});