#!/usr/bin/env node
/**
 * Test Coverage Verification Script
 * 
 * This script checks if test coverage meets required thresholds.
 * It reads the coverage report generated by Jest and compares it against defined thresholds.
 * 
 * Usage:
 *   node scripts/verify-coverage.js [--coverage-report path/to/coverage-summary.json]
 */

const fs = require('fs');
const path = require('path');

// Default settings
let coverageReportPath = path.resolve('./coverage/coverage-summary.json');
let reportOnly = false;
let verbose = false;

// Parse command line arguments
for (let i = 2; i < process.argv.length; i++) {
  const arg = process.argv[i];
  
  if (arg === '--coverage-report' && i + 1 < process.argv.length) {
    coverageReportPath = path.resolve(process.argv[++i]);
  } else if (arg === '--report-only') {
    reportOnly = true;
  } else if (arg === '--verbose') {
    verbose = true;
  } else if (arg === '--help') {
    console.log(`
Test Coverage Verification Script

Usage:
  node ${path.basename(process.argv[1])} [options]

Options:
  --coverage-report <path>  Path to coverage summary JSON file (default: ./coverage/coverage-summary.json)
  --report-only            Just report coverage without checking thresholds
  --verbose                Show detailed information
  --help                   Show this help message
  
The script compares coverage against the thresholds defined in package.json or uses defaults.
`);
    process.exit(0);
  }
}

// Define default thresholds
const DEFAULT_THRESHOLDS = {
  lines: 80,
  statements: 80,
  functions: 75,
  branches: 70
};

// Try to read thresholds from package.json
let packageThresholds = {};
try {
  const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
  packageThresholds = packageJson.jest?.coverageThreshold?.global || {};
} catch (err) {
  console.warn('Could not read thresholds from package.json, using defaults');
}

// Combine thresholds, with package.json taking precedence
const thresholds = { ...DEFAULT_THRESHOLDS, ...packageThresholds };

// Read coverage report
try {
  if (!fs.existsSync(coverageReportPath)) {
    console.error(`Coverage report not found at ${coverageReportPath}`);
    console.error('Run tests with coverage first: npm test -- --coverage');
    process.exit(1);
  }
  
  const coverage = JSON.parse(fs.readFileSync(coverageReportPath, 'utf8'));
  const totalCoverage = coverage.total || {};
  
  // Extract coverage percentages, defaulting to 0 if missing
  const actualCoverage = {
    lines: totalCoverage.lines?.pct || 0,
    statements: totalCoverage.statements?.pct || 0,
    functions: totalCoverage.functions?.pct || 0,
    branches: totalCoverage.branches?.pct || 0
  };
  
  // Format function for consistent output
  const formatPercentage = (value) => {
    return `${value.toFixed(2)}%`.padStart(7);
  };
  
  // Print coverage report
  console.log('\n=== Test Coverage Report ===\n');
  console.log('Category    | Actual   | Threshold | Status');
  console.log('------------|----------|-----------|-------');
  
  let allPassed = true;
  
  // Check each coverage type against its threshold
  for (const [category, actual] of Object.entries(actualCoverage)) {
    const threshold = thresholds[category] || 0;
    const passes = actual >= threshold;
    if (!passes) allPassed = false;
    
    const status = passes ? '✅ PASS' : '❌ FAIL';
    console.log(`${category.padEnd(11)}| ${formatPercentage(actual)} | ${formatPercentage(threshold)} | ${status}`);
  }
  
  // Print summary
  console.log('\n=== Summary ===\n');
  
  if (allPassed || reportOnly) {
    const color = allPassed ? '\x1b[32m' : '\x1b[33m'; // Green for pass, yellow for report-only mode
    const message = allPassed 
      ? 'All coverage thresholds met or exceeded!' 
      : 'Some coverage thresholds not met, but running in report-only mode.';
    console.log(`${color}${message}\x1b[0m`);
    
    // Print file-level coverage if verbose mode is enabled
    if (verbose) {
      console.log('\n=== File Details ===\n');
      console.log('File paths with low coverage:\n');
      
      const lowCoverageFiles = [];
      
      // Look at individual file coverage
      for (const [filePath, fileCoverage] of Object.entries(coverage)) {
        if (filePath === 'total') continue;
        
        const fileStatements = fileCoverage.statements?.pct || 0;
        const fileFunctions = fileCoverage.functions?.pct || 0;
        
        // Flag files with particularly low coverage
        if (fileStatements < 50 || fileFunctions < 50) {
          lowCoverageFiles.push({
            path: filePath,
            statements: fileStatements,
            functions: fileFunctions
          });
        }
      }
      
      // Sort by lowest coverage first
      lowCoverageFiles.sort((a, b) => a.statements - b.statements);
      
      // Print low coverage files
      if (lowCoverageFiles.length > 0) {
        lowCoverageFiles.forEach(file => {
          console.log(`${file.path}:`);
          console.log(`  Statements: ${formatPercentage(file.statements)}`);
          console.log(`  Functions: ${formatPercentage(file.functions)}`);
          console.log('');
        });
      } else {
        console.log('No files with critically low coverage found.\n');
      }
    }
    
    process.exit(0);
  } else {
    console.log('\x1b[31mSome coverage thresholds were not met!\x1b[0m');
    console.log('Run tests with better coverage or adjust thresholds in package.json');
    process.exit(1);
  }
  
} catch (err) {
  console.error('Error reading or parsing coverage report:');
  console.error(err.message);
  process.exit(1);
}