{"ast":null,"code":"/**\n * Accessibility Focus Hook\n * \n * A custom hook for managing focus in an accessible way.\n * Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yFocus\n */\n\nimport { useCallback, useRef, useEffect } from 'react';\n\n/**\n * Custom hook for managing focus in an accessible way\n * \n * @param {Object} options - Configuration options\n * @param {boolean} [options.trapFocus=false] - Whether to trap focus within a container\n * @param {boolean} [options.autoFocus=false] - Whether to auto-focus the first focusable element\n * @param {boolean} [options.restoreFocus=true] - Whether to restore focus when unmounting\n * @returns {Object} Object containing focus management functions\n */\nconst useA11yFocus = function () {\n  let {\n    trapFocus = false,\n    autoFocus = false,\n    restoreFocus = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Reference to the container element\n  const containerRef = useRef(null);\n\n  // Reference to the element to restore focus to\n  const previousFocusRef = useRef(null);\n\n  // Reference to the first and last focusable elements\n  const firstFocusableRef = useRef(null);\n  const lastFocusableRef = useRef(null);\n\n  /**\n   * Get all focusable elements within the container\n   */\n  const getFocusableElements = useCallback(() => {\n    if (!containerRef.current) return [];\n\n    // Selector for all potentially focusable elements\n    const focusableSelector = ['a[href]:not([tabindex=\"-1\"])', 'button:not([disabled]):not([tabindex=\"-1\"])', 'input:not([disabled]):not([tabindex=\"-1\"])', 'select:not([disabled]):not([tabindex=\"-1\"])', 'textarea:not([disabled]):not([tabindex=\"-1\"])', 'area[href]:not([tabindex=\"-1\"])', '[contentEditable=true]:not([tabindex=\"-1\"])', '[tabindex]:not([tabindex=\"-1\"])'].join(',');\n    return Array.from(containerRef.current.querySelectorAll(focusableSelector));\n  }, []);\n\n  /**\n   * Update the first and last focusable elements refs\n   */\n  const updateFocusableRefs = useCallback(() => {\n    const focusableElements = getFocusableElements();\n    if (focusableElements.length > 0) {\n      firstFocusableRef.current = focusableElements[0];\n      lastFocusableRef.current = focusableElements[focusableElements.length - 1];\n    } else {\n      firstFocusableRef.current = null;\n      lastFocusableRef.current = null;\n    }\n  }, [getFocusableElements]);\n\n  /**\n   * Set the container element reference\n   */\n  const setContainerRef = useCallback(element => {\n    if (!element) return;\n    containerRef.current = element;\n    updateFocusableRefs();\n  }, [updateFocusableRefs]);\n\n  /**\n   * Focus a specific element\n   */\n  const focusElement = useCallback(element => {\n    if (!element || typeof element.focus !== 'function') return;\n    try {\n      element.focus();\n    } catch (e) {\n      console.error('Error focusing element:', e);\n    }\n  }, []);\n\n  /**\n   * Focus the first focusable element in the container\n   */\n  const focusFirstElement = useCallback(() => {\n    if (firstFocusableRef.current) {\n      focusElement(firstFocusableRef.current);\n      return true;\n    }\n    return false;\n  }, [focusElement]);\n\n  /**\n   * Focus the last focusable element in the container\n   */\n  const focusLastElement = useCallback(() => {\n    if (lastFocusableRef.current) {\n      focusElement(lastFocusableRef.current);\n      return true;\n    }\n    return false;\n  }, [focusElement]);\n\n  /**\n   * Save the currently focused element\n   */\n  const saveFocus = useCallback(() => {\n    previousFocusRef.current = document.activeElement;\n  }, []);\n\n  /**\n   * Restore focus to the previously focused element\n   */\n  const restorePreviousFocus = useCallback(() => {\n    if (previousFocusRef.current && typeof previousFocusRef.current.focus === 'function') {\n      try {\n        previousFocusRef.current.focus();\n      } catch (e) {\n        console.error('Error restoring focus:', e);\n      }\n    }\n  }, []);\n\n  /**\n   * Handle tab key to trap focus within the container\n   */\n  const handleTabKey = useCallback(event => {\n    if (!trapFocus || !containerRef.current) return;\n\n    // Update focusable elements in case the DOM has changed\n    updateFocusableRefs();\n\n    // Handle shift+tab\n    if (event.shiftKey && document.activeElement === firstFocusableRef.current) {\n      event.preventDefault();\n      focusLastElement();\n    }\n    // Handle tab\n    else if (!event.shiftKey && document.activeElement === lastFocusableRef.current) {\n      event.preventDefault();\n      focusFirstElement();\n    }\n  }, [trapFocus, updateFocusableRefs, focusFirstElement, focusLastElement]);\n\n  /**\n   * Set up key event listeners for focus trapping\n   */\n  useEffect(() => {\n    if (!trapFocus || !containerRef.current) return;\n\n    // Update focusable elements\n    updateFocusableRefs();\n\n    // Set up event listener for keydown\n    const handleKeyDown = event => {\n      if (event.key === 'Tab') {\n        handleTabKey(event);\n      }\n    };\n\n    // Add the event listener\n    containerRef.current.addEventListener('keydown', handleKeyDown);\n\n    // Clean up event listener\n    return () => {\n      if (containerRef.current) {\n        containerRef.current.removeEventListener('keydown', handleKeyDown);\n      }\n    };\n  }, [trapFocus, handleTabKey, updateFocusableRefs]);\n\n  /**\n   * Set up auto-focus and restore focus on unmount\n   */\n  useEffect(() => {\n    // Save the currently focused element\n    if (restoreFocus) {\n      saveFocus();\n    }\n\n    // Auto-focus the first element if requested\n    if (autoFocus) {\n      updateFocusableRefs();\n      focusFirstElement();\n    }\n\n    // Restore focus when unmounting\n    return () => {\n      if (restoreFocus) {\n        restorePreviousFocus();\n      }\n    };\n  }, [autoFocus, restoreFocus, saveFocus, updateFocusableRefs, focusFirstElement, restorePreviousFocus]);\n  return {\n    containerRef,\n    setContainerRef,\n    focusFirstElement,\n    focusLastElement,\n    focusElement,\n    saveFocus,\n    restorePreviousFocus,\n    updateFocusableRefs\n  };\n};\nexport default useA11yFocus;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}