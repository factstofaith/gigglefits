{"ast":null,"code":"/**\n * Accessibility Focus Hook\n * \n * A custom hook for managing focus in an accessible way, with support for\n * focus trapping, focus restoration, and focus visibility.\n * Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yFocus\n */\n\nimport { useCallback, useRef, useEffect } from 'react';\n\n/**\n * Custom hook for managing focus in an accessible way\n * \n * @param {Object} options - Configuration options\n * @param {React.RefObject} [options.containerRef] - Reference to the container element\n * @param {boolean} [options.trapFocus=false] - Whether to trap focus within the container\n * @param {boolean} [options.restoreFocus=true] - Whether to restore focus when unmounting\n * @param {boolean} [options.autoFocus=true] - Whether to auto-focus the container when mounted\n * @param {string} [options.initialFocusSelector] - Selector for the element to focus initially\n * @param {Array<string>} [options.focusableSelectors] - Selectors for focusable elements\n * @returns {Object} Object containing focus management functions\n */\nconst useA11yFocus = function () {\n  let {\n    containerRef,\n    trapFocus = false,\n    restoreFocus = true,\n    autoFocus = true,\n    initialFocusSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\n    focusableSelectors = ['a[href]:not([disabled])', 'button:not([disabled])', 'textarea:not([disabled])', 'input:not([disabled])', 'select:not([disabled])', 'details:not([disabled])', '[tabindex]:not([tabindex=\"-1\"])', '[contenteditable=\"true\"]']\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Reference to the element that had focus before entering the container\n  const previousActiveElementRef = useRef(null);\n\n  // References to the first and last focusable elements in the container\n  const firstFocusableElementRef = useRef(null);\n  const lastFocusableElementRef = useRef(null);\n\n  // Whether the component is mounted\n  const isMountedRef = useRef(false);\n\n  /**\n   * Get all focusable elements within the container\n   */\n  const getFocusableElements = useCallback(() => {\n    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current)) return [];\n    const selector = focusableSelectors.join(', ');\n    const elements = Array.from(containerRef.current.querySelectorAll(selector));\n\n    // Filter out elements that are hidden or have display: none\n    return elements.filter(element => {\n      const style = window.getComputedStyle(element);\n      return style.display !== 'none' && style.visibility !== 'hidden' && element.offsetWidth > 0 && element.offsetHeight > 0;\n    });\n  }, [containerRef, focusableSelectors]);\n\n  /**\n   * Update the first and last focusable element references\n   */\n  const updateFocusableElements = useCallback(() => {\n    const elements = getFocusableElements();\n    firstFocusableElementRef.current = elements[0] || null;\n    lastFocusableElementRef.current = elements[elements.length - 1] || null;\n  }, [getFocusableElements]);\n\n  /**\n   * Set focus to the first focusable element within the container\n   */\n  const focusFirstElement = useCallback(() => {\n    updateFocusableElements();\n    if (firstFocusableElementRef.current) {\n      firstFocusableElementRef.current.focus();\n    } else if (containerRef !== null && containerRef !== void 0 && containerRef.current) {\n      // If no focusable elements, focus the container itself\n      containerRef.current.setAttribute('tabindex', '-1');\n      containerRef.current.focus();\n    }\n  }, [containerRef, updateFocusableElements]);\n\n  /**\n   * Set focus to an element matching the provided selector\n   */\n  const focusElement = useCallback(selector => {\n    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current)) return false;\n    const element = containerRef.current.querySelector(selector);\n    if (element) {\n      element.focus();\n      return true;\n    }\n    return false;\n  }, [containerRef]);\n\n  /**\n   * Restore focus to the previously focused element\n   */\n  const restorePreviousFocus = useCallback(() => {\n    if (previousActiveElementRef.current && typeof previousActiveElementRef.current.focus === 'function') {\n      try {\n        previousActiveElementRef.current.focus();\n      } catch (e) {\n        // Element might be unmounted or not focusable anymore\n        console.warn('Failed to restore focus:', e);\n      }\n    }\n  }, []);\n\n  /**\n   * Handle tab key to trap focus within the container\n   */\n  const handleTabKey = useCallback(event => {\n    // Only process if trapFocus is enabled\n    if (!trapFocus) return;\n    const focusableElements = getFocusableElements();\n    if (focusableElements.length === 0) return;\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n    const isTabPressed = event.key === 'Tab';\n    const isShiftPressed = event.shiftKey;\n\n    // Handle Tab forward from last element\n    if (isTabPressed && !isShiftPressed && document.activeElement === lastElement) {\n      event.preventDefault();\n      firstElement.focus();\n    }\n    // Handle Tab backward from first element\n    else if (isTabPressed && isShiftPressed && document.activeElement === firstElement) {\n      event.preventDefault();\n      lastElement.focus();\n    }\n  }, [trapFocus, getFocusableElements]);\n\n  /**\n   * Event handler for keydown events\n   */\n  const handleKeyDown = useCallback(event => {\n    handleTabKey(event);\n  }, [handleTabKey]);\n\n  /**\n   * Set up initial focus management on mount\n   */\n  useEffect(() => {\n    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current)) return;\n\n    // Save the current active element\n    previousActiveElementRef.current = document.activeElement;\n\n    // Update focusable elements references\n    updateFocusableElements();\n\n    // Handle initial focus\n    if (autoFocus) {\n      // If initialFocusSelector is provided, try to focus that element first\n      if (initialFocusSelector) {\n        const didFocus = focusElement(initialFocusSelector);\n        if (!didFocus) {\n          focusFirstElement();\n        }\n      } else {\n        focusFirstElement();\n      }\n    }\n    isMountedRef.current = true;\n\n    // Cleanup on unmount\n    return () => {\n      isMountedRef.current = false;\n\n      // Restore focus when unmounting and if restoreFocus is enabled\n      if (restoreFocus) {\n        restorePreviousFocus();\n      }\n    };\n  }, [containerRef, autoFocus, restoreFocus, updateFocusableElements, focusFirstElement, focusElement, restorePreviousFocus, initialFocusSelector]);\n\n  /**\n   * Set up keyboard event listeners for focus trapping\n   */\n  useEffect(() => {\n    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current) || !trapFocus) return;\n    const container = containerRef.current;\n    container.addEventListener('keydown', handleKeyDown);\n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [containerRef, trapFocus, handleKeyDown]);\n\n  /**\n   * Update focusable elements when children change\n   */\n  useEffect(() => {\n    if (!(containerRef !== null && containerRef !== void 0 && containerRef.current)) return;\n\n    // MutationObserver to watch for changes to the DOM\n    const observer = new MutationObserver(() => {\n      if (isMountedRef.current) {\n        updateFocusableElements();\n      }\n    });\n\n    // Watch for child list changes and subtree modifications\n    observer.observe(containerRef.current, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['disabled', 'hidden', 'style', 'tabindex']\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [containerRef, updateFocusableElements]);\n  return {\n    focusFirstElement,\n    focusElement,\n    restorePreviousFocus,\n    handleKeyDown,\n    getFocusableElements,\n    firstFocusableElement: firstFocusableElementRef.current,\n    lastFocusableElement: lastFocusableElementRef.current\n  };\n};\nexport default useA11yFocus;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}