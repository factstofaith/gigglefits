{"ast":null,"code":"/**\n * Accessibility Navigation Hook\n * \n * A custom hook for managing navigation and tab indices in an accessible way.\n * Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yNavigation\n */\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n/**\n * Custom hook for managing tab navigation in complex components\n * \n * @param {Object} options - Configuration options\n * @param {number} [options.itemCount=0] - Number of items to manage\n * @param {number} [options.defaultActiveIndex=-1] - Default active index\n * @param {boolean} [options.wrap=true] - Whether to wrap around at edges\n * @param {boolean} [options.vertical=true] - Whether navigation is vertical\n * @param {boolean} [options.horizontal=true] - Whether navigation is horizontal\n * @param {Function} [options.onNavigate] - Callback when navigation occurs\n * @param {Function} [options.onActivate] - Callback when an item is activated\n * @returns {Object} Navigation state and handlers\n */\nconst useA11yNavigation = function () {\n  let {\n    itemCount = 0,\n    defaultActiveIndex = -1,\n    wrap = true,\n    vertical = true,\n    horizontal = true,\n    onNavigate = null,\n    onActivate = null\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Current active index\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n\n  // Last user interaction type for determining focus visibility\n  const [interactionType, setInteractionType] = useState('keyboard');\n\n  // Store references for item elements\n  const itemRefs = useRef([]);\n\n  /**\n   * Update active index within bounds\n   */\n  const updateActiveIndex = useCallback(newIndex => {\n    if (newIndex < 0) {\n      newIndex = wrap ? itemCount - 1 : 0;\n    } else if (newIndex >= itemCount) {\n      newIndex = wrap ? 0 : itemCount - 1;\n    }\n    setActiveIndex(newIndex);\n    if (onNavigate) {\n      onNavigate(newIndex);\n    }\n    return newIndex;\n  }, [itemCount, wrap, onNavigate]);\n\n  /**\n   * Navigate to the next item\n   */\n  const navigateNext = useCallback(() => {\n    setInteractionType('keyboard');\n    return updateActiveIndex(activeIndex + 1);\n  }, [activeIndex, updateActiveIndex]);\n\n  /**\n   * Navigate to the previous item\n   */\n  const navigatePrevious = useCallback(() => {\n    setInteractionType('keyboard');\n    return updateActiveIndex(activeIndex - 1);\n  }, [activeIndex, updateActiveIndex]);\n\n  /**\n   * Navigate to the first item\n   */\n  const navigateFirst = useCallback(() => {\n    setInteractionType('keyboard');\n    return updateActiveIndex(0);\n  }, [updateActiveIndex]);\n\n  /**\n   * Navigate to the last item\n   */\n  const navigateLast = useCallback(() => {\n    setInteractionType('keyboard');\n    return updateActiveIndex(itemCount - 1);\n  }, [updateActiveIndex, itemCount]);\n\n  /**\n   * Navigate to a specific index\n   */\n  const navigateTo = useCallback(function (index) {\n    let {\n      focus = true,\n      source = 'keyboard'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    setInteractionType(source);\n    const newIndex = updateActiveIndex(index);\n    if (focus && itemRefs.current[newIndex]) {\n      itemRefs.current[newIndex].focus();\n    }\n    return newIndex;\n  }, [updateActiveIndex]);\n\n  /**\n   * Handle item activation (e.g., on Enter or click)\n   */\n  const activateItem = useCallback((index, event) => {\n    if (index >= 0 && index < itemCount) {\n      if (onActivate) {\n        onActivate(index, event);\n      }\n    }\n  }, [itemCount, onActivate]);\n\n  /**\n   * Get props for the container element\n   */\n  const getContainerProps = useCallback(function () {\n    let {\n      role = 'menu',\n      ...props\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return {\n      role,\n      'aria-orientation': vertical && !horizontal ? 'vertical' : !vertical && horizontal ? 'horizontal' : undefined,\n      ...props\n    };\n  }, [vertical, horizontal]);\n\n  /**\n   * Get props for each item element\n   */\n  const getItemProps = useCallback(function (index) {\n    let {\n      role = 'menuitem',\n      disabled = false,\n      ...props\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n      role,\n      tabIndex: index === activeIndex ? 0 : -1,\n      'aria-disabled': disabled ? 'true' : undefined,\n      'data-index': index,\n      'data-focus-visible': index === activeIndex && interactionType === 'keyboard' ? 'true' : undefined,\n      ref: el => {\n        itemRefs.current[index] = el;\n      },\n      onKeyDown: event => {\n        if (disabled) return;\n        const {\n          key\n        } = event;\n        let handled = false;\n        if (vertical && key === 'ArrowDown') {\n          navigateNext();\n          handled = true;\n        } else if (vertical && key === 'ArrowUp') {\n          navigatePrevious();\n          handled = true;\n        } else if (horizontal && key === 'ArrowRight') {\n          navigateNext();\n          handled = true;\n        } else if (horizontal && key === 'ArrowLeft') {\n          navigatePrevious();\n          handled = true;\n        } else if (key === 'Home') {\n          navigateFirst();\n          handled = true;\n        } else if (key === 'End') {\n          navigateLast();\n          handled = true;\n        } else if (key === 'Enter' || key === ' ') {\n          activateItem(index, event);\n          handled = true;\n        }\n        if (handled) {\n          event.preventDefault();\n        }\n        if (props.onKeyDown) {\n          props.onKeyDown(event);\n        }\n      },\n      onClick: event => {\n        if (!disabled) {\n          setInteractionType('mouse');\n          activateItem(index, event);\n\n          // Also navigate to the item\n          navigateTo(index, {\n            focus: false,\n            source: 'mouse'\n          });\n        }\n        if (props.onClick) {\n          props.onClick(event);\n        }\n      },\n      onFocus: event => {\n        // Don't change active index on focus if it's not coming from keyboard navigation\n        if (interactionType === 'keyboard') {\n          navigateTo(index, {\n            focus: false\n          });\n        }\n        if (props.onFocus) {\n          props.onFocus(event);\n        }\n      },\n      ...props\n    };\n  }, [activeIndex, interactionType, navigateNext, navigatePrevious, navigateFirst, navigateLast, navigateTo, activateItem, vertical, horizontal]);\n\n  /**\n   * Handle when item count changes\n   */\n  useEffect(() => {\n    // If active index is out of bounds, update it\n    if (activeIndex >= itemCount) {\n      updateActiveIndex(itemCount > 0 ? itemCount - 1 : -1);\n    }\n\n    // Resize refs array\n    itemRefs.current = itemRefs.current.slice(0, itemCount);\n  }, [itemCount, activeIndex, updateActiveIndex]);\n\n  /**\n   * Update container key event handlers when active element changes\n   */\n  useEffect(() => {\n    // Set up global keyboard event detection to track interaction type\n    const handleKeyDown = () => {\n      setInteractionType('keyboard');\n    };\n    const handleMouseDown = () => {\n      setInteractionType('mouse');\n    };\n    document.addEventListener('keydown', handleKeyDown, true);\n    document.addEventListener('mousedown', handleMouseDown, true);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, true);\n      document.removeEventListener('mousedown', handleMouseDown, true);\n    };\n  }, []);\n  return {\n    activeIndex,\n    interactionType,\n    navigateNext,\n    navigatePrevious,\n    navigateFirst,\n    navigateLast,\n    navigateTo,\n    activateItem,\n    getContainerProps,\n    getItemProps,\n    itemRefs: itemRefs.current\n  };\n};\nexport default useA11yNavigation;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}