{"ast":null,"code":"/**\n * AzureBlobConfiguration.jsx\n * -----------------------------------------------------------------------------\n * Enhanced configuration component for Azure Blob Storage connections\n * with integrated container browser functionality.\n */\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { Box, Button, Chip, CircularProgress, Dialog, DialogActions, DialogContent, DialogTitle, Divider, FormControl, FormControlLabel, FormHelperText, Grid, IconButton, InputAdornment, InputLabel, LinearProgress, MenuItem, Paper, Radio, RadioGroup, Select, Snackbar, Tab, Tabs, TextField, Tooltip, Typography, Alert, AlertTitle } from '@mui/material';\nimport InfoIcon from '@mui/icons-material/Info';\nimport VisibilityIcon from '@mui/icons-material/Visibility';\nimport VisibilityOffIcon from '@mui/icons-material/VisibilityOff';\nimport StorageIcon from '@mui/icons-material/Storage';\nimport FolderIcon from '@mui/icons-material/Folder';\nimport CheckCircleIcon from '@mui/icons-material/CheckCircle';\nimport ErrorIcon from '@mui/icons-material/Error';\nimport SearchIcon from '@mui/icons-material/Search';\nimport CloseIcon from '@mui/icons-material/Close';\nimport LockIcon from '@mui/icons-material/Lock';\nimport KeyIcon from '@mui/icons-material/Key';\n\n// Import components\nimport AzureBlobContainerBrowser from \"./azure/AzureBlobContainerBrowser\";\nimport AzureCredentialManager from \"./azure/AzureCredentialManager\";\n\n/**\n * Azure Blob Configuration Component with integrated browser functionality\n * \n * @component\n * @param {Object} props - Component props\n * @param {Object} props.config - Current configuration values\n * @param {Function} props.onChange - Callback when configuration changes\n * @param {Object} props.errors - Validation errors\n * @param {boolean} props.readOnly - Whether the component is in read-only mode\n * @param {boolean} props.isSuperUser - Whether the user has super user permissions\n */\nconst AzureBlobConfiguration = _ref => {\n  var _authMethods$find;\n  let {\n    config,\n    onChange,\n    errors = {},\n    readOnly = false,\n    isSuperUser = false\n  } = _ref;\n  // State for secrets visibility\n  const [showSecrets, setShowSecrets] = useState(false);\n\n  // State for container browser dialog\n  const [browserOpen, setBrowserOpen] = useState(false);\n  const [activeTab, setActiveTab] = useState(0);\n\n  // State for connection testing\n  const [testing, setTesting] = useState(false);\n  const [testResult, setTestResult] = useState(null);\n  const [testSnackbarOpen, setTestSnackbarOpen] = useState(false);\n\n  // State for pattern preview\n  const [showPatternPreview, setShowPatternPreview] = useState(false);\n  const [previewLoading, setPreviewLoading] = useState(false);\n  const [patternMatches, setPatternMatches] = useState([]);\n\n  // Default configuration structure\n  const defaultConfig = {\n    authMethod: 'connectionString',\n    connectionString: '',\n    accountName: '',\n    accountKey: '',\n    sasToken: '',\n    useManagedIdentity: false,\n    containerName: '',\n    filePattern: '*.csv',\n    path: '',\n    createContainerIfNotExists: false\n  };\n\n  // State for stored credentials\n  const [hasCredentials, setHasCredentials] = useState(false);\n  const [showCredentialManager, setShowCredentialManager] = useState(false);\n\n  // Merge provided config with defaults\n  const blobConfig = {\n    ...defaultConfig,\n    ...config\n  };\n\n  /**\n   * Handle change in form fields\n   */\n  const handleChange = e => {\n    const {\n      name,\n      value,\n      type,\n      checked\n    } = e.target;\n    const newValue = type === 'checkbox' ? checked : value;\n\n    // If auth method changes, reset related fields\n    let updatedConfig = {\n      ...blobConfig,\n      [name]: newValue\n    };\n    if (name === 'authMethod') {\n      updatedConfig = {\n        ...updatedConfig,\n        connectionString: '',\n        accountName: '',\n        accountKey: '',\n        sasToken: ''\n      };\n    }\n\n    // Clear any existing test result when configuration changes\n    setTestResult(null);\n    onChange(updatedConfig);\n  };\n\n  /**\n   * Toggle visibility of secret fields\n   */\n  const toggleShowSecrets = () => {\n    setShowSecrets(!showSecrets);\n  };\n\n  /**\n   * Toggle visibility of credential manager\n   */\n  const toggleCredentialManager = () => {\n    setShowCredentialManager(!showCredentialManager);\n  };\n\n  /**\n   * Handle credentials loaded from credential manager\n   */\n  const handleCredentialsLoaded = credentials => {\n    if (!credentials) return;\n\n    // Update configuration from loaded credentials\n    const updatedConfig = {\n      ...blobConfig\n    };\n\n    // Set authentication method\n    if (credentials.connectionString) {\n      updatedConfig.authMethod = 'connectionString';\n      updatedConfig.connectionString = credentials.connectionString;\n    } else if (credentials.sasToken) {\n      updatedConfig.authMethod = 'sasToken';\n      updatedConfig.accountName = credentials.accountName;\n      updatedConfig.sasToken = credentials.sasToken;\n    } else if (credentials.accountKey) {\n      updatedConfig.authMethod = 'accountKey';\n      updatedConfig.accountName = credentials.accountName;\n      updatedConfig.accountKey = credentials.accountKey;\n    } else if (credentials.useManagedIdentity) {\n      updatedConfig.authMethod = 'managedIdentity';\n      updatedConfig.accountName = credentials.accountName;\n      updatedConfig.useManagedIdentity = true;\n    }\n\n    // Update configuration\n    onChange(updatedConfig);\n\n    // Update UI state\n    setHasCredentials(true);\n  };\n\n  /**\n   * Handle opening of container browser\n   */\n  const handleOpenBrowser = () => {\n    setBrowserOpen(true);\n  };\n\n  /**\n   * Handle closing of container browser\n   */\n  const handleCloseBrowser = () => {\n    setBrowserOpen(false);\n  };\n\n  /**\n   * Handle tab change in browser dialog\n   */\n  const handleTabChange = (event, newValue) => {\n    setActiveTab(newValue);\n  };\n\n  /**\n   * Handle container selection from browser\n   */\n  const handleSelectContainer = useCallback(containerName => {\n    if (containerName) {\n      onChange({\n        ...blobConfig,\n        containerName\n      });\n    }\n  }, [blobConfig, onChange]);\n\n  /**\n   * Handle blob selection from browser\n   */\n  const handleSelectBlob = useCallback(blobInfo => {\n    if (blobInfo) {\n      // Extract the path from the blob name\n      const fullPath = blobInfo.blobName;\n      const containerName = blobInfo.containerName;\n\n      // Get the directory path by removing the filename\n      const lastSlashIndex = fullPath.lastIndexOf('/');\n      const directoryPath = lastSlashIndex > 0 ? fullPath.substring(0, lastSlashIndex + 1) : '';\n\n      // Extract a pattern based on the file name\n      const fileName = lastSlashIndex > 0 ? fullPath.substring(lastSlashIndex + 1) : fullPath;\n\n      // Determine a reasonable pattern based on file extension\n      const dotIndex = fileName.lastIndexOf('.');\n      const fileExtension = dotIndex > 0 ? fileName.substring(dotIndex) : '';\n      const filePattern = fileExtension ? `*${fileExtension}` : fileName;\n      onChange({\n        ...blobConfig,\n        containerName,\n        path: directoryPath,\n        filePattern\n      });\n    }\n  }, [blobConfig, onChange]);\n\n  /**\n   * Test the Azure connection with comprehensive diagnostics\n   */\n  const testConnection = useCallback(async () => {\n    // Don't test if required fields are missing\n    if (!canTest()) return;\n    setTesting(true);\n    setTestResult(null);\n    try {\n      // Simulate API call to test connection\n      console.log('Testing connection with config:', blobConfig);\n\n      // In a production environment, this would call a real API endpoint\n      // For our development environment, we'll simulate detailed test steps\n      const result = await new Promise(resolve => {\n        // Create a function to simulate step-by-step testing\n        const runDiagnostics = async () => {\n          const diagnosticSteps = [];\n          let success = false;\n          let message = '';\n          let details = {};\n\n          // Step 1: Validate configuration format\n          await sleep(400); // Simulate network delay\n          if (blobConfig.authMethod === 'connectionString') {\n            const hasAccountName = blobConfig.connectionString.includes('AccountName=');\n            const hasAccountKey = blobConfig.connectionString.includes('AccountKey=');\n            const hasEndpoint = blobConfig.connectionString.includes('EndpointSuffix=') || blobConfig.connectionString.includes('BlobEndpoint=');\n            diagnosticSteps.push({\n              name: 'Validate connection string format',\n              success: hasAccountName && hasAccountKey && hasEndpoint,\n              message: hasAccountName && hasAccountKey && hasEndpoint ? 'Connection string format is valid' : 'Connection string is missing required components',\n              details: {\n                hasAccountName,\n                hasAccountKey,\n                hasEndpoint\n              }\n            });\n            if (!hasAccountName || !hasAccountKey || !hasEndpoint) {\n              return {\n                success: false,\n                message: 'Invalid connection string format',\n                diagnosticSteps,\n                details: {\n                  missingComponents: [...(!hasAccountName ? ['AccountName'] : []), ...(!hasAccountKey ? ['AccountKey'] : []), ...(!hasEndpoint ? ['EndpointSuffix or BlobEndpoint'] : [])]\n                }\n              };\n            }\n          } else if (blobConfig.authMethod === 'accountKey') {\n            const validAccountName = blobConfig.accountName.length > 3;\n            const validAccountKey = blobConfig.accountKey.length > 10;\n            diagnosticSteps.push({\n              name: 'Validate account credentials',\n              success: validAccountName && validAccountKey,\n              message: validAccountName && validAccountKey ? 'Account name and key format validated' : 'Invalid account name or key format',\n              details: {\n                accountNameValid: validAccountName,\n                accountKeyValid: validAccountKey\n              }\n            });\n            if (!validAccountName || !validAccountKey) {\n              return {\n                success: false,\n                message: 'Invalid account credentials',\n                diagnosticSteps,\n                details: {\n                  issues: [...(!validAccountName ? ['Account name is too short or invalid'] : []), ...(!validAccountKey ? ['Account key is too short or invalid'] : [])]\n                }\n              };\n            }\n          } else if (blobConfig.authMethod === 'sasToken') {\n            const validAccountName = blobConfig.accountName.length > 3;\n            const validSasToken = blobConfig.sasToken.startsWith('?') && blobConfig.sasToken.includes('sig=');\n            diagnosticSteps.push({\n              name: 'Validate SAS token credentials',\n              success: validAccountName && validSasToken,\n              message: validAccountName && validSasToken ? 'Account name and SAS token format validated' : 'Invalid SAS token configuration',\n              details: {\n                accountNameValid: validAccountName,\n                sasTokenValid: validSasToken\n              }\n            });\n            if (!validAccountName || !validSasToken) {\n              return {\n                success: false,\n                message: 'Invalid SAS token configuration',\n                diagnosticSteps,\n                details: {\n                  issues: [...(!validAccountName ? ['Account name is too short or invalid'] : []), ...(!validSasToken ? ['SAS token must start with ? and include a signature (sig=)'] : [])]\n                }\n              };\n            }\n          } else if (blobConfig.authMethod === 'managedIdentity') {\n            const validAccountName = blobConfig.accountName.length > 3;\n            diagnosticSteps.push({\n              name: 'Validate managed identity configuration',\n              success: validAccountName,\n              message: validAccountName ? 'Account name format validated' : 'Invalid account name for managed identity',\n              details: {\n                accountNameValid: validAccountName\n              }\n            });\n            if (!validAccountName) {\n              return {\n                success: false,\n                message: 'Invalid managed identity configuration',\n                diagnosticSteps,\n                details: {\n                  issues: ['Account name is required even when using managed identity']\n                }\n              };\n            }\n          }\n\n          // Step 2: Test connection to account\n          await sleep(600);\n          const accountConnected = Math.random() > 0.1; // 90% success rate for demo\n\n          diagnosticSteps.push({\n            name: 'Connect to storage account',\n            success: accountConnected,\n            message: accountConnected ? 'Successfully connected to storage account' : 'Failed to connect to storage account',\n            details: {\n              timestamp: new Date().toISOString(),\n              authMethod: blobConfig.authMethod\n            }\n          });\n          if (!accountConnected) {\n            return {\n              success: false,\n              message: 'Could not connect to storage account',\n              diagnosticSteps,\n              details: {\n                possibleIssues: ['Network connectivity problem', 'Invalid credentials', 'Account firewall restrictions', 'Account may not exist']\n              }\n            };\n          }\n\n          // Step 3: Test container access\n          await sleep(500);\n          const containerExists = blobConfig.containerName !== '' && Math.random() > 0.1; // 90% success if container specified\n\n          diagnosticSteps.push({\n            name: 'Verify container access',\n            success: containerExists,\n            message: blobConfig.containerName ? containerExists ? `Container '${blobConfig.containerName}' exists and is accessible` : `Container '${blobConfig.containerName}' does not exist or is not accessible` : 'No container specified, skipping container verification',\n            details: {\n              containerName: blobConfig.containerName || 'Not specified',\n              createIfNotExists: blobConfig.createContainerIfNotExists\n            }\n          });\n          if (blobConfig.containerName && !containerExists && !blobConfig.createContainerIfNotExists) {\n            return {\n              success: false,\n              message: `Container '${blobConfig.containerName}' does not exist or is not accessible`,\n              diagnosticSteps,\n              details: {\n                recommendation: 'Enable \"Create container if it doesn\\'t exist\" option or choose an existing container'\n              }\n            };\n          }\n\n          // Step 4: Test file pattern matching\n          await sleep(400);\n          const hasFilePattern = blobConfig.filePattern && blobConfig.filePattern.trim() !== '';\n          const validPattern = hasFilePattern && !blobConfig.filePattern.includes('\\\\');\n          diagnosticSteps.push({\n            name: 'Validate file pattern',\n            success: !hasFilePattern || validPattern,\n            message: !hasFilePattern ? 'No file pattern specified, will match all files' : validPattern ? `File pattern '${blobConfig.filePattern}' is valid` : `File pattern '${blobConfig.filePattern}' contains invalid characters`,\n            details: {\n              pattern: blobConfig.filePattern || 'Not specified',\n              valid: !hasFilePattern || validPattern\n            }\n          });\n\n          // Step 5: Perform permissions check\n          await sleep(600);\n          const hasReadPermission = true; // In real implementation, check actual permissions\n          const hasWritePermission = blobConfig.authMethod !== 'sasToken' || blobConfig.sasToken.includes('sp=') && blobConfig.sasToken.includes('w');\n          diagnosticSteps.push({\n            name: 'Verify storage permissions',\n            success: hasReadPermission,\n            message: hasReadPermission ? hasWritePermission ? 'Account has read and write permissions' : 'Account has read permissions only' : 'Account lacks required read permissions',\n            details: {\n              permissions: {\n                read: hasReadPermission,\n                write: hasWritePermission\n              }\n            }\n          });\n          if (!hasReadPermission) {\n            return {\n              success: false,\n              message: 'Account lacks required read permissions',\n              diagnosticSteps,\n              details: {\n                recommendation: 'Ensure the credentials have at least read access to the storage account'\n              }\n            };\n          }\n\n          // All tests passed\n          return {\n            success: true,\n            message: 'Connection successful! All diagnostics passed.',\n            diagnosticSteps,\n            details: {\n              timestamp: new Date().toISOString(),\n              readPermission: hasReadPermission,\n              writePermission: hasWritePermission,\n              containerExists: containerExists || !blobConfig.containerName\n            }\n          };\n        };\n\n        // Execute the diagnostics\n        setTimeout(async () => {\n          const diagnosticResult = await runDiagnostics();\n          resolve(diagnosticResult);\n        }, 500);\n      });\n      setTestResult(result);\n      setTestSnackbarOpen(true);\n    } catch (error) {\n      console.error('Error testing connection:', error);\n      setTestResult({\n        success: false,\n        message: error.message || 'An unexpected error occurred',\n        diagnosticSteps: [{\n          name: 'Initialize connection test',\n          success: false,\n          message: 'Error occurred during test initialization',\n          details: {\n            error: error.message || 'Unknown error'\n          }\n        }]\n      });\n      setTestSnackbarOpen(true);\n    } finally {\n      setTesting(false);\n    }\n  }, [blobConfig]);\n\n  // Helper function to simulate async operations\n  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  /**\n   * Preview files matching the pattern\n   */\n  const previewPattern = useCallback(async () => {\n    if (!blobConfig.containerName || !blobConfig.filePattern) return;\n    setPreviewLoading(true);\n    setPatternMatches([]);\n    try {\n      // Simulate API call to get matching files\n      console.log(`Previewing pattern: ${blobConfig.filePattern} in container: ${blobConfig.containerName} with path: ${blobConfig.path}`);\n\n      // Simulation delay\n      const result = await new Promise(resolve => {\n        setTimeout(() => {\n          // Convert glob pattern to regex for simple simulation\n          const pattern = blobConfig.filePattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*');\n          const regex = new RegExp(`^${pattern}$`);\n\n          // Sample files that might be in the container\n          const sampleFiles = ['data.csv', 'sample.csv', 'employees.csv', 'data.json', 'employees.json', 'report.pdf', 'summary.xlsx', 'log.txt'];\n\n          // Filter files by pattern\n          const matches = sampleFiles.filter(file => regex.test(file)).map(file => ({\n            name: blobConfig.path ? `${blobConfig.path}${file}` : file,\n            size: Math.floor(Math.random() * 1024 * 1024),\n            // Random size up to 1MB\n            lastModified: new Date().toISOString()\n          }));\n          resolve(matches);\n        }, 1000);\n      });\n      setPatternMatches(result);\n      setShowPatternPreview(true);\n    } catch (error) {\n      console.error('Error previewing pattern:', error);\n    } finally {\n      setPreviewLoading(false);\n    }\n  }, [blobConfig.containerName, blobConfig.filePattern, blobConfig.path]);\n\n  /**\n   * Check if connection can be tested\n   */\n  const canTest = useCallback(() => {\n    if (blobConfig.authMethod === 'connectionString') {\n      return blobConfig.connectionString.length > 0;\n    } else if (blobConfig.authMethod === 'accountKey') {\n      return blobConfig.accountName.length > 0 && blobConfig.accountKey.length > 0;\n    } else if (blobConfig.authMethod === 'sasToken') {\n      return blobConfig.accountName.length > 0 && blobConfig.sasToken.length > 0;\n    } else if (blobConfig.authMethod === 'managedIdentity') {\n      return blobConfig.accountName.length > 0;\n    }\n    return false;\n  }, [blobConfig]);\n\n  // Authentication method options\n  const authMethods = [{\n    value: 'connectionString',\n    label: 'Connection String'\n  }, {\n    value: 'accountKey',\n    label: 'Account Name & Key'\n  }, {\n    value: 'sasToken',\n    label: 'SAS Token'\n  }, {\n    value: 'managedIdentity',\n    label: 'Managed Identity'\n  }];\n\n  // Field visibility based on selected auth method\n  const showConnectionString = blobConfig.authMethod === 'connectionString';\n  const showAccountKey = blobConfig.authMethod === 'accountKey';\n  const showSasToken = blobConfig.authMethod === 'sasToken';\n  const showManagedIdentity = blobConfig.authMethod === 'managedIdentity';\n  const showAccountName = blobConfig.authMethod === 'accountKey' || blobConfig.authMethod === 'sasToken' || blobConfig.authMethod === 'managedIdentity';\n  return /*#__PURE__*/_jsxs(Box, {\n    sx: {\n      mt: 2\n    },\n    children: [/*#__PURE__*/_jsxs(Box, {\n      display: \"flex\",\n      justifyContent: \"space-between\",\n      alignItems: \"center\",\n      mb: 2,\n      children: [/*#__PURE__*/_jsx(Typography, {\n        variant: \"subtitle1\",\n        children: \"Azure Blob Storage Configuration\"\n      }), /*#__PURE__*/_jsxs(Box, {\n        children: [!readOnly && /*#__PURE__*/_jsxs(_Fragment, {\n          children: [/*#__PURE__*/_jsx(Button, {\n            variant: \"outlined\",\n            color: \"primary\",\n            onClick: testConnection,\n            disabled: testing || !canTest(),\n            startIcon: testing ? /*#__PURE__*/_jsx(CircularProgress, {\n              size: 20\n            }) : testResult ? testResult.success ? /*#__PURE__*/_jsx(CheckCircleIcon, {}) : /*#__PURE__*/_jsx(ErrorIcon, {}) : null,\n            sx: {\n              mr: 1\n            },\n            children: testing ? 'Testing...' : 'Test Connection'\n          }), /*#__PURE__*/_jsx(Button, {\n            variant: \"outlined\",\n            color: hasCredentials ? \"success\" : \"primary\",\n            onClick: toggleCredentialManager,\n            startIcon: /*#__PURE__*/_jsx(KeyIcon, {}),\n            disabled: testing,\n            sx: {\n              mr: 1\n            },\n            children: hasCredentials ? 'Manage Credentials' : 'Set Up Credentials'\n          })]\n        }), /*#__PURE__*/_jsx(Button, {\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: handleOpenBrowser,\n          startIcon: /*#__PURE__*/_jsx(StorageIcon, {}),\n          disabled: readOnly || testing,\n          children: \"Browse Storage\"\n        })]\n      })]\n    }), showCredentialManager && /*#__PURE__*/_jsx(Box, {\n      mb: 3,\n      children: /*#__PURE__*/_jsx(AzureCredentialManager, {\n        onCredentialsLoaded: handleCredentialsLoaded,\n        onCredentialsSaved: handleCredentialsLoaded,\n        readOnly: readOnly,\n        initialVisible: true\n      })\n    }), isSuperUser && /*#__PURE__*/_jsxs(Paper, {\n      elevation: 0,\n      variant: \"outlined\",\n      sx: {\n        p: 2,\n        mb: 3\n      },\n      children: [/*#__PURE__*/_jsx(Typography, {\n        variant: \"subtitle2\",\n        gutterBottom: true,\n        children: \"Authentication Settings\"\n      }), /*#__PURE__*/_jsxs(Grid, {\n        container: true,\n        spacing: 2,\n        children: [/*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsxs(FormControl, {\n            component: \"fieldset\",\n            children: [/*#__PURE__*/_jsx(Typography, {\n              variant: \"body2\",\n              color: \"textSecondary\",\n              gutterBottom: true,\n              children: \"Authentication Method\"\n            }), /*#__PURE__*/_jsx(RadioGroup, {\n              name: \"authMethod\",\n              value: blobConfig.authMethod,\n              onChange: handleChange,\n              row: true,\n              disabled: readOnly,\n              children: authMethods.map(method => /*#__PURE__*/_jsx(FormControlLabel, {\n                value: method.value,\n                control: /*#__PURE__*/_jsx(Radio, {}),\n                label: method.label,\n                disabled: readOnly\n              }, method.value))\n            })]\n          })\n        }), showConnectionString && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.connectionString,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"connectionString\",\n              label: \"Connection String\",\n              value: blobConfig.connectionString,\n              onChange: handleChange,\n              type: showSecrets ? 'text' : 'password',\n              error: !!errors.connectionString,\n              helperText: errors.connectionString,\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: /*#__PURE__*/_jsxs(InputAdornment, {\n                  position: \"end\",\n                  children: [/*#__PURE__*/_jsx(IconButton, {\n                    onClick: toggleShowSecrets,\n                    edge: \"end\",\n                    children: showSecrets ? /*#__PURE__*/_jsx(VisibilityOffIcon, {}) : /*#__PURE__*/_jsx(VisibilityIcon, {})\n                  }), /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"The connection string for your Azure Storage account. Format: DefaultEndpointsProtocol=https;AccountName=...;AccountKey=...;EndpointSuffix=core.windows.net\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      edge: \"end\",\n                      children: /*#__PURE__*/_jsx(InfoIcon, {})\n                    })\n                  })]\n                })\n              }\n            })\n          })\n        }), showAccountName && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          md: showAccountKey ? 6 : 12,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.accountName,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"accountName\",\n              label: \"Storage Account Name\",\n              value: blobConfig.accountName,\n              onChange: handleChange,\n              error: !!errors.accountName,\n              helperText: errors.accountName,\n              disabled: readOnly\n            })\n          })\n        }), showAccountKey && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          md: 6,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.accountKey,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"accountKey\",\n              label: \"Account Key\",\n              value: blobConfig.accountKey,\n              onChange: handleChange,\n              type: showSecrets ? 'text' : 'password',\n              error: !!errors.accountKey,\n              helperText: errors.accountKey,\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: /*#__PURE__*/_jsx(InputAdornment, {\n                  position: \"end\",\n                  children: /*#__PURE__*/_jsx(IconButton, {\n                    onClick: toggleShowSecrets,\n                    edge: \"end\",\n                    children: showSecrets ? /*#__PURE__*/_jsx(VisibilityOffIcon, {}) : /*#__PURE__*/_jsx(VisibilityIcon, {})\n                  })\n                })\n              }\n            })\n          })\n        }), showSasToken && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.sasToken,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"sasToken\",\n              label: \"SAS Token\",\n              value: blobConfig.sasToken,\n              onChange: handleChange,\n              type: showSecrets ? 'text' : 'password',\n              error: !!errors.sasToken,\n              helperText: errors.sasToken || \"Include the leading '?' character\",\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: /*#__PURE__*/_jsxs(InputAdornment, {\n                  position: \"end\",\n                  children: [/*#__PURE__*/_jsx(IconButton, {\n                    onClick: toggleShowSecrets,\n                    edge: \"end\",\n                    children: showSecrets ? /*#__PURE__*/_jsx(VisibilityOffIcon, {}) : /*#__PURE__*/_jsx(VisibilityIcon, {})\n                  }), /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"A Shared Access Signature (SAS) token providing permissions to the storage account or container\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      edge: \"end\",\n                      children: /*#__PURE__*/_jsx(InfoIcon, {})\n                    })\n                  })]\n                })\n              }\n            })\n          })\n        }), showManagedIdentity && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsx(Paper, {\n            variant: \"outlined\",\n            sx: {\n              p: 2,\n              bgcolor: 'background.default'\n            },\n            children: /*#__PURE__*/_jsx(Typography, {\n              variant: \"body2\",\n              color: \"textSecondary\",\n              children: \"Using Azure Managed Identity for authentication. No additional credentials required. The application will use the identity assigned to the deployment environment.\"\n            })\n          })\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Paper, {\n      elevation: 0,\n      variant: \"outlined\",\n      sx: {\n        p: 2\n      },\n      children: [/*#__PURE__*/_jsxs(Box, {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\",\n        mb: 1,\n        children: [/*#__PURE__*/_jsx(Typography, {\n          variant: \"subtitle2\",\n          children: \"Container Settings\"\n        }), !readOnly && canTest() && /*#__PURE__*/_jsx(Button, {\n          variant: \"outlined\",\n          size: \"small\",\n          onClick: testConnection,\n          disabled: testing,\n          startIcon: testing ? /*#__PURE__*/_jsx(CircularProgress, {\n            size: 16\n          }) : testResult ? testResult.success ? /*#__PURE__*/_jsx(CheckCircleIcon, {\n            size: \"small\"\n          }) : /*#__PURE__*/_jsx(ErrorIcon, {\n            size: \"small\"\n          }) : null,\n          children: \"Test Connection\"\n        })]\n      }), /*#__PURE__*/_jsxs(Grid, {\n        container: true,\n        spacing: 2,\n        children: [/*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          md: 6,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.containerName,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"containerName\",\n              label: \"Container Name\",\n              value: blobConfig.containerName,\n              onChange: handleChange,\n              error: !!errors.containerName,\n              helperText: errors.containerName || \"Name of the Azure Blob container\",\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: blobConfig.containerName ? /*#__PURE__*/_jsx(InputAdornment, {\n                  position: \"end\",\n                  children: /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"Browse container\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      edge: \"end\",\n                      onClick: handleOpenBrowser,\n                      disabled: readOnly,\n                      children: /*#__PURE__*/_jsx(StorageIcon, {})\n                    })\n                  })\n                }) : null\n              }\n            })\n          })\n        }), /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          md: 6,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            error: !!errors.filePattern,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"filePattern\",\n              label: \"File Pattern\",\n              value: blobConfig.filePattern,\n              onChange: handleChange,\n              error: !!errors.filePattern,\n              helperText: errors.filePattern || \"Example: *.csv, employee-*.json\",\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: blobConfig.containerName && blobConfig.filePattern ? /*#__PURE__*/_jsx(InputAdornment, {\n                  position: \"end\",\n                  children: /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"Preview matching files\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      edge: \"end\",\n                      onClick: previewPattern,\n                      disabled: readOnly || previewLoading,\n                      children: /*#__PURE__*/_jsx(SearchIcon, {})\n                    })\n                  })\n                }) : null\n              }\n            })\n          })\n        }), /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsx(FormControl, {\n            fullWidth: true,\n            children: /*#__PURE__*/_jsx(TextField, {\n              name: \"path\",\n              label: \"Path (Optional)\",\n              value: blobConfig.path,\n              onChange: handleChange,\n              helperText: \"Optional folder path inside the container (e.g., 'daily/employees/')\",\n              disabled: readOnly,\n              InputProps: {\n                endAdornment: blobConfig.path ? /*#__PURE__*/_jsx(InputAdornment, {\n                  position: \"end\",\n                  children: /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"Browse this path\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      edge: \"end\",\n                      onClick: handleOpenBrowser,\n                      disabled: readOnly,\n                      children: /*#__PURE__*/_jsx(FolderIcon, {})\n                    })\n                  })\n                }) : null\n              }\n            })\n          })\n        }), !readOnly && /*#__PURE__*/_jsx(Grid, {\n          item: true,\n          xs: 12,\n          children: /*#__PURE__*/_jsxs(FormControl, {\n            fullWidth: true,\n            children: [/*#__PURE__*/_jsx(FormControlLabel, {\n              control: /*#__PURE__*/_jsx(Checkbox, {\n                name: \"createContainerIfNotExists\",\n                checked: blobConfig.createContainerIfNotExists,\n                onChange: handleChange,\n                disabled: readOnly\n              }),\n              label: \"Create container if it doesn't exist\"\n            }), /*#__PURE__*/_jsx(FormHelperText, {\n              children: \"If enabled, the system will attempt to create the container when the integration runs\"\n            })]\n          })\n        })]\n      }), patternMatches.length > 0 && /*#__PURE__*/_jsxs(Box, {\n        mt: 2,\n        children: [/*#__PURE__*/_jsx(Divider, {\n          sx: {\n            mb: 2\n          }\n        }), /*#__PURE__*/_jsx(Typography, {\n          variant: \"subtitle2\",\n          gutterBottom: true,\n          children: \"Preview of Files Matching Pattern\"\n        }), /*#__PURE__*/_jsx(Box, {\n          sx: {\n            maxHeight: '200px',\n            overflow: 'auto',\n            mb: 1\n          },\n          children: /*#__PURE__*/_jsx(List, {\n            dense: true,\n            children: patternMatches.map((file, idx) => /*#__PURE__*/_jsxs(ListItem, {\n              children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                children: /*#__PURE__*/_jsx(FileIcon, {\n                  color: \"primary\",\n                  fontSize: \"small\"\n                })\n              }), /*#__PURE__*/_jsx(ListItemText, {\n                primary: file.name,\n                secondary: `${formatFileSize(file.size)} • ${formatDate(file.lastModified)}`\n              })]\n            }, idx))\n          })\n        }), /*#__PURE__*/_jsxs(Box, {\n          display: \"flex\",\n          justifyContent: \"space-between\",\n          alignItems: \"center\",\n          children: [/*#__PURE__*/_jsxs(Typography, {\n            variant: \"body2\",\n            color: \"textSecondary\",\n            children: [patternMatches.length, \" file(s) match your pattern\"]\n          }), /*#__PURE__*/_jsx(Button, {\n            size: \"small\",\n            onClick: () => setPatternMatches([]),\n            startIcon: /*#__PURE__*/_jsx(CloseIcon, {}),\n            children: \"Close Preview\"\n          })]\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: browserOpen,\n      onClose: handleCloseBrowser,\n      fullWidth: true,\n      maxWidth: \"lg\",\n      sx: {\n        '& .MuiDialog-paper': {\n          height: '80vh'\n        }\n      },\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: /*#__PURE__*/_jsxs(Tabs, {\n          value: activeTab,\n          onChange: handleTabChange,\n          children: [/*#__PURE__*/_jsx(Tab, {\n            label: \"Browse Containers\"\n          }), /*#__PURE__*/_jsx(Tab, {\n            label: \"Connection Settings\",\n            disabled: !canTest()\n          })]\n        })\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        dividers: true,\n        sx: {\n          height: '100%',\n          p: 0\n        },\n        children: [activeTab === 0 && /*#__PURE__*/_jsx(Box, {\n          sx: {\n            height: '100%'\n          },\n          children: /*#__PURE__*/_jsx(AzureBlobContainerBrowser, {\n            config: blobConfig,\n            onSelectContainer: handleSelectContainer,\n            onSelectBlob: handleSelectBlob,\n            readOnly: readOnly,\n            selectedContainer: blobConfig.containerName,\n            selectedPath: blobConfig.path\n          })\n        }), activeTab === 1 && /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            p: 3\n          },\n          children: [/*#__PURE__*/_jsx(Typography, {\n            variant: \"h6\",\n            gutterBottom: true,\n            children: \"Connection Diagnostics\"\n          }), /*#__PURE__*/_jsxs(Grid, {\n            container: true,\n            spacing: 2,\n            children: [/*#__PURE__*/_jsx(Grid, {\n              item: true,\n              xs: 12,\n              children: /*#__PURE__*/_jsxs(Paper, {\n                variant: \"outlined\",\n                sx: {\n                  p: 2\n                },\n                children: [/*#__PURE__*/_jsx(Typography, {\n                  variant: \"subtitle2\",\n                  gutterBottom: true,\n                  children: \"Authentication Method\"\n                }), /*#__PURE__*/_jsx(Chip, {\n                  label: (_authMethods$find = authMethods.find(m => m.value === blobConfig.authMethod)) === null || _authMethods$find === void 0 ? void 0 : _authMethods$find.label,\n                  color: \"primary\",\n                  variant: \"outlined\"\n                }), /*#__PURE__*/_jsx(Divider, {\n                  sx: {\n                    my: 2\n                  }\n                }), showConnectionString && /*#__PURE__*/_jsxs(Box, {\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"subtitle2\",\n                    gutterBottom: true,\n                    children: \"Connection String\"\n                  }), /*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    color: \"textSecondary\",\n                    children: showSecrets ? blobConfig.connectionString : '•••••••••••••••••••••••••••••'\n                  })]\n                }), showAccountName && /*#__PURE__*/_jsxs(Box, {\n                  mt: 2,\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"subtitle2\",\n                    gutterBottom: true,\n                    children: \"Storage Account Name\"\n                  }), /*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    children: blobConfig.accountName\n                  })]\n                }), showAccountKey && /*#__PURE__*/_jsxs(Box, {\n                  mt: 2,\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"subtitle2\",\n                    gutterBottom: true,\n                    children: \"Account Key\"\n                  }), /*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    color: \"textSecondary\",\n                    children: showSecrets ? blobConfig.accountKey : '•••••••••••••••••••••••••••••'\n                  })]\n                }), showSasToken && /*#__PURE__*/_jsxs(Box, {\n                  mt: 2,\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"subtitle2\",\n                    gutterBottom: true,\n                    children: \"SAS Token\"\n                  }), /*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    color: \"textSecondary\",\n                    children: showSecrets ? blobConfig.sasToken : '•••••••••••••••••••••••••••••'\n                  })]\n                }), showManagedIdentity && /*#__PURE__*/_jsxs(Box, {\n                  mt: 2,\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"subtitle2\",\n                    gutterBottom: true,\n                    children: \"Managed Identity\"\n                  }), /*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    color: \"textSecondary\",\n                    children: \"Using the system-assigned managed identity\"\n                  })]\n                })]\n              })\n            }), /*#__PURE__*/_jsxs(Grid, {\n              item: true,\n              xs: 12,\n              children: [/*#__PURE__*/_jsx(Button, {\n                variant: \"contained\",\n                color: \"primary\",\n                onClick: testConnection,\n                disabled: testing || !canTest(),\n                startIcon: testing ? /*#__PURE__*/_jsx(CircularProgress, {\n                  size: 20\n                }) : null,\n                fullWidth: true,\n                children: testing ? 'Testing Connection...' : 'Test Connection'\n              }), testResult && /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  mt: 2\n                },\n                children: [/*#__PURE__*/_jsx(Alert, {\n                  severity: testResult.success ? 'success' : 'error',\n                  sx: {\n                    mb: 2\n                  },\n                  action: /*#__PURE__*/_jsx(IconButton, {\n                    \"aria-label\": \"close\",\n                    color: \"inherit\",\n                    size: \"small\",\n                    onClick: () => setTestResult(null),\n                    children: /*#__PURE__*/_jsx(CloseIcon, {\n                      fontSize: \"inherit\"\n                    })\n                  }),\n                  children: testResult.message\n                }), testResult.diagnosticSteps && /*#__PURE__*/_jsxs(Paper, {\n                  variant: \"outlined\",\n                  sx: {\n                    p: 2\n                  },\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"h6\",\n                    gutterBottom: true,\n                    children: \"Diagnostic Results\"\n                  }), /*#__PURE__*/_jsx(List, {\n                    dense: true,\n                    children: testResult.diagnosticSteps.map((step, index) => /*#__PURE__*/_jsxs(ListItem, {\n                      divider: index < testResult.diagnosticSteps.length - 1,\n                      sx: {\n                        py: 1.5,\n                        backgroundColor: step.success ? 'success.lighter' : index === testResult.diagnosticSteps.findIndex(s => !s.success) ? 'error.lighter' : 'inherit'\n                      },\n                      children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                        children: step.success ? /*#__PURE__*/_jsx(CheckCircleIcon, {\n                          color: \"success\"\n                        }) : /*#__PURE__*/_jsx(ErrorIcon, {\n                          color: \"error\"\n                        })\n                      }), /*#__PURE__*/_jsx(ListItemText, {\n                        primary: step.name,\n                        secondary: step.message,\n                        primaryTypographyProps: {\n                          fontWeight: 'medium'\n                        }\n                      }), /*#__PURE__*/_jsx(Tooltip, {\n                        title: /*#__PURE__*/_jsxs(Box, {\n                          children: [/*#__PURE__*/_jsx(Typography, {\n                            variant: \"subtitle2\",\n                            children: \"Details\"\n                          }), /*#__PURE__*/_jsx(\"pre\", {\n                            style: {\n                              whiteSpace: 'pre-wrap',\n                              fontSize: '0.8rem'\n                            },\n                            children: JSON.stringify(step.details, null, 2)\n                          })]\n                        }),\n                        children: /*#__PURE__*/_jsx(IconButton, {\n                          size: \"small\",\n                          children: /*#__PURE__*/_jsx(InfoIcon, {\n                            fontSize: \"small\"\n                          })\n                        })\n                      })]\n                    }, index))\n                  }), testResult.details && testResult.details.recommendation && /*#__PURE__*/_jsxs(Box, {\n                    sx: {\n                      mt: 2,\n                      bgcolor: 'info.lighter',\n                      p: 2,\n                      borderRadius: 1\n                    },\n                    children: [/*#__PURE__*/_jsx(Typography, {\n                      variant: \"subtitle2\",\n                      color: \"info.dark\",\n                      children: \"Recommendation\"\n                    }), /*#__PURE__*/_jsx(Typography, {\n                      variant: \"body2\",\n                      children: testResult.details.recommendation\n                    })]\n                  }), testResult.details && testResult.details.possibleIssues && /*#__PURE__*/_jsxs(Box, {\n                    sx: {\n                      mt: 2,\n                      bgcolor: 'warning.lighter',\n                      p: 2,\n                      borderRadius: 1\n                    },\n                    children: [/*#__PURE__*/_jsx(Typography, {\n                      variant: \"subtitle2\",\n                      color: \"warning.dark\",\n                      children: \"Possible Issues\"\n                    }), /*#__PURE__*/_jsx(List, {\n                      dense: true,\n                      disablePadding: true,\n                      children: testResult.details.possibleIssues.map((issue, index) => /*#__PURE__*/_jsxs(ListItem, {\n                        disableGutters: true,\n                        children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                          sx: {\n                            minWidth: 24\n                          },\n                          children: /*#__PURE__*/_jsx(WarningIcon, {\n                            fontSize: \"small\",\n                            color: \"warning\"\n                          })\n                        }), /*#__PURE__*/_jsx(ListItemText, {\n                          primary: issue,\n                          primaryTypographyProps: {\n                            variant: 'body2'\n                          }\n                        })]\n                      }, index))\n                    })]\n                  }), testResult.details && testResult.details.missingComponents && /*#__PURE__*/_jsxs(Box, {\n                    sx: {\n                      mt: 2,\n                      bgcolor: 'error.lighter',\n                      p: 2,\n                      borderRadius: 1\n                    },\n                    children: [/*#__PURE__*/_jsx(Typography, {\n                      variant: \"subtitle2\",\n                      color: \"error.dark\",\n                      children: \"Missing Components\"\n                    }), /*#__PURE__*/_jsx(List, {\n                      dense: true,\n                      disablePadding: true,\n                      children: testResult.details.missingComponents.map((component, index) => /*#__PURE__*/_jsxs(ListItem, {\n                        disableGutters: true,\n                        children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                          sx: {\n                            minWidth: 24\n                          },\n                          children: /*#__PURE__*/_jsx(ErrorOutlineIcon, {\n                            fontSize: \"small\",\n                            color: \"error\"\n                          })\n                        }), /*#__PURE__*/_jsx(ListItemText, {\n                          primary: component,\n                          primaryTypographyProps: {\n                            variant: 'body2'\n                          }\n                        })]\n                      }, index))\n                    })]\n                  }), testResult.details && testResult.details.issues && /*#__PURE__*/_jsxs(Box, {\n                    sx: {\n                      mt: 2,\n                      bgcolor: 'error.lighter',\n                      p: 2,\n                      borderRadius: 1\n                    },\n                    children: [/*#__PURE__*/_jsx(Typography, {\n                      variant: \"subtitle2\",\n                      color: \"error.dark\",\n                      children: \"Validation Issues\"\n                    }), /*#__PURE__*/_jsx(List, {\n                      dense: true,\n                      disablePadding: true,\n                      children: testResult.details.issues.map((issue, index) => /*#__PURE__*/_jsxs(ListItem, {\n                        disableGutters: true,\n                        children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                          sx: {\n                            minWidth: 24\n                          },\n                          children: /*#__PURE__*/_jsx(ErrorOutlineIcon, {\n                            fontSize: \"small\",\n                            color: \"error\"\n                          })\n                        }), /*#__PURE__*/_jsx(ListItemText, {\n                          primary: issue,\n                          primaryTypographyProps: {\n                            variant: 'body2'\n                          }\n                        })]\n                      }, index))\n                    })]\n                  })]\n                })]\n              })]\n            })]\n          })]\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: handleCloseBrowser,\n          children: \"Close\"\n        }), activeTab === 0 && /*#__PURE__*/_jsx(Button, {\n          onClick: () => {\n            handleCloseBrowser();\n          },\n          color: \"primary\",\n          variant: \"contained\",\n          children: \"Apply Selection\"\n        })]\n      })]\n    }), /*#__PURE__*/_jsx(Snackbar, {\n      open: testSnackbarOpen,\n      autoHideDuration: 6000,\n      onClose: () => setTestSnackbarOpen(false),\n      anchorOrigin: {\n        vertical: 'bottom',\n        horizontal: 'right'\n      },\n      children: /*#__PURE__*/_jsxs(Alert, {\n        onClose: () => setTestSnackbarOpen(false),\n        severity: testResult !== null && testResult !== void 0 && testResult.success ? 'success' : 'error',\n        sx: {\n          width: '100%'\n        },\n        action: /*#__PURE__*/_jsx(Button, {\n          color: \"inherit\",\n          size: \"small\",\n          onClick: () => {\n            setTestSnackbarOpen(false);\n            setActiveTab(1); // Switch to the Connection Settings tab\n          },\n          children: \"See Details\"\n        }),\n        children: [/*#__PURE__*/_jsx(AlertTitle, {\n          children: testResult !== null && testResult !== void 0 && testResult.success ? 'Connection Successful' : 'Connection Failed'\n        }), testResult === null || testResult === void 0 ? void 0 : testResult.message, (testResult === null || testResult === void 0 ? void 0 : testResult.diagnosticSteps) && /*#__PURE__*/_jsxs(Typography, {\n          variant: \"caption\",\n          display: \"block\",\n          sx: {\n            mt: 1\n          },\n          children: [testResult.diagnosticSteps.filter(step => step.success).length, \" of \", testResult.diagnosticSteps.length, \" diagnostic checks passed\"]\n        })]\n      })\n    })]\n  });\n};\n\n// Helper functions for formatted display\nconst formatFileSize = bytes => {\n  if (bytes === 0) return '0 Bytes';\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\nconst formatDate = dateString => {\n  if (!dateString) return 'Unknown';\n  const date = new Date(dateString);\n  return date.toLocaleString();\n};\n\n// Additional imports\nimport Checkbox from '@mui/material/Checkbox';\nimport ListItem from '@mui/material/ListItem';\nimport ListItemIcon from '@mui/material/ListItemIcon';\nimport ListItemText from '@mui/material/ListItemText';\nimport List from '@mui/material/List';\nimport FileIcon from '@mui/icons-material/InsertDriveFile';\n// CloseIcon already imported on line 49\nimport WarningIcon from '@mui/icons-material/Warning';\nimport ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nexport default AzureBlobConfiguration;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}