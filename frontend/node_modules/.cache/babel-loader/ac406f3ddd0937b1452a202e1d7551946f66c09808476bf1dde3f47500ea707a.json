{"ast":null,"code":"/**\n * Connection Validation Service\n * \n * This service provides validation for connections between nodes in the flow canvas.\n * It handles type compatibility, data format validation, and connection constraints.\n */\n\n// Node type definitions\nconst NODE_TYPES = {\n  sourceNode: {\n    outputs: ['data'],\n    maxOutputConnections: null,\n    // unlimited\n    description: 'Source node providing data'\n  },\n  destinationNode: {\n    inputs: ['data'],\n    maxInputConnections: 10,\n    description: 'Destination node receiving data'\n  },\n  transformationNode: {\n    inputs: ['data'],\n    outputs: ['data'],\n    maxInputConnections: 5,\n    maxOutputConnections: 10,\n    description: 'Transformation node processing data'\n  },\n  filterNode: {\n    inputs: ['data'],\n    outputs: ['data', 'filtered'],\n    maxInputConnections: 5,\n    maxOutputConnections: 10,\n    description: 'Filter node routing data based on conditions'\n  }\n};\n\n// Data type compatibility matrix\n// This defines which data types can be connected to which\nconst DATA_TYPE_COMPATIBILITY = {\n  'string': ['string', 'any'],\n  'number': ['number', 'any'],\n  'boolean': ['boolean', 'any'],\n  'date': ['date', 'string', 'any'],\n  'object': ['object', 'any'],\n  'array': ['array', 'any'],\n  'any': ['string', 'number', 'boolean', 'date', 'object', 'array', 'any']\n};\n\n/**\n * Checks if a node of sourceType can connect to a node of targetType\n * \n * @param {string} sourceType - The type of the source node\n * @param {string} targetType - The type of the target node\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateNodeTypeConnection = (sourceType, targetType) => {\n  // Check if node types exist in our definitions\n  if (!NODE_TYPES[sourceType]) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Invalid source node type: ${sourceType}`\n    };\n  }\n  if (!NODE_TYPES[targetType]) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Invalid target node type: ${targetType}`\n    };\n  }\n\n  // Check if source node has outputs\n  if (!NODE_TYPES[sourceType].outputs || NODE_TYPES[sourceType].outputs.length === 0) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Source node type ${sourceType} has no outputs`\n    };\n  }\n\n  // Check if target node has inputs\n  if (!NODE_TYPES[targetType].inputs || NODE_TYPES[targetType].inputs.length === 0) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Target node type ${targetType} has no inputs`\n    };\n  }\n\n  // For now, let's assume all defined connections are valid if both have I/O\n  return {\n    isValid: true,\n    message: `Connection from ${sourceType} to ${targetType} is valid`\n  };\n};\n\n/**\n * Validates a connection between nodes based on handles and data types\n * \n * @param {Object} source - The source node\n * @param {Object} target - The target node\n * @param {string} sourceHandle - The source handle ID\n * @param {string} targetHandle - The target handle ID\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateHandleConnection = (source, target, sourceHandle, targetHandle) => {\n  var _source$data, _source$data$outputs, _source$data$outputs$, _target$data, _target$data$inputs, _target$data$inputs$t;\n  // Get the data types from handles\n  const sourceDataType = (source === null || source === void 0 ? void 0 : (_source$data = source.data) === null || _source$data === void 0 ? void 0 : (_source$data$outputs = _source$data.outputs) === null || _source$data$outputs === void 0 ? void 0 : (_source$data$outputs$ = _source$data$outputs[sourceHandle]) === null || _source$data$outputs$ === void 0 ? void 0 : _source$data$outputs$.type) || 'any';\n  const targetDataType = (target === null || target === void 0 ? void 0 : (_target$data = target.data) === null || _target$data === void 0 ? void 0 : (_target$data$inputs = _target$data.inputs) === null || _target$data$inputs === void 0 ? void 0 : (_target$data$inputs$t = _target$data$inputs[targetHandle]) === null || _target$data$inputs$t === void 0 ? void 0 : _target$data$inputs$t.type) || 'any';\n\n  // Check if data types are compatible\n  const compatibleTypes = DATA_TYPE_COMPATIBILITY[sourceDataType] || [];\n  if (!compatibleTypes.includes(targetDataType)) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Incompatible data types: ${sourceDataType} cannot connect to ${targetDataType}`\n    };\n  }\n  return {\n    isValid: true,\n    message: `Data types ${sourceDataType} and ${targetDataType} are compatible`\n  };\n};\n\n/**\n * Validates connection count constraints\n * \n * @param {Object} node - The node to check\n * @param {Array} connections - All existing connections\n * @param {string} connectionType - Either 'input' or 'output'\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateConnectionCount = (node, connections, connectionType) => {\n  const nodeType = node.type;\n  const nodeTypeInfo = NODE_TYPES[nodeType];\n  if (!nodeTypeInfo) {\n    return {\n      isValid: true,\n      // Skip constraint validation for unknown node types\n      message: 'Unknown node type, skipping constraint validation'\n    };\n  }\n\n  // Count existing connections for this node\n  const connectionCount = connections.filter(conn => {\n    if (connectionType === 'input') {\n      return conn.target === node.id;\n    } else {\n      return conn.source === node.id;\n    }\n  }).length;\n\n  // Check against max connection constraints\n  const maxConnections = connectionType === 'input' ? nodeTypeInfo.maxInputConnections : nodeTypeInfo.maxOutputConnections;\n  if (maxConnections !== null && connectionCount >= maxConnections) {\n    return {\n      isValid: false,\n      hasWarning: true,\n      message: `Maximum ${connectionType} connections (${maxConnections}) reached for ${nodeType}`\n    };\n  }\n  return {\n    isValid: true,\n    message: `${connectionType} connection count is valid (${connectionCount}/${maxConnections || 'âˆž'})`\n  };\n};\n\n/**\n * Detect cycles in the flow graph\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const detectCycles = (nodes, edges) => {\n  // Create an adjacency list representation of the graph\n  const graph = {};\n  nodes.forEach(node => {\n    graph[node.id] = [];\n  });\n  edges.forEach(edge => {\n    if (edge.source && edge.target) {\n      graph[edge.source].push(edge.target);\n    }\n  });\n\n  // DFS to detect cycles\n  const visited = {};\n  const recStack = {};\n  function dfsUtil(nodeId, visited, recStack) {\n    if (!visited[nodeId]) {\n      visited[nodeId] = true;\n      recStack[nodeId] = true;\n      const neighbors = graph[nodeId] || [];\n      for (const neighbor of neighbors) {\n        if (!visited[neighbor] && dfsUtil(neighbor, visited, recStack)) {\n          return true;\n        } else if (recStack[neighbor]) {\n          return true;\n        }\n      }\n    }\n    recStack[nodeId] = false;\n    return false;\n  }\n\n  // Check each node as a starting point\n  for (const nodeId in graph) {\n    if (!visited[nodeId]) {\n      if (dfsUtil(nodeId, visited, recStack)) {\n        return {\n          isValid: false,\n          hasError: true,\n          message: 'Cycle detected in flow. This may cause infinite loops.'\n        };\n      }\n    }\n  }\n  return {\n    isValid: true,\n    message: 'No cycles detected in flow.'\n  };\n};\n\n/**\n * Validates a connection as a whole\n * \n * @param {Object} connection - The connection to validate\n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateConnection = (connection, nodes, edges) => {\n  // Find source and target nodes\n  const sourceNode = nodes.find(node => node.id === connection.source);\n  const targetNode = nodes.find(node => node.id === connection.target);\n  if (!sourceNode || !targetNode) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: 'Source or target node not found'\n    };\n  }\n\n  // Validate node type compatibility\n  const nodeTypeValidation = validateNodeTypeConnection(sourceNode.type, targetNode.type);\n  if (!nodeTypeValidation.isValid) {\n    return nodeTypeValidation;\n  }\n\n  // Validate handle data type compatibility\n  const handleValidation = validateHandleConnection(sourceNode, targetNode, connection.sourceHandle, connection.targetHandle);\n  if (!handleValidation.isValid) {\n    return handleValidation;\n  }\n\n  // Validate source output connection count\n  const sourceOutputValidation = validateConnectionCount(sourceNode, edges, 'output');\n  if (!sourceOutputValidation.isValid) {\n    return sourceOutputValidation;\n  }\n\n  // Validate target input connection count\n  const targetInputValidation = validateConnectionCount(targetNode, edges, 'input');\n  if (!targetInputValidation.isValid) {\n    return targetInputValidation;\n  }\n\n  // Check for cycles when adding this connection\n  const allEdges = [...edges, connection].filter(e =>\n  // Filter out the existing version of this connection if we're updating\n  !(e.id !== connection.id && e.source === connection.source && e.target === connection.target));\n  const cycleValidation = detectCycles(nodes, allEdges);\n  if (!cycleValidation.isValid) {\n    return cycleValidation;\n  }\n\n  // All validations passed\n  return {\n    isValid: true,\n    message: 'Connection is valid'\n  };\n};\n\n/**\n * Validates a full flow\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation results with isValid flag, error list, and node/edge specific validation\n */\nexport const validateFlow = (nodes, edges) => {\n  const result = {\n    isValid: true,\n    hasErrors: false,\n    hasWarnings: false,\n    errors: [],\n    warnings: [],\n    nodeValidation: {},\n    edgeValidation: {}\n  };\n\n  // Check if there's at least one source node\n  const sourceNodes = nodes.filter(node => node.type === 'sourceNode');\n  if (sourceNodes.length === 0) {\n    result.isValid = false;\n    result.hasErrors = true;\n    result.errors.push('Flow must have at least one source node');\n  }\n\n  // Check if there's at least one destination node\n  const destinationNodes = nodes.filter(node => node.type === 'destinationNode');\n  if (destinationNodes.length === 0) {\n    result.isValid = false;\n    result.hasErrors = true;\n    result.errors.push('Flow must have at least one destination node');\n  }\n\n  // Check if each source node is connected\n  sourceNodes.forEach(node => {\n    const hasOutgoingConnections = edges.some(edge => edge.source === node.id);\n    if (!hasOutgoingConnections) {\n      var _node$data;\n      result.hasWarnings = true;\n      result.warnings.push(`Source node ${((_node$data = node.data) === null || _node$data === void 0 ? void 0 : _node$data.label) || node.id} is not connected to any destination`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Source node not connected'\n      };\n    }\n  });\n\n  // Check if each destination node is connected\n  destinationNodes.forEach(node => {\n    const hasIncomingConnections = edges.some(edge => edge.target === node.id);\n    if (!hasIncomingConnections) {\n      var _node$data2;\n      result.hasWarnings = true;\n      result.warnings.push(`Destination node ${((_node$data2 = node.data) === null || _node$data2 === void 0 ? void 0 : _node$data2.label) || node.id} has no incoming connections`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Destination node not connected'\n      };\n    }\n  });\n\n  // Validate all connections\n  edges.forEach(edge => {\n    const edgeValidation = validateConnection(edge, nodes, edges);\n    result.edgeValidation[edge.id] = edgeValidation;\n    if (!edgeValidation.isValid) {\n      if (edgeValidation.hasError) {\n        result.isValid = false;\n        result.hasErrors = true;\n        result.errors.push(`Invalid connection: ${edgeValidation.message}`);\n      } else if (edgeValidation.hasWarning) {\n        result.hasWarnings = true;\n        result.warnings.push(`Warning for connection: ${edgeValidation.message}`);\n      }\n    }\n  });\n\n  // Detect unreachable nodes\n  const reachableNodes = new Set();\n\n  // Start with source nodes\n  sourceNodes.forEach(node => {\n    reachableNodes.add(node.id);\n  });\n\n  // Follow the connections\n  let newNodesAdded = true;\n  while (newNodesAdded) {\n    newNodesAdded = false;\n    edges.forEach(edge => {\n      if (reachableNodes.has(edge.source) && !reachableNodes.has(edge.target)) {\n        reachableNodes.add(edge.target);\n        newNodesAdded = true;\n      }\n    });\n  }\n\n  // Check for unreachable nodes\n  nodes.forEach(node => {\n    if (!reachableNodes.has(node.id) && node.type !== 'sourceNode') {\n      var _node$data3;\n      result.hasWarnings = true;\n      result.warnings.push(`Node ${((_node$data3 = node.data) === null || _node$data3 === void 0 ? void 0 : _node$data3.label) || node.id} is unreachable from any source`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Node is unreachable'\n      };\n    }\n  });\n  return result;\n};\n\n/**\n * Deep validation for a flow before execution\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Promise<Object>} Validation results with detailed checks\n */\nexport const validateFlowForExecution = async (nodes, edges) => {\n  // Start with basic validation\n  const baseValidation = validateFlow(nodes, edges);\n\n  // If the basic validation failed with errors, no need to continue\n  if (!baseValidation.isValid) {\n    return baseValidation;\n  }\n\n  // Perform deep validation for each node\n  const result = {\n    ...baseValidation,\n    nodeConfig: {}\n  };\n\n  // Check node configuration completeness\n  await Promise.all(nodes.map(async node => {\n    var _node$data4;\n    // Skip if node has no validate function\n    if (!((_node$data4 = node.data) !== null && _node$data4 !== void 0 && _node$data4.validate)) {\n      return;\n    }\n    try {\n      const nodeValidation = await node.data.validate();\n      result.nodeConfig[node.id] = nodeValidation;\n      if (!nodeValidation.isValid) {\n        if (nodeValidation.hasError) {\n          var _node$data5;\n          result.isValid = false;\n          result.hasErrors = true;\n          result.errors.push(`Node ${((_node$data5 = node.data) === null || _node$data5 === void 0 ? void 0 : _node$data5.label) || node.id}: ${nodeValidation.message}`);\n        } else if (nodeValidation.hasWarning) {\n          var _node$data6;\n          result.hasWarnings = true;\n          result.warnings.push(`Node ${((_node$data6 = node.data) === null || _node$data6 === void 0 ? void 0 : _node$data6.label) || node.id}: ${nodeValidation.message}`);\n        }\n      }\n    } catch (error) {\n      var _node$data7;\n      result.isValid = false;\n      result.hasErrors = true;\n      result.errors.push(`Error validating node ${((_node$data7 = node.data) === null || _node$data7 === void 0 ? void 0 : _node$data7.label) || node.id}: ${error.message}`);\n    }\n  }));\n  return result;\n};\nexport default {\n  validateNodeTypeConnection,\n  validateHandleConnection,\n  validateConnectionCount,\n  detectCycles,\n  validateConnection,\n  validateFlow,\n  validateFlowForExecution\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}