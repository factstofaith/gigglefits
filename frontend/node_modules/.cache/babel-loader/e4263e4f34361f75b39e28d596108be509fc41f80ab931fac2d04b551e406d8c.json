{"ast":null,"code":"/**\n * S3 Bucket Browser Component\n *\n * A component for browsing and selecting AWS S3 buckets and objects.\n * Supports bucket listing, object browsing, searching, and file operations.\n *\n * @component\n */\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Box, Button, Card, CardContent, CardHeader, Chip, CircularProgress, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Divider, FormControl, FormGroup, FormHelperText, FormLabel, Grid, IconButton, InputAdornment, InputLabel, List, ListItem, ListItemIcon, ListItemSecondaryAction, ListItemText, Menu, MenuItem, Paper, Radio, RadioGroup, Select, Slider, Stack, Switch, Tab, Tabs, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, TextField, Tooltip, Typography, Alert, AlertTitle, FormControlLabel, Checkbox, LinearProgress } from '@mui/material';\nimport { DatePicker } from '@mui/x-date-pickers/DatePicker';\nimport { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';\nimport { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';\nimport { AddCircleOutline as AddIcon, ArrowUpward as UpIcon, CloudUpload as UploadIcon, Delete as DeleteIcon, Download as DownloadIcon, Folder as FolderIcon, FolderOpen as FolderOpenIcon, InsertDriveFile as FileIcon, MoreVert as MoreVertIcon, Refresh as RefreshIcon, Search as SearchIcon, Visibility as ViewIcon, CreateNewFolder as CreateFolderIcon, Storage as BucketIcon, CheckCircle as CheckCircleIcon, Close as CloseIcon, Info as InfoIcon, Warning as WarningIcon, ErrorOutline as ErrorOutlineIcon, FilterList as FilterListIcon, FilterAlt as FilterAltIcon, SelectAll as SelectAllIcon, LibraryAddCheck as BatchActionIcon, Public as PublicIcon, Lock as LockIcon, Archive as ArchiveIcon, Check as CheckIcon, Clear as ClearIcon, ContentCopy as CopyIcon, ZoomIn as ZoomInIcon, MoveToInbox as MoveIcon, Label as TagIcon, Settings as AdvancedIcon } from '@mui/icons-material';\n\n// Utilities for handling file types\nimport { generateFileMetadata, MimeTypeCategories } from \"../../../utils/fileTypeUtils\";\n\n// File type options for filtering\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst FILE_TYPE_OPTIONS = [{\n  value: 'TEXT',\n  label: 'Text Files',\n  description: 'CSV, TXT, JSON, XML, etc.'\n}, {\n  value: 'DOCUMENT',\n  label: 'Documents',\n  description: 'PDF, DOCX, XLSX, PPTX, etc.'\n}, {\n  value: 'IMAGE',\n  label: 'Images',\n  description: 'JPG, PNG, GIF, SVG, etc.'\n}, {\n  value: 'AUDIO',\n  label: 'Audio',\n  description: 'MP3, WAV, OGG, etc.'\n}, {\n  value: 'VIDEO',\n  label: 'Video',\n  description: 'MP4, WEBM, AVI, etc.'\n}, {\n  value: 'ARCHIVE',\n  label: 'Archives',\n  description: 'ZIP, RAR, TAR, etc.'\n}, {\n  value: 'DATA',\n  label: 'Data Files',\n  description: 'CSV, JSON, Parquet, etc.'\n}, {\n  value: 'CODE',\n  label: 'Source Code',\n  description: 'JS, PY, JAVA, etc.'\n}];\n\n// Size options presets for filtering\nconst SIZE_PRESETS = [{\n  value: [0, 1024 * 10],\n  label: 'Tiny (< 10KB)'\n}, {\n  value: [0, 1024 * 100],\n  label: 'Small (< 100KB)'\n}, {\n  value: [1024 * 100, 1024 * 1024],\n  label: 'Medium (100KB - 1MB)'\n}, {\n  value: [1024 * 1024, 1024 * 1024 * 10],\n  label: 'Large (1MB - 10MB)'\n}, {\n  value: [1024 * 1024 * 10, 1024 * 1024 * 100],\n  label: 'X-Large (10MB - 100MB)'\n}, {\n  value: [1024 * 1024 * 100, Number.MAX_SAFE_INTEGER],\n  label: 'XX-Large (> 100MB)'\n}];\n\n// Date presets for filtering\nconst DATE_PRESETS = [{\n  value: {\n    days: 1\n  },\n  label: 'Last 24 hours'\n}, {\n  value: {\n    days: 7\n  },\n  label: 'Last 7 days'\n}, {\n  value: {\n    days: 30\n  },\n  label: 'Last 30 days'\n}, {\n  value: {\n    days: 90\n  },\n  label: 'Last 3 months'\n}, {\n  value: {\n    days: 365\n  },\n  label: 'Last year'\n}, {\n  value: 'custom',\n  label: 'Custom range'\n}];\n\n/**\n * Format file size to human-readable format\n * @param {number} bytes - Size in bytes\n * @returns {string} Formatted size string\n */\nconst formatFileSize = bytes => {\n  if (bytes === 0) return '0 Bytes';\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\n/**\n * Format date to readable string\n * @param {string} dateString - ISO date string\n * @returns {string} Formatted date string\n */\nconst formatDate = dateString => {\n  if (!dateString) return 'Unknown';\n  const date = new Date(dateString);\n  return date.toLocaleString();\n};\n\n/**\n * Gets the date from a specified number of days ago\n * @param {number} days - Number of days to subtract from current date\n * @returns {Date} Date object representing the date X days ago\n */\nconst getDateDaysAgo = days => {\n  const date = new Date();\n  date.setDate(date.getDate() - days);\n  return date;\n};\n\n/**\n * Applies filters to an array of objects\n * @param {Array} objects - Array of S3 objects to filter\n * @param {Object} filters - Filter criteria\n * @returns {Array} Filtered array of objects\n */\nconst applyFilters = (objects, filters) => {\n  if (!objects || !filters) return objects;\n  return objects.filter(item => {\n    // Skip directories if we're filtering by file type or size\n    if (item.type === 'folder' || item.type === 'directory') {\n      // Only filter directories by date or custom prefix\n      let matchesPrefix = true;\n      let matchesDate = true;\n\n      // Filter by prefix if specified\n      if (filters.customPrefix) {\n        matchesPrefix = item.key.toLowerCase().includes(filters.customPrefix.toLowerCase());\n      }\n\n      // Filter by date if specified\n      if (filters.dateRange.start && filters.dateRange.end) {\n        const itemDate = new Date(item.lastModified);\n        matchesDate = itemDate >= filters.dateRange.start && itemDate <= filters.dateRange.end;\n      }\n      return matchesPrefix && matchesDate;\n    }\n\n    // Filter by file type\n    let matchesFileType = true;\n    if (filters.fileTypes && filters.fileTypes.length > 0) {\n      matchesFileType = filters.fileTypes.some(type => {\n        var _MimeTypeCategories$t;\n        // Check if this file's content type belongs to the selected category\n        const contentType = item.contentType || '';\n        return (_MimeTypeCategories$t = MimeTypeCategories[type]) === null || _MimeTypeCategories$t === void 0 ? void 0 : _MimeTypeCategories$t.some(mimeType => contentType.toLowerCase().includes(mimeType.toLowerCase()));\n      });\n    }\n\n    // Filter by size range\n    let matchesSize = true;\n    if (filters.sizeRange && filters.sizeRange.length === 2) {\n      const size = item.size || 0;\n      matchesSize = size >= filters.sizeRange[0] && size <= filters.sizeRange[1];\n    }\n\n    // Filter by date range\n    let matchesDate = true;\n    if (filters.dateRange.start && filters.dateRange.end) {\n      const itemDate = new Date(item.lastModified);\n      matchesDate = itemDate >= filters.dateRange.start && itemDate <= filters.dateRange.end;\n    }\n\n    // Filter by custom prefix\n    let matchesPrefix = true;\n    if (filters.customPrefix) {\n      matchesPrefix = item.key.toLowerCase().includes(filters.customPrefix.toLowerCase());\n    }\n    return matchesFileType && matchesSize && matchesDate && matchesPrefix;\n  });\n};\n\n/**\n * Performs batch operation on selected items with comprehensive progress tracking\n * @param {string} action - The action to perform (delete, download, copy, etc.)\n * @param {Array} items - Array of selected items\n * @param {string} target - Target location for copy/move operations\n * @returns {Promise<Object>} Result of the batch operation\n */\nconst performBatchOperation = async function (action, items) {\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (!items || items.length === 0) {\n    return {\n      success: false,\n      message: 'No items selected'\n    };\n  }\n\n  // Reset status\n  setBatchOperationStatus({\n    inProgress: true,\n    completed: false,\n    failed: false,\n    message: `Processing ${items.length} items...`,\n    details: null,\n    progress: 0\n  });\n\n  // Track total items for progress calculation\n  const totalItems = items.length;\n  const updateProgress = processedItems => {\n    const progress = Math.round(processedItems / totalItems * 100);\n    setBatchOperationStatus(prev => ({\n      ...prev,\n      progress,\n      message: `Processed ${processedItems} of ${totalItems} items (${progress}%)`\n    }));\n  };\n  try {\n    // Different operations based on action type\n    switch (action) {\n      case 'delete':\n        // Simulated batch delete with progress\n        console.log(`Batch deleting ${items.length} items`);\n\n        // Simulate progress updates\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 75));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully deleted ${items.length} items`,\n          details: {\n            itemCount: items.length,\n            itemTypes: countItemTypes(items),\n            totalSize: calculateTotalSize(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully deleted ${items.length} items`,\n          details: {\n            itemCount: items.length\n          }\n        };\n      case 'download':\n        // Simulated batch download with progress\n        console.log(`Batch downloading ${items.length} items`);\n\n        // Faster progress simulation for download\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 50));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Prepared ${items.length} items for download`,\n          details: {\n            itemCount: items.length,\n            itemTypes: countItemTypes(items),\n            totalSize: calculateTotalSize(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Prepared ${items.length} items for download`,\n          details: {\n            itemCount: items.length\n          }\n        };\n      case 'copy':\n        // Simulated batch copy with progress and target\n        console.log(`Batch copying ${items.length} items to ${target}`);\n\n        // Slower progress simulation for copy\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully copied ${items.length} items to ${target || 'destination'}`,\n          details: {\n            itemCount: items.length,\n            target: target || 'destination',\n            itemTypes: countItemTypes(items),\n            totalSize: calculateTotalSize(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully copied ${items.length} items`,\n          details: {\n            itemCount: items.length,\n            target\n          }\n        };\n      case 'move':\n        // Simulated batch move with progress and target\n        console.log(`Batch moving ${items.length} items to ${target}`);\n\n        // Slower progress simulation for move\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 125));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully moved ${items.length} items to ${target || 'destination'}`,\n          details: {\n            itemCount: items.length,\n            target: target || 'destination',\n            itemTypes: countItemTypes(items),\n            totalSize: calculateTotalSize(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully moved ${items.length} items`,\n          details: {\n            itemCount: items.length,\n            target\n          }\n        };\n      case 'makePublic':\n        // Simulated making items public with progress\n        console.log(`Making ${items.length} items public`);\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 40));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully made ${items.length} items public`,\n          details: {\n            itemCount: items.length,\n            itemTypes: countItemTypes(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully made ${items.length} items public`,\n          details: {\n            itemCount: items.length\n          }\n        };\n      case 'makePrivate':\n        // Simulated making items private with progress\n        console.log(`Making ${items.length} items private`);\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 40));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully made ${items.length} items private`,\n          details: {\n            itemCount: items.length,\n            itemTypes: countItemTypes(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully made ${items.length} items private`,\n          details: {\n            itemCount: items.length\n          }\n        };\n      case 'addTags':\n        // Simulated tagging items with progress\n        console.log(`Adding tags to ${items.length} items`);\n        for (let i = 0; i < totalItems; i++) {\n          await new Promise(resolve => setTimeout(resolve, 60));\n          updateProgress(i + 1);\n        }\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: true,\n          failed: false,\n          message: `Successfully tagged ${items.length} items`,\n          details: {\n            itemCount: items.length,\n            itemTypes: countItemTypes(items)\n          },\n          progress: 100\n        });\n        return {\n          success: true,\n          message: `Successfully tagged ${items.length} items`,\n          details: {\n            itemCount: items.length\n          }\n        };\n      default:\n        setBatchOperationStatus({\n          inProgress: false,\n          completed: false,\n          failed: true,\n          message: `Unknown action: ${action}`,\n          details: null,\n          progress: 0\n        });\n        return {\n          success: false,\n          message: `Unknown action: ${action}`\n        };\n    }\n  } catch (error) {\n    // Handle errors\n    setBatchOperationStatus({\n      inProgress: false,\n      completed: false,\n      failed: true,\n      message: `Operation failed: ${error.message}`,\n      details: {\n        error: error.message\n      },\n      progress: 0\n    });\n    return {\n      success: false,\n      message: `Operation failed: ${error.message}`,\n      details: {\n        error: error.message\n      }\n    };\n  }\n};\n\n/**\n * Counts items by type (file, folder) in a selection\n * @param {Array} items - The items to count\n * @returns {Object} Counts by type\n */\nconst countItemTypes = items => {\n  if (!items) return {\n    files: 0,\n    folders: 0\n  };\n  const counts = {\n    files: 0,\n    folders: 0\n  };\n  items.forEach(item => {\n    if (item.type === 'folder' || item.type === 'directory') {\n      counts.folders++;\n    } else {\n      counts.files++;\n    }\n  });\n  return counts;\n};\n\n/**\n * Calculates the total size of selected items\n * @param {Array} items - The items to calculate size for\n * @returns {number} Total size in bytes\n */\nconst calculateTotalSize = items => {\n  if (!items) return 0;\n  return items.reduce((total, item) => {\n    // Only add size for files\n    if (item.type !== 'folder' && item.type !== 'directory') {\n      return total + (item.size || 0);\n    }\n    return total;\n  }, 0);\n};\n\n/**\n * S3 Bucket Browser Component\n */\nconst S3BucketBrowser = _ref => {\n  let {\n    config,\n    onSelectBucket,\n    onSelectObject,\n    readOnly = false,\n    selectedBucket = '',\n    selectedPrefix = ''\n  } = _ref;\n  // Ref to track if component is mounted (prevents memory leaks from state updates after unmount)\n  const isMounted = useRef(true);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  // Refs to track active timers and intervals for cleanup\n  const timeoutIdsRef = useRef([]);\n  const intervalIdsRef = useRef([]);\n\n  // Helper to safely set timeout with tracking for cleanup\n  const setSafeTimeout = useCallback((callback, delay) => {\n    const id = setTimeout(() => {\n      // Remove from tracking array when executed\n      timeoutIdsRef.current = timeoutIdsRef.current.filter(timeoutId => timeoutId !== id);\n      // Only execute callback if component is still mounted\n      if (isMounted.current) {\n        callback();\n      }\n    }, delay);\n\n    // Add to tracking array\n    timeoutIdsRef.current.push(id);\n    return id;\n  }, []);\n\n  // Helper to safely set interval with tracking for cleanup\n  const setSafeInterval = useCallback((callback, delay) => {\n    const id = setInterval(() => {\n      // Only execute callback if component is still mounted\n      if (isMounted.current) {\n        callback();\n      }\n    }, delay);\n\n    // Add to tracking array\n    intervalIdsRef.current.push(id);\n    return id;\n  }, []);\n\n  // Clean up all active timers and intervals on unmount\n  useEffect(() => {\n    return () => {\n      // Clear all tracked timeouts\n      timeoutIdsRef.current.forEach(id => clearTimeout(id));\n      timeoutIdsRef.current = [];\n\n      // Clear all tracked intervals\n      intervalIdsRef.current.forEach(id => clearInterval(id));\n      intervalIdsRef.current = [];\n    };\n  }, []);\n\n  // Load buckets on mount and when config changes with proper cleanup\n  useEffect(() => {\n    // Create abort controller for cleanup\n    const abortController = new AbortController();\n    if (config) {\n      loadBuckets(abortController.signal);\n    }\n\n    // Cleanup: abort any in-progress fetches when component unmounts or config changes\n    return () => {\n      abortController.abort();\n    };\n  }, [config, loadBuckets]);\n  // State for buckets and objects\n  const [buckets, setBuckets] = useState([]);\n  const [objects, setObjects] = useState([]);\n  const [currentPrefix, setCurrentPrefix] = useState(selectedPrefix || '');\n  const [prefixHistory, setPrefixHistory] = useState([]);\n\n  // State for loading indicators\n  const [loading, setLoading] = useState(false);\n  const [bucketLoading, setBucketLoading] = useState(false);\n\n  // Search state\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n\n  // Enhanced filtering state\n  const [filterDialogOpen, setFilterDialogOpen] = useState(false);\n  const [filterTabValue, setFilterTabValue] = useState(0);\n  const [activeFilters, setActiveFilters] = useState({\n    fileTypes: [],\n    sizeRange: [0, Number.MAX_SAFE_INTEGER],\n    dateRange: {\n      start: null,\n      end: null\n    },\n    modifiedBy: '',\n    customPrefix: ''\n  });\n\n  // Active filter tracking for visual feedback\n  const [activeFilterCount, setActiveFilterCount] = useState(0);\n  const [filterSummary, setFilterSummary] = useState({\n    hasFileTypeFilters: false,\n    hasSizeFilter: false,\n    hasDateFilter: false,\n    hasCustomPrefix: false\n  });\n\n  // Batch operations state\n  const [selectedItems, setSelectedItems] = useState([]);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [batchActionDialogOpen, setBatchActionDialogOpen] = useState(false);\n  const [batchAction, setBatchAction] = useState('');\n  const [batchActionTarget, setBatchActionTarget] = useState('');\n  const [batchOperationStatus, setBatchOperationStatus] = useState({\n    inProgress: false,\n    completed: false,\n    failed: false,\n    message: '',\n    details: null,\n    progress: 0\n  });\n\n  // Dialog states\n  const [newBucketDialogOpen, setNewBucketDialogOpen] = useState(false);\n  const [newBucketName, setNewBucketName] = useState('');\n  const [newFolderDialogOpen, setNewFolderDialogOpen] = useState(false);\n  const [newFolderName, setNewFolderName] = useState('');\n  const [confirmDeleteDialogOpen, setConfirmDeleteDialogOpen] = useState(false);\n  const [itemToDelete, setItemToDelete] = useState(null);\n  const [fileUploadDialogOpen, setFileUploadDialogOpen] = useState(false);\n  const [selectedFile, setSelectedFile] = useState(null);\n  const [filesToUpload, setFilesToUpload] = useState([]);\n  const [currentUploadIndex, setCurrentUploadIndex] = useState(0);\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [uploadOptions, setUploadOptions] = useState({\n    overwriteExisting: true,\n    makePublic: false\n  });\n\n  // Context menu state\n  const [contextMenuPos, setContextMenuPos] = useState(null);\n  const [selectedItem, setSelectedItem] = useState(null);\n\n  // File viewer state\n  const [fileViewerOpen, setFileViewerOpen] = useState(false);\n  const [fileViewUrl, setFileViewUrl] = useState('');\n  const [fileViewType, setFileViewType] = useState('');\n\n  // Error state\n  const [error, setError] = useState(null);\n\n  /**\n   * Load buckets from S3 with support for cancellation\n   * @param {AbortSignal} [signal] - Optional AbortSignal for cancellation\n   */\n  const loadBuckets = useCallback(async signal => {\n    if (!config) return;\n    setBucketLoading(true);\n    setError(null);\n    try {\n      // Simulated API call for development environment\n      console.log('Loading S3 buckets with config:', config);\n\n      // Create a promise that can be aborted\n      const abortablePromise = new Promise((resolve, reject) => {\n        // Track the timeout ID so we can clear it if aborted\n        const timeoutId = setTimeout(() => {\n          resolve({\n            status: 'success',\n            buckets: [{\n              name: 'data-bucket-1',\n              creationDate: new Date(Date.now() - 15552000000).toISOString()\n            }, {\n              name: 'data-bucket-2',\n              creationDate: new Date(Date.now() - 7776000000).toISOString()\n            }, {\n              name: 'logs-bucket',\n              creationDate: new Date(Date.now() - 31104000000).toISOString()\n            }, {\n              name: 'backup-bucket',\n              creationDate: new Date(Date.now() - 62208000000).toISOString()\n            }, {\n              name: 'test-integration-bucket',\n              creationDate: new Date().toISOString()\n            }]\n          });\n        }, 1000);\n\n        // Handle abort signal if provided\n        if (signal) {\n          signal.addEventListener('abort', () => {\n            clearTimeout(timeoutId);\n            reject(new Error('Operation cancelled'));\n          });\n        }\n\n        // Track the timeout for cleanup\n        timeoutIdsRef.current.push(timeoutId);\n      });\n      const response = await abortablePromise;\n\n      // Check if component is still mounted before updating state\n      if (!isMounted.current) return;\n      if (response.status === 'success') {\n        setBuckets(response.buckets);\n\n        // If a bucket is already selected, keep it selected\n        if (selectedBucket && response.buckets.some(b => b.name === selectedBucket)) {\n          loadObjects(selectedBucket, selectedPrefix || '', signal);\n        }\n      } else {\n        setError(response.message || 'Failed to load S3 buckets');\n      }\n    } catch (err) {\n      // Only log and update error state if not cancelled and component is mounted\n      if (err.message !== 'Operation cancelled' && isMounted.current) {\n        console.error('Error loading buckets:', err);\n        setError(err.message || 'An error occurred while loading S3 buckets');\n      }\n    } finally {\n      // Only update loading state if component is still mounted\n      if (isMounted.current) {\n        setBucketLoading(false);\n      }\n    }\n  }, [config, selectedBucket, selectedPrefix, isMounted]);\n\n  /**\n   * Load objects from a bucket with specified prefix\n   */\n  const loadObjects = useCallback(async function (bucketName) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    if (!config || !bucketName) return;\n    setLoading(true);\n    setError(null);\n    try {\n      // Simulate API call\n      console.log(`Loading objects from bucket: ${bucketName}, prefix: ${prefix}`);\n\n      // Simulate API response with mock data based on prefix\n      const response = await new Promise(resolve => setTimeout(() => {\n        // Generate different mock responses based on the prefix\n        let mockObjects = [];\n        if (prefix === '') {\n          // Root directory\n          mockObjects = [{\n            key: 'folder1/',\n            size: 0,\n            lastModified: new Date(Date.now() - 86400000).toISOString(),\n            type: 'folder'\n          }, {\n            key: 'folder2/',\n            size: 0,\n            lastModified: new Date(Date.now() - 172800000).toISOString(),\n            type: 'folder'\n          }, {\n            key: 'data/',\n            size: 0,\n            lastModified: new Date(Date.now() - 259200000).toISOString(),\n            type: 'folder'\n          }, {\n            key: 'sample.csv',\n            size: 1024,\n            lastModified: new Date(Date.now() - 345600000).toISOString(),\n            contentType: 'text/csv',\n            type: 'file'\n          }, {\n            key: 'readme.txt',\n            size: 512,\n            lastModified: new Date(Date.now() - 432000000).toISOString(),\n            contentType: 'text/plain',\n            type: 'file'\n          }];\n        } else if (prefix === 'folder1/') {\n          // Folder 1 contents\n          mockObjects = [{\n            key: 'folder1/subfolder/',\n            size: 0,\n            lastModified: new Date(Date.now() - 518400000).toISOString(),\n            type: 'folder'\n          }, {\n            key: 'folder1/data1.json',\n            size: 2048,\n            lastModified: new Date(Date.now() - 604800000).toISOString(),\n            contentType: 'application/json',\n            type: 'file'\n          }];\n        } else if (prefix === 'folder1/subfolder/') {\n          // Subfolder contents\n          mockObjects = [{\n            key: 'folder1/subfolder/deep.xml',\n            size: 4096,\n            lastModified: new Date(Date.now() - 691200000).toISOString(),\n            contentType: 'application/xml',\n            type: 'file'\n          }];\n        } else if (prefix === 'folder2/') {\n          // Folder 2 contents\n          mockObjects = [{\n            key: 'folder2/image.png',\n            size: 102400,\n            lastModified: new Date(Date.now() - 777600000).toISOString(),\n            contentType: 'image/png',\n            type: 'file'\n          }, {\n            key: 'folder2/document.pdf',\n            size: 204800,\n            lastModified: new Date(Date.now() - 864000000).toISOString(),\n            contentType: 'application/pdf',\n            type: 'file'\n          }];\n        } else if (prefix === 'data/') {\n          // Data folder contents\n          mockObjects = [{\n            key: 'data/dataset1.csv',\n            size: 5120,\n            lastModified: new Date(Date.now() - 950400000).toISOString(),\n            contentType: 'text/csv',\n            type: 'file'\n          }, {\n            key: 'data/dataset2.csv',\n            size: 6144,\n            lastModified: new Date(Date.now() - 1036800000).toISOString(),\n            contentType: 'text/csv',\n            type: 'file'\n          }, {\n            key: 'data/dataset3.xlsx',\n            size: 8192,\n            lastModified: new Date(Date.now() - 1123200000).toISOString(),\n            contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            type: 'file'\n          }];\n        }\n        resolve({\n          status: 'success',\n          objects: mockObjects,\n          bucketName: bucketName,\n          prefix: prefix\n        });\n      }, 1000));\n      if (response.status === 'success') {\n        // Update current bucket and prefix\n        if (bucketName !== selectedBucket) {\n          onSelectBucket(bucketName);\n          setPrefixHistory([]);\n        }\n        setObjects(response.objects);\n        setCurrentPrefix(prefix);\n\n        // If this is a new prefix, add it to history\n        if (prefix !== currentPrefix) {\n          setPrefixHistory(prevHistory => {\n            // Add the previous prefix to history only if it's not empty\n            if (currentPrefix) {\n              return [...prevHistory, currentPrefix];\n            }\n            return prevHistory;\n          });\n        }\n      } else {\n        setError(response.message || 'Failed to load objects');\n      }\n    } catch (err) {\n      console.error('Error loading objects:', err);\n      setError(err.message || 'An error occurred while loading objects');\n    } finally {\n      setLoading(false);\n      setIsSearching(false);\n    }\n  }, [config, currentPrefix, onSelectBucket, selectedBucket]);\n\n  /**\n   * Navigate to a folder or object\n   */\n  const navigateTo = useCallback(item => {\n    if (item.type === 'folder') {\n      // Extract the folder prefix from the key\n      const fullPrefix = item.key;\n\n      // Load objects from the folder\n      loadObjects(selectedBucket, fullPrefix);\n    } else if (item.type === 'file') {\n      // Select the object\n      onSelectObject({\n        bucketName: selectedBucket,\n        prefix: currentPrefix,\n        key: item.key,\n        size: item.size,\n        lastModified: item.lastModified,\n        contentType: item.contentType\n      });\n    }\n  }, [currentPrefix, loadObjects, onSelectObject, selectedBucket]);\n\n  /**\n   * Go up one level in the prefix\n   */\n  const navigateUp = useCallback(() => {\n    if (prefixHistory.length > 0) {\n      // Get the previous prefix\n      const previousPrefix = prefixHistory[prefixHistory.length - 1];\n\n      // Update the prefix history\n      setPrefixHistory(prevHistory => prevHistory.slice(0, -1));\n\n      // Load objects from the previous prefix\n      loadObjects(selectedBucket, previousPrefix);\n    } else {\n      // If we're at the root of a bucket, go back to bucket list\n      setObjects([]);\n      setCurrentPrefix('');\n      onSelectBucket('');\n    }\n  }, [loadObjects, onSelectBucket, prefixHistory, selectedBucket]);\n\n  /**\n   * Search for objects\n   */\n  const searchObjects = useCallback(async () => {\n    if (!searchTerm || !selectedBucket) return;\n    setIsSearching(true);\n    setLoading(true);\n    setError(null);\n    try {\n      // Simulate API call\n      console.log(`Searching for \"${searchTerm}\" in bucket: ${selectedBucket}`);\n\n      // Simulate API response\n      const response = await new Promise(resolve => setTimeout(() => {\n        // Generate mock search results\n        const allPossibleObjects = [{\n          key: 'folder1/data1.json',\n          size: 2048,\n          lastModified: new Date(Date.now() - 604800000).toISOString(),\n          contentType: 'application/json',\n          type: 'file'\n        }, {\n          key: 'folder1/subfolder/deep.xml',\n          size: 4096,\n          lastModified: new Date(Date.now() - 691200000).toISOString(),\n          contentType: 'application/xml',\n          type: 'file'\n        }, {\n          key: 'folder2/image.png',\n          size: 102400,\n          lastModified: new Date(Date.now() - 777600000).toISOString(),\n          contentType: 'image/png',\n          type: 'file'\n        }, {\n          key: 'folder2/document.pdf',\n          size: 204800,\n          lastModified: new Date(Date.now() - 864000000).toISOString(),\n          contentType: 'application/pdf',\n          type: 'file'\n        }, {\n          key: 'data/dataset1.csv',\n          size: 5120,\n          lastModified: new Date(Date.now() - 950400000).toISOString(),\n          contentType: 'text/csv',\n          type: 'file'\n        }, {\n          key: 'data/dataset2.csv',\n          size: 6144,\n          lastModified: new Date(Date.now() - 1036800000).toISOString(),\n          contentType: 'text/csv',\n          type: 'file'\n        }, {\n          key: 'data/dataset3.xlsx',\n          size: 8192,\n          lastModified: new Date(Date.now() - 1123200000).toISOString(),\n          contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n          type: 'file'\n        }, {\n          key: 'sample.csv',\n          size: 1024,\n          lastModified: new Date(Date.now() - 345600000).toISOString(),\n          contentType: 'text/csv',\n          type: 'file'\n        }, {\n          key: 'readme.txt',\n          size: 512,\n          lastModified: new Date(Date.now() - 432000000).toISOString(),\n          contentType: 'text/plain',\n          type: 'file'\n        }];\n\n        // Filter by search term\n        const searchLower = searchTerm.toLowerCase();\n        const results = allPossibleObjects.filter(obj => obj.key.toLowerCase().includes(searchLower));\n        resolve({\n          status: 'success',\n          objects: results\n        });\n      }, 1000));\n      if (response.status === 'success') {\n        setSearchResults(response.objects);\n      } else {\n        setError(response.message || 'Failed to search objects');\n      }\n    } catch (err) {\n      console.error('Error searching objects:', err);\n      setError(err.message || 'An error occurred while searching objects');\n    } finally {\n      setLoading(false);\n    }\n  }, [searchTerm, selectedBucket]);\n\n  /**\n   * Clear search and return to regular browsing\n   */\n  const clearSearch = useCallback(() => {\n    setSearchTerm('');\n    setSearchResults([]);\n    setIsSearching(false);\n\n    // Reload current prefix\n    if (selectedBucket) {\n      loadObjects(selectedBucket, currentPrefix);\n    }\n  }, [currentPrefix, loadObjects, selectedBucket]);\n\n  /**\n   * Apply advanced filters and update UI\n   */\n  const applyAdvancedFilters = useCallback(() => {\n    if (!selectedBucket) return;\n    setLoading(true);\n    try {\n      // If we're searching, apply filters to search results\n      // Otherwise apply to the current objects list\n      const itemsToFilter = isSearching ? searchResults : objects;\n      const filteredResults = applyFilters(itemsToFilter, activeFilters);\n\n      // If searching, update search results\n      // Otherwise, update the objects list directly\n      if (isSearching) {\n        setSearchResults(filteredResults);\n      } else {\n        // Set a flag to indicate we're filtering\n        setIsSearching(true);\n        setSearchResults(filteredResults);\n      }\n    } catch (err) {\n      console.error('Error applying filters:', err);\n      setError('An error occurred while applying filters');\n    } finally {\n      setLoading(false);\n      setFilterDialogOpen(false);\n    }\n  }, [activeFilters, isSearching, objects, searchResults, selectedBucket]);\n\n  /**\n   * Clear all active filters\n   */\n  const clearFilters = useCallback(() => {\n    setActiveFilters({\n      fileTypes: [],\n      sizeRange: [0, Number.MAX_SAFE_INTEGER],\n      dateRange: {\n        start: null,\n        end: null\n      },\n      modifiedBy: '',\n      customPrefix: ''\n    });\n\n    // If we were filtering but not searching, reload objects\n    if (isSearching && !searchTerm) {\n      setIsSearching(false);\n      if (selectedBucket) {\n        loadObjects(selectedBucket, currentPrefix);\n      }\n    }\n    // If we were both searching and filtering, apply just the search\n    else if (isSearching && searchTerm) {\n      searchObjects();\n    }\n  }, [currentPrefix, isSearching, loadObjects, searchObjects, searchTerm, selectedBucket]);\n\n  /**\n   * Toggle selection mode for batch operations\n   */\n  const toggleSelectionMode = useCallback(() => {\n    setSelectionMode(prev => !prev);\n\n    // Clear selections when toggling off\n    if (selectionMode) {\n      setSelectedItems([]);\n    }\n  }, [selectionMode]);\n\n  /**\n   * Toggle selection of an item\n   */\n  const toggleItemSelection = useCallback((e, item) => {\n    e.stopPropagation(); // Prevent navigating when clicking the checkbox\n\n    setSelectedItems(prev => {\n      // Check if item is already selected\n      const isSelected = prev.some(selected => selected.key === item.key && selected.type === item.type);\n      if (isSelected) {\n        // Remove item from selection\n        return prev.filter(selected => !(selected.key === item.key && selected.type === item.type));\n      } else {\n        // Add item to selection\n        return [...prev, item];\n      }\n    });\n  }, []);\n\n  /**\n   * Check if an item is selected\n   */\n  const isItemSelected = useCallback(item => {\n    return selectedItems.some(selected => selected.key === item.key && selected.type === item.type);\n  }, [selectedItems]);\n\n  /**\n   * Select or deselect all items\n   */\n  const selectAllItems = useCallback(() => {\n    if (selectedItems.length === (isSearching ? searchResults.length : objects.length)) {\n      // If all are selected, deselect all\n      setSelectedItems([]);\n    } else {\n      // Otherwise, select all\n      setSelectedItems(isSearching ? searchResults : objects);\n    }\n  }, [isSearching, objects, searchResults, selectedItems]);\n\n  /**\n   * Execute batch action on selected items\n   */\n  const executeBatchAction = useCallback(async () => {\n    if (!selectedItems.length || !batchAction) return;\n    setLoading(true);\n    setError(null);\n    try {\n      const result = await performBatchOperation(batchAction, selectedItems);\n      if (result.success) {\n        // Set success message\n        // For delete, remove items from the list\n        if (batchAction === 'delete') {\n          const itemKeys = selectedItems.map(item => item.key);\n\n          // Update objects or search results accordingly\n          if (isSearching) {\n            setSearchResults(prev => prev.filter(item => !itemKeys.includes(item.key)));\n          } else {\n            setObjects(prev => prev.filter(item => !itemKeys.includes(item.key)));\n          }\n        }\n\n        // Reset selection\n        setSelectedItems([]);\n        setSelectionMode(false);\n      } else {\n        setError(result.message || 'Batch operation failed');\n      }\n    } catch (err) {\n      console.error('Error executing batch action:', err);\n      setError('An error occurred during batch operation');\n    } finally {\n      setLoading(false);\n      setBatchActionDialogOpen(false);\n    }\n  }, [batchAction, isSearching, selectedItems]);\n\n  /**\n   * Create a new bucket\n   */\n  const createBucket = useCallback(async () => {\n    if (!newBucketName) return;\n    setLoading(true);\n    setError(null);\n    try {\n      // Simulate API call\n      console.log(`Creating bucket: ${newBucketName}`);\n\n      // Simulate API response\n      const response = await new Promise(resolve => setTimeout(() => {\n        if (newBucketName.includes(' ')) {\n          resolve({\n            status: 'error',\n            message: 'Bucket name cannot contain spaces'\n          });\n        } else if (buckets.some(b => b.name === newBucketName)) {\n          resolve({\n            status: 'error',\n            message: 'Bucket already exists'\n          });\n        } else {\n          resolve({\n            status: 'success',\n            bucket: {\n              name: newBucketName,\n              creationDate: new Date().toISOString()\n            }\n          });\n        }\n      }, 1000));\n      if (response.status === 'success') {\n        // Add new bucket to list\n        setBuckets(prevBuckets => [...prevBuckets, response.bucket]);\n\n        // Close dialog\n        setNewBucketDialogOpen(false);\n        setNewBucketName('');\n\n        // Select the new bucket\n        onSelectBucket(response.bucket.name);\n        loadObjects(response.bucket.name, '');\n      } else {\n        setError(response.message || 'Failed to create bucket');\n      }\n    } catch (err) {\n      console.error('Error creating bucket:', err);\n      setError(err.message || 'An error occurred while creating bucket');\n    } finally {\n      setLoading(false);\n    }\n  }, [buckets, loadObjects, newBucketName, onSelectBucket]);\n\n  /**\n   * Create a new folder\n   */\n  const createFolder = useCallback(async () => {\n    if (!newFolderName || !selectedBucket) return;\n    setLoading(true);\n    setError(null);\n    try {\n      // Construct the full key\n      const fullKey = currentPrefix ? `${currentPrefix}${newFolderName}/` : `${newFolderName}/`;\n\n      // Simulate API call\n      console.log(`Creating folder: ${fullKey} in bucket: ${selectedBucket}`);\n\n      // Simulate API response\n      const response = await new Promise(resolve => setTimeout(() => {\n        resolve({\n          status: 'success',\n          folder: {\n            key: fullKey,\n            size: 0,\n            lastModified: new Date().toISOString(),\n            type: 'folder'\n          }\n        });\n      }, 1000));\n      if (response.status === 'success') {\n        // Add new folder to list\n        setObjects(prevObjects => [...prevObjects, response.folder]);\n\n        // Close dialog\n        setNewFolderDialogOpen(false);\n        setNewFolderName('');\n      } else {\n        setError(response.message || 'Failed to create folder');\n      }\n    } catch (err) {\n      console.error('Error creating folder:', err);\n      setError(err.message || 'An error occurred while creating folder');\n    } finally {\n      setLoading(false);\n    }\n  }, [currentPrefix, newFolderName, selectedBucket]);\n\n  /**\n   * Delete a bucket, folder, or object\n   */\n  const deleteItem = useCallback(async () => {\n    if (!itemToDelete) return;\n    setLoading(true);\n    setError(null);\n    try {\n      console.log(`Deleting ${itemToDelete.type}: ${itemToDelete.name || itemToDelete.key}`);\n\n      // Simulate API call\n      const response = await new Promise(resolve => setTimeout(() => {\n        resolve({\n          status: 'success'\n        });\n      }, 1000));\n      if (response.status === 'success') {\n        if (itemToDelete.type === 'bucket') {\n          // Remove bucket from list\n          setBuckets(prevBuckets => prevBuckets.filter(b => b.name !== itemToDelete.name));\n\n          // If this was the selected bucket, clear selection\n          if (selectedBucket === itemToDelete.name) {\n            onSelectBucket('');\n            setObjects([]);\n            setCurrentPrefix('');\n          }\n        } else {\n          // Remove object or folder from list\n          setObjects(prevObjects => prevObjects.filter(o => o.key !== itemToDelete.key));\n        }\n\n        // Close dialog\n        setConfirmDeleteDialogOpen(false);\n        setItemToDelete(null);\n      } else {\n        setError(response.message || 'Failed to delete item');\n      }\n    } catch (err) {\n      console.error('Error deleting item:', err);\n      setError(err.message || 'An error occurred while deleting item');\n    } finally {\n      setLoading(false);\n    }\n  }, [itemToDelete, onSelectBucket, selectedBucket]);\n\n  /**\n   * Process file selection for upload\n   */\n  const processFileSelection = useCallback(files => {\n    if (!files || files.length === 0) return;\n\n    // If it's a FileList (from input), convert to array\n    const fileArray = Array.from(files);\n    if (fileArray.length === 1) {\n      // Single file selection - use the existing workflow\n      setSelectedFile(fileArray[0]);\n      setFilesToUpload([]);\n    } else {\n      // Multiple file selection\n      setFilesToUpload(fileArray);\n      setSelectedFile(fileArray[0]); // Show the first file in preview\n      setCurrentUploadIndex(0);\n    }\n  }, []);\n\n  /**\n   * Upload a single file\n   */\n  const uploadSingleFile = useCallback(async file => {\n    if (!file || !selectedBucket) return false;\n    try {\n      // Construct the full key\n      const fullKey = currentPrefix ? `${currentPrefix}${file.name}` : file.name;\n      console.log(`Uploading file: ${fullKey} to bucket: ${selectedBucket}`);\n\n      // Simulate upload progress with more realistic behavior using safe interval helper\n      let progress = 0;\n      const uploadProgressInterval = setSafeInterval(() => {\n        // Realistic upload progress simulation\n        // First 80% is linear, last 20% is slower to simulate server processing\n        if (progress < 80) {\n          progress += Math.random() * 5; // Random increment for realism\n        } else if (progress < 95) {\n          progress += Math.random() * 0.5; // Slower near the end\n        } else if (progress < 99) {\n          progress += 0.1; // Very slow for the last bit\n        }\n        if (progress >= 100) {\n          // Find and remove from tracked intervals\n          const index = intervalIdsRef.current.indexOf(uploadProgressInterval);\n          if (index !== -1) {\n            intervalIdsRef.current.splice(index, 1);\n          }\n          clearInterval(uploadProgressInterval);\n          progress = 100;\n        }\n        setUploadProgress(Math.min(Math.floor(progress), 100));\n      }, 200);\n\n      // Simulate API response with file validation and upload behavior\n      const response = await new Promise(resolve => {\n        // Calculate simulated upload time based on file size for realism\n        // Larger files take longer to upload\n        const baseUploadTime = 1000; // Minimum 1 second\n        const sizeBasedTime = Math.min(file.size / 10000, 5000); // Up to 5 seconds more for large files\n\n        // Use safe timeout helper to prevent memory leaks\n        setSafeTimeout(() => {\n          // Find and remove from tracked intervals\n          const index = intervalIdsRef.current.indexOf(uploadProgressInterval);\n          if (index !== -1) {\n            intervalIdsRef.current.splice(index, 1);\n          }\n          clearInterval(uploadProgressInterval);\n          setUploadProgress(100);\n\n          // In a real implementation, we would check for errors\n          // like size limits, permission issues, etc.\n          resolve({\n            status: 'success',\n            object: {\n              key: fullKey,\n              size: file.size,\n              lastModified: new Date().toISOString(),\n              contentType: file.type || 'application/octet-stream',\n              type: 'file'\n            }\n          });\n        }, baseUploadTime + sizeBasedTime);\n      });\n      if (response.status === 'success') {\n        // Add new file to list if we're in the current prefix\n        setObjects(prevObjects => [...prevObjects, response.object]);\n        return true;\n      } else {\n        setError(response.message || `Failed to upload file: ${file.name}`);\n        return false;\n      }\n    } catch (err) {\n      console.error(`Error uploading file ${file.name}:`, err);\n      setError(err.message || `An error occurred while uploading file: ${file.name}`);\n      return false;\n    }\n  }, [currentPrefix, selectedBucket]);\n\n  /**\n   * Upload files (single file or batch upload)\n   */\n  const uploadFile = useCallback(async () => {\n    if (!selectedBucket) return;\n    setLoading(true);\n    setError(null);\n    try {\n      if (filesToUpload.length > 0) {\n        // Batch upload workflow\n        let successCount = 0;\n\n        // Process each file in sequence\n        for (let i = 0; i < filesToUpload.length; i++) {\n          setCurrentUploadIndex(i);\n          setSelectedFile(filesToUpload[i]); // Update preview to current file\n          setUploadProgress(0);\n          const success = await uploadSingleFile(filesToUpload[i]);\n          if (success) {\n            successCount++;\n          }\n\n          // Short pause between files\n          if (i < filesToUpload.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 500));\n          }\n        }\n\n        // Show completion message\n        console.log(`Uploaded ${successCount} of ${filesToUpload.length} files successfully`);\n\n        // Close dialog after batch upload\n        if (successCount > 0) {\n          setTimeout(() => {\n            setFileUploadDialogOpen(false);\n            setSelectedFile(null);\n            setFilesToUpload([]);\n            setUploadProgress(0);\n          }, 1500);\n        }\n      } else if (selectedFile) {\n        // Single file upload workflow\n        const success = await uploadSingleFile(selectedFile);\n\n        // Close dialog after successful upload\n        if (success) {\n          setTimeout(() => {\n            setFileUploadDialogOpen(false);\n            setSelectedFile(null);\n            setUploadProgress(0);\n          }, 1500);\n        }\n      }\n    } catch (err) {\n      console.error('Error in upload process:', err);\n      setError(err.message || 'An unexpected error occurred during upload');\n    } finally {\n      setLoading(false);\n    }\n  }, [selectedBucket, selectedFile, filesToUpload, uploadSingleFile]);\n\n  /**\n   * Download an object\n   */\n  const downloadObject = useCallback(item => {\n    if (!item || !selectedBucket) return;\n    console.log(`Downloading object: ${item.key} from bucket: ${selectedBucket}`);\n\n    // In a real implementation, this would create a download link\n    // For now, we'll just simulate it\n    alert(`Simulated download of file: ${item.key}`);\n  }, [selectedBucket]);\n\n  /**\n   * View/preview an object\n   */\n  const viewObject = useCallback(item => {\n    if (!item || !selectedBucket) return;\n    console.log(`Viewing object: ${item.key} from bucket: ${selectedBucket}`);\n\n    // In a real implementation, this would create a URL for the object content\n    // For now, we'll use a placeholder\n    setFileViewUrl(`https://example.com/preview/${selectedBucket}/${item.key}`);\n\n    // Set the file type based on contentType\n    const contentType = item.contentType || '';\n    setFileViewType(contentType);\n\n    // Set selected item for additional metadata in preview\n    setSelectedItem(item);\n\n    // Open the viewer\n    setFileViewerOpen(true);\n  }, [selectedBucket]);\n\n  /**\n   * Handle context menu opening\n   */\n  const handleContextMenu = useCallback((event, item) => {\n    event.preventDefault();\n\n    // Skip if in read-only mode\n    if (readOnly) return;\n    setContextMenuPos({\n      x: event.clientX,\n      y: event.clientY\n    });\n    setSelectedItem(item);\n  }, [readOnly]);\n\n  /**\n   * Handle context menu closing\n   */\n  const handleContextMenuClose = useCallback(() => {\n    setContextMenuPos(null);\n    setSelectedItem(null);\n  }, []);\n\n  // Load buckets on mount\n  useEffect(() => {\n    if (config) {\n      loadBuckets();\n    }\n  }, [config, loadBuckets]);\n\n  // File content render functions with enhanced preview\n  const renderFilePreview = (url, contentType) => {\n    // Import FilePreview component for advanced file previewing\n    const FilePreview = require(\"../../common/FilePreview\").default;\n\n    // Generate a mock file object with the selected item's data\n    const fileObj = selectedItem ? {\n      name: getDisplayName(selectedItem.key, selectedItem.type),\n      type: contentType,\n      size: selectedItem.size || 0,\n      lastModified: selectedItem.lastModified\n    } : null;\n\n    // Generate simulated content for text files\n    const generateSimulatedContent = () => {\n      if (contentType === 'text/plain') {\n        return `This is a simulated preview of a plain text file.\\n\\nFilename: ${selectedItem.key}\\nSize: ${formatFileSize(selectedItem.size || 0)}\\nLast Modified: ${formatDate(selectedItem.lastModified)}\\n\\nIn a production environment, this would fetch the actual file content from the S3 bucket.`;\n      }\n      if (contentType === 'text/csv') {\n        return `id,name,email,department\\n1,\"John Smith\",john.smith@example.com,Marketing\\n2,\"Jane Doe\",jane.doe@example.com,Engineering\\n3,\"Robert Johnson\",robert.johnson@example.com,Finance\\n4,\"Sarah Williams\",sarah.williams@example.com,Human Resources\\n5,\"Michael Brown\",michael.brown@example.com,Sales`;\n      }\n      if (contentType === 'application/json') {\n        return JSON.stringify({\n          \"id\": 12345,\n          \"name\": \"Sample JSON Data\",\n          \"items\": [{\n            \"id\": 1,\n            \"value\": \"First item\"\n          }, {\n            \"id\": 2,\n            \"value\": \"Second item\"\n          }, {\n            \"id\": 3,\n            \"value\": \"Third item\"\n          }],\n          \"metadata\": {\n            \"created\": new Date().toISOString(),\n            \"version\": \"1.0.0\",\n            \"source\": \"S3 Object\"\n          }\n        }, null, 2);\n      }\n      if (contentType === 'application/xml' || contentType === 'text/xml') {\n        return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<root>\\n  <item id=\"1\">\\n    <n>First Item</n>\\n    <value>100</value>\\n  </item>\\n  <item id=\"2\">\\n    <n>Second Item</n>\\n    <value>200</value>\\n  </item>\\n  <metadata>\\n    <created>${new Date().toISOString()}</created>\\n    <source>S3 Object</source>\\n  </metadata>\\n</root>`;\n      }\n\n      // Default text content\n      return `This is a simulated preview of content type: ${contentType}\\n\\nIn a production environment, this would display the actual file content.`;\n    };\n\n    // Generate content for text-based files\n    const content = contentType === 'text/plain' || contentType === 'text/csv' || contentType === 'application/json' || contentType === 'application/xml' || contentType === 'text/xml' ? generateSimulatedContent() : null;\n    return /*#__PURE__*/_jsx(FilePreview, {\n      file: fileObj,\n      url: url,\n      content: content,\n      mimeType: contentType,\n      filename: fileObj === null || fileObj === void 0 ? void 0 : fileObj.name,\n      onDownload: () => downloadObject(selectedItem),\n      maxHeight: \"600px\",\n      fullWidth: true\n    });\n  };\n\n  // Get color for file icon based on content type\n  const getIconColorForFileType = contentType => {\n    if (contentType.startsWith('image/')) {\n      return 'success.main'; // Green for images\n    } else if (contentType.startsWith('text/')) {\n      return 'info.main'; // Blue for text files\n    } else if (contentType.includes('spreadsheet') || contentType.includes('excel')) {\n      return 'success.dark'; // Dark green for spreadsheets\n    } else if (contentType.includes('pdf')) {\n      return 'error.main'; // Red for PDFs\n    } else if (contentType.includes('zip') || contentType.includes('compressed')) {\n      return 'warning.dark'; // Dark yellow for archives\n    } else if (contentType.includes('json') || contentType.includes('xml')) {\n      return 'secondary.main'; // Purple for data files\n    } else {\n      return 'info.main'; // Default blue\n    }\n  };\n\n  // Item name display function (truncates long paths)\n  const getDisplayName = (key, type) => {\n    if (type === 'bucket') {\n      return key;\n    } else if (type === 'folder') {\n      // For folders, extract the last folder name\n      const parts = key.split('/');\n      return parts[parts.length - 2] || key; // Account for trailing slash\n    } else {\n      // For files, extract filename from potentially nested path\n      const parts = key.split('/');\n      return parts[parts.length - 1] || key;\n    }\n  };\n  return /*#__PURE__*/_jsxs(Box, {\n    sx: {\n      display: 'flex',\n      flexDirection: 'column',\n      height: '100%'\n    },\n    children: [/*#__PURE__*/_jsxs(Box, {\n      sx: {\n        display: 'flex',\n        alignItems: 'center',\n        mb: 2\n      },\n      children: [/*#__PURE__*/_jsx(Box, {\n        sx: {\n          display: 'flex',\n          alignItems: 'center',\n          flexGrow: 1,\n          overflow: 'hidden'\n        },\n        children: /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            display: 'flex',\n            alignItems: 'center',\n            flexWrap: 'nowrap',\n            overflow: 'hidden'\n          },\n          children: [/*#__PURE__*/_jsx(Typography, {\n            variant: \"h6\",\n            sx: {\n              flexShrink: 0,\n              whiteSpace: 'nowrap'\n            },\n            children: selectedBucket ? /*#__PURE__*/_jsxs(_Fragment, {\n              children: [/*#__PURE__*/_jsx(Tooltip, {\n                title: \"Back to buckets\",\n                children: /*#__PURE__*/_jsx(Box, {\n                  component: \"span\",\n                  onClick: () => onSelectBucket(''),\n                  sx: {\n                    cursor: 'pointer',\n                    color: 'primary.main',\n                    '&:hover': {\n                      textDecoration: 'underline'\n                    }\n                  },\n                  children: \"Buckets\"\n                })\n              }), ' / ', /*#__PURE__*/_jsx(Tooltip, {\n                title: `Bucket: ${selectedBucket}`,\n                children: /*#__PURE__*/_jsx(\"strong\", {\n                  children: selectedBucket\n                })\n              })]\n            }) : 'AWS S3 Buckets'\n          }), selectedBucket && currentPrefix && /*#__PURE__*/_jsx(Box, {\n            sx: {\n              display: 'flex',\n              alignItems: 'center',\n              ml: 1,\n              overflow: 'hidden',\n              flexWrap: 'nowrap'\n            },\n            children: /*#__PURE__*/_jsxs(Typography, {\n              component: \"span\",\n              variant: \"body2\",\n              sx: {\n                display: 'flex',\n                alignItems: 'center',\n                color: 'text.secondary',\n                overflow: 'hidden',\n                textOverflow: 'ellipsis',\n                whiteSpace: 'nowrap'\n              },\n              children: [' / ', currentPrefix.split('/').filter(Boolean).map((segment, index, array) => {\n                // Create a path up to this segment\n                const pathUpToSegment = array.slice(0, index + 1).join('/') + '/';\n                return /*#__PURE__*/_jsxs(React.Fragment, {\n                  children: [index > 0 && ' / ', /*#__PURE__*/_jsx(Tooltip, {\n                    title: `Navigate to ${segment}`,\n                    children: /*#__PURE__*/_jsx(Box, {\n                      component: \"span\",\n                      onClick: () => loadObjects(selectedBucket, pathUpToSegment),\n                      sx: {\n                        cursor: 'pointer',\n                        color: 'primary.main',\n                        flexShrink: 0,\n                        '&:hover': {\n                          textDecoration: 'underline'\n                        }\n                      },\n                      children: segment\n                    })\n                  })]\n                }, index);\n              })]\n            })\n          })]\n        })\n      }), /*#__PURE__*/_jsxs(Box, {\n        sx: {\n          display: 'flex',\n          alignItems: 'center',\n          ml: 2\n        },\n        children: [selectedBucket && /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Go up\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            onClick: navigateUp,\n            disabled: loading,\n            size: \"small\",\n            children: /*#__PURE__*/_jsx(UpIcon, {})\n          })\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Refresh\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            onClick: () => selectedBucket ? loadObjects(selectedBucket, currentPrefix) : loadBuckets(),\n            disabled: loading,\n            size: \"small\",\n            children: /*#__PURE__*/_jsx(RefreshIcon, {})\n          })\n        }), !readOnly && /*#__PURE__*/_jsxs(_Fragment, {\n          children: [selectedBucket ? /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Upload File\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: () => setFileUploadDialogOpen(true),\n              disabled: loading,\n              size: \"small\",\n              color: \"primary\",\n              children: /*#__PURE__*/_jsx(UploadIcon, {})\n            })\n          }) : /*#__PURE__*/_jsx(Tooltip, {\n            title: \"New Bucket\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: () => setNewBucketDialogOpen(true),\n              disabled: loading || bucketLoading,\n              size: \"small\",\n              color: \"primary\",\n              children: /*#__PURE__*/_jsx(AddIcon, {})\n            })\n          }), selectedBucket && /*#__PURE__*/_jsx(Tooltip, {\n            title: \"New Folder\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: () => setNewFolderDialogOpen(true),\n              disabled: loading,\n              size: \"small\",\n              color: \"primary\",\n              children: /*#__PURE__*/_jsx(CreateFolderIcon, {})\n            })\n          })]\n        })]\n      })]\n    }), selectedBucket && /*#__PURE__*/_jsxs(Box, {\n      sx: {\n        mb: 2\n      },\n      children: [/*#__PURE__*/_jsxs(Box, {\n        sx: {\n          display: 'flex',\n          alignItems: 'center',\n          mb: 1\n        },\n        children: [/*#__PURE__*/_jsx(TextField, {\n          fullWidth: true,\n          placeholder: \"Search objects...\",\n          value: searchTerm,\n          onChange: e => setSearchTerm(e.target.value),\n          disabled: loading,\n          size: \"small\",\n          InputProps: {\n            startAdornment: /*#__PURE__*/_jsx(InputAdornment, {\n              position: \"start\",\n              children: /*#__PURE__*/_jsx(SearchIcon, {})\n            }),\n            endAdornment: isSearching && !activeFilters.fileTypes.length && /*#__PURE__*/_jsx(InputAdornment, {\n              position: \"end\",\n              children: /*#__PURE__*/_jsx(Button, {\n                size: \"small\",\n                onClick: clearSearch,\n                disabled: loading,\n                children: \"Clear\"\n              })\n            })\n          },\n          onKeyPress: e => {\n            if (e.key === 'Enter' && searchTerm) {\n              searchObjects();\n            }\n          }\n        }), /*#__PURE__*/_jsx(Button, {\n          variant: \"contained\",\n          onClick: searchObjects,\n          disabled: loading || !searchTerm,\n          sx: {\n            ml: 1\n          },\n          children: \"Search\"\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Advanced Filters\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            color: activeFilters.fileTypes.length > 0 ? \"primary\" : \"default\",\n            onClick: () => {\n              setFilterTabValue(0);\n              setFilterDialogOpen(true);\n            },\n            sx: {\n              ml: 1\n            },\n            children: /*#__PURE__*/_jsx(FilterAltIcon, {})\n          })\n        }), !readOnly && /*#__PURE__*/_jsx(Tooltip, {\n          title: selectionMode ? \"Exit Selection Mode\" : \"Selection Mode\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            color: selectionMode ? \"primary\" : \"default\",\n            onClick: toggleSelectionMode,\n            sx: {\n              ml: 1\n            },\n            children: /*#__PURE__*/_jsx(SelectAllIcon, {})\n          })\n        })]\n      }), (activeFilters.fileTypes.length > 0 || activeFilters.dateRange.start || activeFilters.sizeRange[0] > 0 || activeFilters.sizeRange[1] < Number.MAX_SAFE_INTEGER || activeFilters.customPrefix) && /*#__PURE__*/_jsxs(Box, {\n        sx: {\n          display: 'flex',\n          alignItems: 'center',\n          flexWrap: 'wrap',\n          gap: 1,\n          mb: 1\n        },\n        children: [/*#__PURE__*/_jsx(Typography, {\n          variant: \"body2\",\n          color: \"text.secondary\",\n          children: \"Filters:\"\n        }), activeFilters.fileTypes.map(fileType => {\n          var _FILE_TYPE_OPTIONS$fi;\n          return /*#__PURE__*/_jsx(Chip, {\n            label: `Type: ${((_FILE_TYPE_OPTIONS$fi = FILE_TYPE_OPTIONS.find(opt => opt.value === fileType)) === null || _FILE_TYPE_OPTIONS$fi === void 0 ? void 0 : _FILE_TYPE_OPTIONS$fi.label) || fileType}`,\n            size: \"small\",\n            onDelete: () => {\n              setActiveFilters(prev => ({\n                ...prev,\n                fileTypes: prev.fileTypes.filter(t => t !== fileType)\n              }));\n              // Re-apply filters\n              setTimeout(applyAdvancedFilters, 0);\n            }\n          }, fileType);\n        }), activeFilters.sizeRange[0] > 0 && /*#__PURE__*/_jsx(Chip, {\n          label: `Min size: ${formatFileSize(activeFilters.sizeRange[0])}`,\n          size: \"small\",\n          onDelete: () => {\n            setActiveFilters(prev => ({\n              ...prev,\n              sizeRange: [0, prev.sizeRange[1]]\n            }));\n            // Re-apply filters\n            setTimeout(applyAdvancedFilters, 0);\n          }\n        }), activeFilters.sizeRange[1] < Number.MAX_SAFE_INTEGER && /*#__PURE__*/_jsx(Chip, {\n          label: `Max size: ${formatFileSize(activeFilters.sizeRange[1])}`,\n          size: \"small\",\n          onDelete: () => {\n            setActiveFilters(prev => ({\n              ...prev,\n              sizeRange: [prev.sizeRange[0], Number.MAX_SAFE_INTEGER]\n            }));\n            // Re-apply filters\n            setTimeout(applyAdvancedFilters, 0);\n          }\n        }), activeFilters.dateRange.start && activeFilters.dateRange.end && /*#__PURE__*/_jsx(Chip, {\n          label: `Date: ${formatDate(activeFilters.dateRange.start)} - ${formatDate(activeFilters.dateRange.end)}`,\n          size: \"small\",\n          onDelete: () => {\n            setActiveFilters(prev => ({\n              ...prev,\n              dateRange: {\n                start: null,\n                end: null\n              }\n            }));\n            // Re-apply filters\n            setTimeout(applyAdvancedFilters, 0);\n          }\n        }), activeFilters.customPrefix && /*#__PURE__*/_jsx(Chip, {\n          label: `Prefix: ${activeFilters.customPrefix}`,\n          size: \"small\",\n          onDelete: () => {\n            setActiveFilters(prev => ({\n              ...prev,\n              customPrefix: ''\n            }));\n            // Re-apply filters\n            setTimeout(applyAdvancedFilters, 0);\n          }\n        }), /*#__PURE__*/_jsx(Button, {\n          size: \"small\",\n          variant: \"outlined\",\n          startIcon: /*#__PURE__*/_jsx(ClearIcon, {\n            fontSize: \"small\"\n          }),\n          onClick: clearFilters,\n          children: \"Clear All\"\n        })]\n      }), selectionMode && selectedItems.length > 0 && /*#__PURE__*/_jsxs(Paper, {\n        variant: \"outlined\",\n        sx: {\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          p: 1,\n          mt: 1\n        },\n        children: [/*#__PURE__*/_jsxs(Box, {\n          sx: {\n            display: 'flex',\n            alignItems: 'center'\n          },\n          children: [/*#__PURE__*/_jsxs(Typography, {\n            variant: \"body2\",\n            fontWeight: \"bold\",\n            color: \"primary.main\",\n            children: [selectedItems.length, \" item\", selectedItems.length !== 1 ? 's' : '', \" selected\"]\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Clear selection\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => setSelectedItems([]),\n              sx: {\n                ml: 1\n              },\n              children: /*#__PURE__*/_jsx(ClearIcon, {\n                fontSize: \"small\"\n              })\n            })\n          })]\n        }), /*#__PURE__*/_jsxs(Box, {\n          children: [/*#__PURE__*/_jsx(Tooltip, {\n            title: \"Download Selected\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => {\n                setBatchAction('download');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(DownloadIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Delete Selected\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              color: \"error\",\n              onClick: () => {\n                setBatchAction('delete');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(DeleteIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Copy Selected\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => {\n                setBatchAction('copy');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(CopyIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Move Selected\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => {\n                setBatchAction('move');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(MoveIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Make Public\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => {\n                setBatchAction('makePublic');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(PublicIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Tooltip, {\n            title: \"Make Private\",\n            children: /*#__PURE__*/_jsx(IconButton, {\n              size: \"small\",\n              onClick: () => {\n                setBatchAction('makePrivate');\n                setBatchActionDialogOpen(true);\n              },\n              children: /*#__PURE__*/_jsx(LockIcon, {\n                fontSize: \"small\"\n              })\n            })\n          }), /*#__PURE__*/_jsx(Button, {\n            size: \"small\",\n            variant: \"outlined\",\n            color: \"primary\",\n            onClick: selectAllItems,\n            sx: {\n              ml: 1\n            },\n            children: selectedItems.length === (isSearching ? searchResults.length : objects.length) ? 'Deselect All' : 'Select All'\n          })]\n        })]\n      })]\n    }), error && /*#__PURE__*/_jsxs(Typography, {\n      color: \"error\",\n      sx: {\n        mb: 2\n      },\n      children: [\"Error: \", error]\n    }), bucketLoading || loading ? /*#__PURE__*/_jsx(Box, {\n      sx: {\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        py: 4\n      },\n      children: /*#__PURE__*/_jsx(CircularProgress, {})\n    }) : selectedBucket ?\n    /*#__PURE__*/\n    // Object list\n    _jsx(TableContainer, {\n      component: Paper,\n      sx: {\n        flexGrow: 1,\n        overflow: 'auto'\n      },\n      children: /*#__PURE__*/_jsxs(Table, {\n        size: \"small\",\n        children: [/*#__PURE__*/_jsx(TableHead, {\n          children: /*#__PURE__*/_jsxs(TableRow, {\n            children: [selectionMode && /*#__PURE__*/_jsx(TableCell, {\n              padding: \"checkbox\",\n              width: \"50px\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              children: \"Name\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: \"Size\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: \"Last Modified\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: \"Actions\"\n            })]\n          })\n        }), /*#__PURE__*/_jsx(TableBody, {\n          children: (isSearching ? searchResults : objects).length === 0 ? /*#__PURE__*/_jsx(TableRow, {\n            children: /*#__PURE__*/_jsx(TableCell, {\n              colSpan: selectionMode ? 5 : 4,\n              align: \"center\",\n              children: isSearching ? 'No search results' : 'No objects in this location'\n            })\n          }) : (isSearching ? searchResults : objects).map(item => /*#__PURE__*/_jsxs(TableRow, {\n            hover: true,\n            onClick: e => selectionMode ? toggleItemSelection(e, item) : navigateTo(item),\n            sx: {\n              cursor: 'pointer',\n              '&:hover': {\n                backgroundColor: 'action.hover'\n              },\n              ...(selectionMode && isItemSelected(item) ? {\n                backgroundColor: 'action.selected',\n                '&:hover': {\n                  backgroundColor: 'action.selectedHover'\n                }\n              } : {})\n            },\n            onContextMenu: e => handleContextMenu(e, item),\n            children: [selectionMode && /*#__PURE__*/_jsx(TableCell, {\n              padding: \"checkbox\",\n              children: /*#__PURE__*/_jsx(Checkbox, {\n                checked: isItemSelected(item),\n                onChange: e => toggleItemSelection(e, item),\n                onClick: e => e.stopPropagation(),\n                color: \"primary\",\n                size: \"small\"\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              children: /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  display: 'flex',\n                  alignItems: 'center'\n                },\n                children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                  sx: {\n                    minWidth: 36\n                  },\n                  children: item.type === 'folder' ? /*#__PURE__*/_jsx(FolderIcon, {\n                    color: \"primary\"\n                  }) : /*#__PURE__*/_jsx(FileIcon, {\n                    sx: {\n                      color: getIconColorForFileType(item.contentType || '')\n                    }\n                  })\n                }), /*#__PURE__*/_jsxs(Box, {\n                  children: [/*#__PURE__*/_jsx(Typography, {\n                    variant: \"body2\",\n                    sx: {\n                      fontWeight: 500\n                    },\n                    children: getDisplayName(item.key, item.type)\n                  }), item.type === 'file' && item.contentType && /*#__PURE__*/_jsx(Typography, {\n                    variant: \"caption\",\n                    color: \"text.secondary\",\n                    children: item.contentType\n                  })]\n                })]\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: item.type === 'folder' ? '-' : /*#__PURE__*/_jsx(Typography, {\n                variant: \"body2\",\n                sx: {\n                  fontFamily: 'monospace',\n                  fontWeight: 500,\n                  color: 'text.secondary'\n                },\n                children: formatFileSize(item.size || 0)\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: /*#__PURE__*/_jsx(Typography, {\n                variant: \"body2\",\n                color: \"text.secondary\",\n                children: formatDate(item.lastModified)\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  display: 'flex',\n                  justifyContent: 'flex-end',\n                  alignItems: 'center'\n                },\n                children: [item.type === 'file' && /*#__PURE__*/_jsxs(_Fragment, {\n                  children: [/*#__PURE__*/_jsx(Tooltip, {\n                    title: \"View\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      size: \"small\",\n                      onClick: e => {\n                        e.stopPropagation();\n                        viewObject(item);\n                      },\n                      children: /*#__PURE__*/_jsx(ViewIcon, {\n                        fontSize: \"small\"\n                      })\n                    })\n                  }), /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"Download\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      size: \"small\",\n                      onClick: e => {\n                        e.stopPropagation();\n                        downloadObject(item);\n                      },\n                      children: /*#__PURE__*/_jsx(DownloadIcon, {\n                        fontSize: \"small\"\n                      })\n                    })\n                  }), /*#__PURE__*/_jsx(Tooltip, {\n                    title: \"Select this file\",\n                    children: /*#__PURE__*/_jsx(IconButton, {\n                      size: \"small\",\n                      color: \"primary\",\n                      onClick: e => {\n                        e.stopPropagation();\n                        onSelectObject({\n                          bucketName: selectedBucket,\n                          prefix: currentPrefix,\n                          key: item.key,\n                          size: item.size,\n                          lastModified: item.lastModified,\n                          contentType: item.contentType\n                        });\n                      },\n                      children: /*#__PURE__*/_jsx(CheckCircleIcon, {\n                        fontSize: \"small\"\n                      })\n                    })\n                  })]\n                }), !readOnly && /*#__PURE__*/_jsx(Tooltip, {\n                  title: \"More actions\",\n                  children: /*#__PURE__*/_jsx(IconButton, {\n                    size: \"small\",\n                    onClick: e => {\n                      e.stopPropagation();\n                      handleContextMenu(e, item);\n                    },\n                    children: /*#__PURE__*/_jsx(MoreVertIcon, {\n                      fontSize: \"small\"\n                    })\n                  })\n                })]\n              })\n            })]\n          }, item.key))\n        })]\n      })\n    }) :\n    /*#__PURE__*/\n    // Bucket list\n    _jsx(TableContainer, {\n      component: Paper,\n      sx: {\n        flexGrow: 1,\n        overflow: 'auto'\n      },\n      children: /*#__PURE__*/_jsxs(Table, {\n        size: \"small\",\n        children: [/*#__PURE__*/_jsx(TableHead, {\n          children: /*#__PURE__*/_jsxs(TableRow, {\n            children: [selectionMode && /*#__PURE__*/_jsx(TableCell, {\n              padding: \"checkbox\",\n              width: \"50px\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              children: \"Bucket Name\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: \"Creation Date\"\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: \"Actions\"\n            })]\n          })\n        }), /*#__PURE__*/_jsx(TableBody, {\n          children: buckets.length === 0 ? /*#__PURE__*/_jsx(TableRow, {\n            children: /*#__PURE__*/_jsx(TableCell, {\n              colSpan: selectionMode ? 4 : 3,\n              align: \"center\",\n              children: \"No buckets found\"\n            })\n          }) : buckets.map(bucket => /*#__PURE__*/_jsxs(TableRow, {\n            hover: true,\n            onClick: e => selectionMode ? toggleItemSelection(e, {\n              ...bucket,\n              type: 'bucket'\n            }) : loadObjects(bucket.name, ''),\n            sx: {\n              cursor: 'pointer',\n              '&:hover': {\n                backgroundColor: 'action.hover'\n              },\n              ...(selectionMode && isItemSelected({\n                ...bucket,\n                type: 'bucket'\n              }) ? {\n                backgroundColor: 'action.selected',\n                '&:hover': {\n                  backgroundColor: 'action.selectedHover'\n                }\n              } : {})\n            },\n            onContextMenu: e => handleContextMenu(e, {\n              ...bucket,\n              type: 'bucket'\n            }),\n            children: [selectionMode && /*#__PURE__*/_jsx(TableCell, {\n              padding: \"checkbox\",\n              children: /*#__PURE__*/_jsx(Checkbox, {\n                checked: isItemSelected({\n                  ...bucket,\n                  type: 'bucket'\n                }),\n                onChange: e => toggleItemSelection(e, {\n                  ...bucket,\n                  type: 'bucket'\n                }),\n                onClick: e => e.stopPropagation(),\n                color: \"primary\",\n                size: \"small\"\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              children: /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  display: 'flex',\n                  alignItems: 'center'\n                },\n                children: [/*#__PURE__*/_jsx(ListItemIcon, {\n                  sx: {\n                    minWidth: 36\n                  },\n                  children: /*#__PURE__*/_jsx(BucketIcon, {\n                    color: \"primary\"\n                  })\n                }), /*#__PURE__*/_jsx(Typography, {\n                  variant: \"body2\",\n                  sx: {\n                    fontWeight: 500\n                  },\n                  children: bucket.name\n                })]\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: /*#__PURE__*/_jsx(Typography, {\n                variant: \"body2\",\n                color: \"text.secondary\",\n                children: formatDate(bucket.creationDate)\n              })\n            }), /*#__PURE__*/_jsx(TableCell, {\n              align: \"right\",\n              children: /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  display: 'flex',\n                  justifyContent: 'flex-end',\n                  alignItems: 'center'\n                },\n                children: [/*#__PURE__*/_jsx(Tooltip, {\n                  title: \"Browse bucket\",\n                  children: /*#__PURE__*/_jsx(IconButton, {\n                    size: \"small\",\n                    color: \"primary\",\n                    onClick: e => {\n                      e.stopPropagation();\n                      loadObjects(bucket.name, '');\n                    },\n                    children: /*#__PURE__*/_jsx(FolderOpenIcon, {\n                      fontSize: \"small\"\n                    })\n                  })\n                }), /*#__PURE__*/_jsx(Tooltip, {\n                  title: \"Select bucket\",\n                  children: /*#__PURE__*/_jsx(IconButton, {\n                    size: \"small\",\n                    color: \"primary\",\n                    onClick: e => {\n                      e.stopPropagation();\n                      onSelectBucket(bucket.name);\n                    },\n                    children: /*#__PURE__*/_jsx(CheckCircleIcon, {\n                      fontSize: \"small\"\n                    })\n                  })\n                }), !readOnly && /*#__PURE__*/_jsx(Tooltip, {\n                  title: \"More actions\",\n                  children: /*#__PURE__*/_jsx(IconButton, {\n                    size: \"small\",\n                    onClick: e => {\n                      e.stopPropagation();\n                      handleContextMenu(e, {\n                        ...bucket,\n                        type: 'bucket'\n                      });\n                    },\n                    children: /*#__PURE__*/_jsx(MoreVertIcon, {\n                      fontSize: \"small\"\n                    })\n                  })\n                })]\n              })\n            })]\n          }, bucket.name))\n        })]\n      })\n    }), /*#__PURE__*/_jsxs(Menu, {\n      open: Boolean(contextMenuPos),\n      onClose: handleContextMenuClose,\n      anchorReference: \"anchorPosition\",\n      anchorPosition: contextMenuPos ? {\n        top: contextMenuPos.y,\n        left: contextMenuPos.x\n      } : undefined,\n      children: [selectedItem && selectedItem.type === 'bucket' && /*#__PURE__*/_jsxs(\"div\", {\n        children: [/*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            loadObjects(selectedItem.name, '');\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(FolderOpenIcon, {\n              fontSize: \"small\",\n              color: \"primary\"\n            })\n          }), \"Browse bucket\"]\n        }), /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            onSelectBucket(selectedItem.name);\n            handleContextMenuClose();\n          },\n          divider: true,\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(CheckCircleIcon, {\n              fontSize: \"small\",\n              color: \"primary\"\n            })\n          }), \"Select bucket\"]\n        }), !readOnly && /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            setItemToDelete(selectedItem);\n            setConfirmDeleteDialogOpen(true);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(DeleteIcon, {\n              fontSize: \"small\",\n              color: \"error\"\n            })\n          }), \"Delete bucket\"]\n        })]\n      }), selectedItem && selectedItem.type === 'folder' && /*#__PURE__*/_jsxs(\"div\", {\n        children: [/*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            navigateTo(selectedItem);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(FolderOpenIcon, {\n              fontSize: \"small\",\n              color: \"primary\"\n            })\n          }), \"Open folder\"]\n        }), !readOnly && /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            setItemToDelete(selectedItem);\n            setConfirmDeleteDialogOpen(true);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(DeleteIcon, {\n              fontSize: \"small\",\n              color: \"error\"\n            })\n          }), \"Delete folder\"]\n        })]\n      }), selectedItem && selectedItem.type === 'file' && /*#__PURE__*/_jsxs(\"div\", {\n        children: [/*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            viewObject(selectedItem);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(ViewIcon, {\n              fontSize: \"small\"\n            })\n          }), \"View\"]\n        }), /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            downloadObject(selectedItem);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(DownloadIcon, {\n              fontSize: \"small\"\n            })\n          }), \"Download\"]\n        }), /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            onSelectObject({\n              bucketName: selectedBucket,\n              prefix: currentPrefix,\n              key: selectedItem.key,\n              size: selectedItem.size,\n              lastModified: selectedItem.lastModified,\n              contentType: selectedItem.contentType\n            });\n            handleContextMenuClose();\n          },\n          divider: true,\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(CheckCircleIcon, {\n              fontSize: \"small\",\n              color: \"primary\"\n            })\n          }), \"Select this file\"]\n        }), !readOnly && /*#__PURE__*/_jsxs(MenuItem, {\n          onClick: () => {\n            setItemToDelete(selectedItem);\n            setConfirmDeleteDialogOpen(true);\n            handleContextMenuClose();\n          },\n          children: [/*#__PURE__*/_jsx(ListItemIcon, {\n            children: /*#__PURE__*/_jsx(DeleteIcon, {\n              fontSize: \"small\",\n              color: \"error\"\n            })\n          }), \"Delete\"]\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: filterDialogOpen,\n      onClose: () => setFilterDialogOpen(false),\n      maxWidth: \"md\",\n      fullWidth: true,\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: /*#__PURE__*/_jsxs(Box, {\n          display: \"flex\",\n          alignItems: \"center\",\n          children: [/*#__PURE__*/_jsx(FilterAltIcon, {\n            sx: {\n              mr: 1\n            }\n          }), /*#__PURE__*/_jsx(Typography, {\n            variant: \"h6\",\n            children: \"Advanced Filtering\"\n          })]\n        })\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        dividers: true,\n        children: [/*#__PURE__*/_jsxs(Tabs, {\n          value: filterTabValue,\n          onChange: (e, newValue) => setFilterTabValue(newValue),\n          sx: {\n            borderBottom: 1,\n            borderColor: 'divider',\n            mb: 2\n          },\n          children: [/*#__PURE__*/_jsx(Tab, {\n            label: \"File Types\"\n          }), /*#__PURE__*/_jsx(Tab, {\n            label: \"Size\"\n          }), /*#__PURE__*/_jsx(Tab, {\n            label: \"Date\"\n          }), /*#__PURE__*/_jsx(Tab, {\n            label: \"Prefix\"\n          })]\n        }), /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            p: 1,\n            display: filterTabValue === 0 ? 'block' : 'none'\n          },\n          children: [/*#__PURE__*/_jsx(Typography, {\n            variant: \"subtitle1\",\n            gutterBottom: true,\n            children: \"Filter by File Type\"\n          }), /*#__PURE__*/_jsx(Typography, {\n            variant: \"body2\",\n            color: \"text.secondary\",\n            paragraph: true,\n            children: \"Select file types to include in the results\"\n          }), /*#__PURE__*/_jsx(FormGroup, {\n            children: /*#__PURE__*/_jsx(Grid, {\n              container: true,\n              spacing: 2,\n              children: FILE_TYPE_OPTIONS.map(option => /*#__PURE__*/_jsx(Grid, {\n                item: true,\n                xs: 12,\n                sm: 6,\n                md: 4,\n                children: /*#__PURE__*/_jsx(FormControlLabel, {\n                  control: /*#__PURE__*/_jsx(Checkbox, {\n                    checked: activeFilters.fileTypes.includes(option.value),\n                    onChange: e => {\n                      const newFileTypes = e.target.checked ? [...activeFilters.fileTypes, option.value] : activeFilters.fileTypes.filter(t => t !== option.value);\n                      setActiveFilters({\n                        ...activeFilters,\n                        fileTypes: newFileTypes\n                      });\n                    }\n                  }),\n                  label: /*#__PURE__*/_jsxs(Box, {\n                    children: [/*#__PURE__*/_jsx(Typography, {\n                      variant: \"body2\",\n                      children: option.label\n                    }), /*#__PURE__*/_jsx(Typography, {\n                      variant: \"caption\",\n                      color: \"text.secondary\",\n                      children: option.description\n                    })]\n                  })\n                })\n              }, option.value))\n            })\n          }), /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              mt: 4,\n              display: filterTabValue === 1 ? 'block' : 'none'\n            },\n            children: [/*#__PURE__*/_jsx(Typography, {\n              variant: \"subtitle1\",\n              gutterBottom: true,\n              children: \"Filter by Size\"\n            }), /*#__PURE__*/_jsx(Typography, {\n              variant: \"body2\",\n              color: \"text.secondary\",\n              paragraph: true,\n              children: \"Select a size range or use the slider\"\n            }), /*#__PURE__*/_jsxs(FormControl, {\n              fullWidth: true,\n              sx: {\n                mb: 2\n              },\n              children: [/*#__PURE__*/_jsx(InputLabel, {\n                children: \"Size Presets\"\n              }), /*#__PURE__*/_jsxs(Select, {\n                value: \"\",\n                onChange: e => {\n                  const preset = SIZE_PRESETS.find(p => p.label === e.target.value);\n                  if (preset) {\n                    setActiveFilters({\n                      ...activeFilters,\n                      sizeRange: preset.value\n                    });\n                  }\n                },\n                children: [/*#__PURE__*/_jsx(MenuItem, {\n                  value: \"\",\n                  children: \"Custom\"\n                }), SIZE_PRESETS.map(preset => /*#__PURE__*/_jsx(MenuItem, {\n                  value: preset.label,\n                  children: preset.label\n                }, preset.label))]\n              })]\n            }), /*#__PURE__*/_jsxs(Box, {\n              sx: {\n                px: 2\n              },\n              children: [/*#__PURE__*/_jsxs(Typography, {\n                id: \"size-slider\",\n                gutterBottom: true,\n                children: [\"Size Range: \", formatFileSize(activeFilters.sizeRange[0]), \" - \", formatFileSize(activeFilters.sizeRange[1])]\n              }), /*#__PURE__*/_jsx(Slider, {\n                value: activeFilters.sizeRange,\n                onChange: (e, newValue) => {\n                  setActiveFilters({\n                    ...activeFilters,\n                    sizeRange: newValue\n                  });\n                },\n                valueLabelDisplay: \"auto\",\n                valueLabelFormat: value => formatFileSize(value),\n                min: 0,\n                max: 1024 * 1024 * 1024 // 1 GB\n                ,\n                step: 1024,\n                marks: [{\n                  value: 0,\n                  label: '0'\n                }, {\n                  value: 1024 * 1024,\n                  label: '1 MB'\n                }, {\n                  value: 1024 * 1024 * 100,\n                  label: '100 MB'\n                }, {\n                  value: 1024 * 1024 * 1024,\n                  label: '1 GB'\n                }]\n              })]\n            })]\n          }), /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              mt: 4,\n              display: filterTabValue === 2 ? 'block' : 'none'\n            },\n            children: [/*#__PURE__*/_jsx(Typography, {\n              variant: \"subtitle1\",\n              gutterBottom: true,\n              children: \"Filter by Date\"\n            }), /*#__PURE__*/_jsx(Typography, {\n              variant: \"body2\",\n              color: \"text.secondary\",\n              paragraph: true,\n              children: \"Select a date range or choose a preset\"\n            }), /*#__PURE__*/_jsxs(FormControl, {\n              fullWidth: true,\n              sx: {\n                mb: 2\n              },\n              children: [/*#__PURE__*/_jsx(InputLabel, {\n                children: \"Date Presets\"\n              }), /*#__PURE__*/_jsxs(Select, {\n                value: \"\",\n                onChange: e => {\n                  const preset = DATE_PRESETS.find(p => p.label === e.target.value);\n                  if (preset && preset.value !== 'custom') {\n                    const end = new Date();\n                    const start = getDateDaysAgo(preset.value.days);\n                    setActiveFilters({\n                      ...activeFilters,\n                      dateRange: {\n                        start,\n                        end\n                      }\n                    });\n                  }\n                },\n                children: [/*#__PURE__*/_jsx(MenuItem, {\n                  value: \"\",\n                  children: \"Custom Range\"\n                }), DATE_PRESETS.map(preset => /*#__PURE__*/_jsx(MenuItem, {\n                  value: preset.label,\n                  children: preset.label\n                }, preset.label))]\n              })]\n            }), /*#__PURE__*/_jsxs(Grid, {\n              container: true,\n              spacing: 2,\n              children: [/*#__PURE__*/_jsx(Grid, {\n                item: true,\n                xs: 12,\n                sm: 6,\n                children: /*#__PURE__*/_jsx(LocalizationProvider, {\n                  dateAdapter: AdapterDateFns,\n                  children: /*#__PURE__*/_jsx(DatePicker, {\n                    label: \"Start Date\",\n                    value: activeFilters.dateRange.start,\n                    onChange: newValue => {\n                      setActiveFilters({\n                        ...activeFilters,\n                        dateRange: {\n                          ...activeFilters.dateRange,\n                          start: newValue\n                        }\n                      });\n                    },\n                    renderInput: params => /*#__PURE__*/_jsx(TextField, {\n                      ...params,\n                      fullWidth: true\n                    })\n                  })\n                })\n              }), /*#__PURE__*/_jsx(Grid, {\n                item: true,\n                xs: 12,\n                sm: 6,\n                children: /*#__PURE__*/_jsx(LocalizationProvider, {\n                  dateAdapter: AdapterDateFns,\n                  children: /*#__PURE__*/_jsx(DatePicker, {\n                    label: \"End Date\",\n                    value: activeFilters.dateRange.end,\n                    onChange: newValue => {\n                      setActiveFilters({\n                        ...activeFilters,\n                        dateRange: {\n                          ...activeFilters.dateRange,\n                          end: newValue\n                        }\n                      });\n                    },\n                    renderInput: params => /*#__PURE__*/_jsx(TextField, {\n                      ...params,\n                      fullWidth: true\n                    })\n                  })\n                })\n              })]\n            })]\n          }), /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              mt: 4,\n              display: filterTabValue === 3 ? 'block' : 'none'\n            },\n            children: [/*#__PURE__*/_jsx(Typography, {\n              variant: \"subtitle1\",\n              gutterBottom: true,\n              children: \"Filter by Prefix\"\n            }), /*#__PURE__*/_jsx(Typography, {\n              variant: \"body2\",\n              color: \"text.secondary\",\n              paragraph: true,\n              children: \"Enter a custom prefix to filter items\"\n            }), /*#__PURE__*/_jsx(TextField, {\n              fullWidth: true,\n              label: \"Custom Prefix\",\n              value: activeFilters.customPrefix,\n              onChange: e => {\n                setActiveFilters({\n                  ...activeFilters,\n                  customPrefix: e.target.value\n                });\n              },\n              placeholder: \"e.g. data/ or report-\",\n              helperText: \"Filter items by key prefix or substring\"\n            })]\n          })]\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          startIcon: /*#__PURE__*/_jsx(ClearIcon, {}),\n          onClick: () => {\n            setActiveFilters({\n              fileTypes: [],\n              sizeRange: [0, Number.MAX_SAFE_INTEGER],\n              dateRange: {\n                start: null,\n                end: null\n              },\n              modifiedBy: '',\n              customPrefix: ''\n            });\n          },\n          children: \"Clear All\"\n        }), /*#__PURE__*/_jsx(Button, {\n          onClick: () => setFilterDialogOpen(false),\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: () => {\n            setFilterDialogOpen(false);\n            // Apply filters function will be called when dialog is closed\n            // since we're already watching activeFilters in an effect\n          },\n          startIcon: /*#__PURE__*/_jsx(FilterAltIcon, {}),\n          children: \"Apply Filters\"\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: newBucketDialogOpen,\n      onClose: () => setNewBucketDialogOpen(false),\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: \"Create New Bucket\"\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        children: [/*#__PURE__*/_jsx(DialogContentText, {\n          children: \"Enter a name for the new bucket. Bucket names must be globally unique, lowercase letters, numbers, or hyphens.\"\n        }), /*#__PURE__*/_jsx(TextField, {\n          autoFocus: true,\n          margin: \"dense\",\n          id: \"bucket-name\",\n          label: \"Bucket Name\",\n          type: \"text\",\n          fullWidth: true,\n          value: newBucketName,\n          onChange: e => setNewBucketName(e.target.value),\n          error: Boolean(error),\n          helperText: error,\n          disabled: loading\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => setNewBucketDialogOpen(false),\n          disabled: loading,\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          onClick: createBucket,\n          color: \"primary\",\n          disabled: loading || !newBucketName,\n          children: loading ? /*#__PURE__*/_jsx(CircularProgress, {\n            size: 24\n          }) : 'Create'\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: batchActionDialogOpen,\n      onClose: () => setBatchActionDialogOpen(false),\n      children: [/*#__PURE__*/_jsxs(DialogTitle, {\n        children: [batchAction === 'delete' && 'Confirm Delete', batchAction === 'download' && 'Confirm Download', batchAction === 'copy' && 'Confirm Copy', batchAction === 'move' && 'Confirm Move', batchAction === 'makePublic' && 'Confirm Make Public', batchAction === 'makePrivate' && 'Confirm Make Private']\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        children: [/*#__PURE__*/_jsxs(Box, {\n          sx: {\n            display: 'flex',\n            alignItems: 'center',\n            mb: 2\n          },\n          children: [batchAction === 'delete' && /*#__PURE__*/_jsx(DeleteIcon, {\n            color: \"error\",\n            sx: {\n              mr: 1\n            }\n          }), batchAction === 'download' && /*#__PURE__*/_jsx(DownloadIcon, {\n            color: \"primary\",\n            sx: {\n              mr: 1\n            }\n          }), batchAction === 'copy' && /*#__PURE__*/_jsx(CopyIcon, {\n            color: \"primary\",\n            sx: {\n              mr: 1\n            }\n          }), batchAction === 'move' && /*#__PURE__*/_jsx(MoveIcon, {\n            color: \"primary\",\n            sx: {\n              mr: 1\n            }\n          }), batchAction === 'makePublic' && /*#__PURE__*/_jsx(PublicIcon, {\n            color: \"primary\",\n            sx: {\n              mr: 1\n            }\n          }), batchAction === 'makePrivate' && /*#__PURE__*/_jsx(LockIcon, {\n            color: \"primary\",\n            sx: {\n              mr: 1\n            }\n          }), /*#__PURE__*/_jsxs(Typography, {\n            children: [batchAction === 'delete' && `Are you sure you want to delete ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''}?`, batchAction === 'download' && `Download ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''}?`, batchAction === 'copy' && `Copy ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''}?`, batchAction === 'move' && `Move ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''}?`, batchAction === 'makePublic' && `Make ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''} public?`, batchAction === 'makePrivate' && `Make ${selectedItems.length} item${selectedItems.length !== 1 ? 's' : ''} private?`]\n          })]\n        }), selectedItems.length <= 5 ? /*#__PURE__*/_jsx(List, {\n          dense: true,\n          children: selectedItems.map((item, index) => /*#__PURE__*/_jsxs(ListItem, {\n            children: [/*#__PURE__*/_jsx(ListItemIcon, {\n              children: item.type === 'folder' || item.type === 'directory' ? /*#__PURE__*/_jsx(FolderIcon, {\n                fontSize: \"small\",\n                color: \"primary\"\n              }) : /*#__PURE__*/_jsx(FileIcon, {\n                fontSize: \"small\"\n              })\n            }), /*#__PURE__*/_jsx(ListItemText, {\n              primary: item.key.split('/').pop() || item.key,\n              secondary: item.type === 'file' ? formatFileSize(item.size) : ''\n            })]\n          }, index))\n        }) : /*#__PURE__*/_jsxs(Alert, {\n          severity: \"info\",\n          children: [selectedItems.length, \" items selected. Proceeding will affect all selected items.\"]\n        }), (batchAction === 'copy' || batchAction === 'move') && /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            mt: 2\n          },\n          children: [/*#__PURE__*/_jsx(Typography, {\n            variant: \"subtitle2\",\n            gutterBottom: true,\n            children: \"Destination:\"\n          }), /*#__PURE__*/_jsxs(FormControl, {\n            fullWidth: true,\n            sx: {\n              mt: 1\n            },\n            children: [/*#__PURE__*/_jsx(InputLabel, {\n              children: \"Destination Folder\"\n            }), /*#__PURE__*/_jsxs(Select, {\n              value: \"\",\n              onChange: () => {},\n              children: [/*#__PURE__*/_jsx(MenuItem, {\n                value: \"\",\n                children: \"Root Directory\"\n              }), objects.filter(item => item.type === 'folder' || item.type === 'directory').map((folder, idx) => /*#__PURE__*/_jsx(MenuItem, {\n                value: folder.key,\n                children: folder.key\n              }, idx))]\n            })]\n          })]\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => setBatchActionDialogOpen(false),\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          variant: \"contained\",\n          color: batchAction === 'delete' ? 'error' : 'primary',\n          onClick: executeBatchAction,\n          startIcon: batchAction === 'delete' ? /*#__PURE__*/_jsx(DeleteIcon, {}) : batchAction === 'download' ? /*#__PURE__*/_jsx(DownloadIcon, {}) : batchAction === 'copy' ? /*#__PURE__*/_jsx(CopyIcon, {}) : batchAction === 'move' ? /*#__PURE__*/_jsx(MoveIcon, {}) : batchAction === 'makePublic' ? /*#__PURE__*/_jsx(PublicIcon, {}) : batchAction === 'makePrivate' ? /*#__PURE__*/_jsx(LockIcon, {}) : null,\n          children: batchAction === 'delete' ? 'Delete' : batchAction === 'download' ? 'Download' : batchAction === 'copy' ? 'Copy' : batchAction === 'move' ? 'Move' : batchAction === 'makePublic' ? 'Make Public' : batchAction === 'makePrivate' ? 'Make Private' : 'Confirm'\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: newFolderDialogOpen,\n      onClose: () => setNewFolderDialogOpen(false),\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: \"Create New Folder\"\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        children: [/*#__PURE__*/_jsx(DialogContentText, {\n          children: \"Enter a name for the new folder.\"\n        }), /*#__PURE__*/_jsx(TextField, {\n          autoFocus: true,\n          margin: \"dense\",\n          id: \"folder-name\",\n          label: \"Folder Name\",\n          type: \"text\",\n          fullWidth: true,\n          value: newFolderName,\n          onChange: e => setNewFolderName(e.target.value),\n          error: Boolean(error),\n          helperText: error,\n          disabled: loading\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => setNewFolderDialogOpen(false),\n          disabled: loading,\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          onClick: createFolder,\n          color: \"primary\",\n          disabled: loading || !newFolderName,\n          children: loading ? /*#__PURE__*/_jsx(CircularProgress, {\n            size: 24\n          }) : 'Create'\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: confirmDeleteDialogOpen,\n      onClose: () => setConfirmDeleteDialogOpen(false),\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: \"Confirm Delete\"\n      }), /*#__PURE__*/_jsx(DialogContent, {\n        children: /*#__PURE__*/_jsxs(DialogContentText, {\n          children: [\"Are you sure you want to delete the \", (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.type) === 'bucket' ? 'bucket' : (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.type) === 'folder' ? 'folder' : 'file', \":\", /*#__PURE__*/_jsx(Box, {\n            component: \"span\",\n            sx: {\n              fontWeight: 'bold',\n              display: 'block',\n              mt: 1\n            },\n            children: (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.name) || (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.key)\n          }), (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.type) === 'bucket' && /*#__PURE__*/_jsx(Typography, {\n            color: \"error\",\n            sx: {\n              mt: 2\n            },\n            children: \"This will delete all objects in the bucket!\"\n          }), (itemToDelete === null || itemToDelete === void 0 ? void 0 : itemToDelete.type) === 'folder' && /*#__PURE__*/_jsx(Typography, {\n            color: \"error\",\n            sx: {\n              mt: 2\n            },\n            children: \"This will delete all contents of the folder!\"\n          })]\n        })\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => setConfirmDeleteDialogOpen(false),\n          disabled: loading,\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          onClick: deleteItem,\n          color: \"error\",\n          disabled: loading,\n          children: loading ? /*#__PURE__*/_jsx(CircularProgress, {\n            size: 24\n          }) : 'Delete'\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: fileUploadDialogOpen,\n      onClose: () => {\n        if (!loading) {\n          setFileUploadDialogOpen(false);\n          setSelectedFile(null);\n          setUploadProgress(0);\n        }\n      },\n      fullWidth: true,\n      maxWidth: \"md\",\n      children: [/*#__PURE__*/_jsx(DialogTitle, {\n        children: /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'space-between'\n          },\n          children: [\"Upload Files to S3\", /*#__PURE__*/_jsx(IconButton, {\n            onClick: () => {\n              if (!loading) {\n                setFileUploadDialogOpen(false);\n                setSelectedFile(null);\n                setUploadProgress(0);\n              }\n            },\n            children: /*#__PURE__*/_jsx(CloseIcon, {})\n          })]\n        })\n      }), /*#__PURE__*/_jsxs(DialogContent, {\n        children: [/*#__PURE__*/_jsx(Typography, {\n          variant: \"subtitle2\",\n          gutterBottom: true,\n          children: \"Upload Location:\"\n        }), /*#__PURE__*/_jsx(Paper, {\n          variant: \"outlined\",\n          sx: {\n            p: 1.5,\n            mb: 2,\n            bgcolor: 'background.default'\n          },\n          children: /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              display: 'flex',\n              alignItems: 'center'\n            },\n            children: [/*#__PURE__*/_jsx(BucketIcon, {\n              color: \"primary\",\n              sx: {\n                mr: 1\n              }\n            }), /*#__PURE__*/_jsxs(Typography, {\n              sx: {\n                fontWeight: 'medium'\n              },\n              children: [selectedBucket, currentPrefix ? `/${currentPrefix}` : '']\n            })]\n          })\n        }), /*#__PURE__*/_jsxs(Box, {\n          sx: {\n            border: '2px dashed',\n            borderColor: 'divider',\n            borderRadius: 1,\n            p: 3,\n            mb: 3,\n            textAlign: 'center',\n            transition: 'all 0.2s ease',\n            '&:hover': {\n              borderColor: 'primary.main',\n              bgcolor: 'action.hover'\n            },\n            position: 'relative'\n          },\n          onDragOver: e => {\n            e.preventDefault();\n            e.stopPropagation();\n            e.currentTarget.style.borderColor = theme => theme.palette.primary.main;\n            e.currentTarget.style.backgroundColor = theme => theme.palette.action.hover;\n          },\n          onDragLeave: e => {\n            e.preventDefault();\n            e.stopPropagation();\n            e.currentTarget.style.borderColor = '';\n            e.currentTarget.style.backgroundColor = '';\n          },\n          onDrop: e => {\n            e.preventDefault();\n            e.stopPropagation();\n            e.currentTarget.style.borderColor = '';\n            e.currentTarget.style.backgroundColor = '';\n            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n              // Process all dropped files\n              processFileSelection(e.dataTransfer.files);\n            }\n          },\n          children: [/*#__PURE__*/_jsx(UploadIcon, {\n            color: \"primary\",\n            sx: {\n              fontSize: 40,\n              mb: 2\n            }\n          }), /*#__PURE__*/_jsx(Typography, {\n            variant: \"h6\",\n            gutterBottom: true,\n            children: \"Drag & Drop Files Here\"\n          }), /*#__PURE__*/_jsx(Typography, {\n            variant: \"body2\",\n            color: \"textSecondary\",\n            paragraph: true,\n            children: \"or\"\n          }), /*#__PURE__*/_jsxs(Button, {\n            variant: \"contained\",\n            component: \"label\",\n            startIcon: /*#__PURE__*/_jsx(UploadIcon, {}),\n            children: [\"Browse Files\", /*#__PURE__*/_jsx(\"input\", {\n              type: \"file\",\n              hidden: true,\n              multiple: true,\n              onChange: e => {\n                if (e.target.files && e.target.files.length > 0) {\n                  processFileSelection(e.target.files);\n                }\n              }\n            })]\n          }), /*#__PURE__*/_jsx(Typography, {\n            variant: \"caption\",\n            color: \"textSecondary\",\n            sx: {\n              display: 'block',\n              mt: 2\n            },\n            children: \"Supported file types: CSV, JSON, XML, PDF, Images, Text files\"\n          })]\n        }), selectedFile && /*#__PURE__*/_jsxs(Box, {\n          children: [/*#__PURE__*/_jsx(Typography, {\n            variant: \"subtitle2\",\n            gutterBottom: true,\n            children: \"File Preview\"\n          }), /*#__PURE__*/_jsx(Paper, {\n            variant: \"outlined\",\n            sx: {\n              p: 2,\n              mb: 2\n            },\n            children: /*#__PURE__*/_jsxs(Grid, {\n              container: true,\n              spacing: 2,\n              alignItems: \"center\",\n              children: [/*#__PURE__*/_jsx(Grid, {\n                item: true,\n                xs: 12,\n                md: 6,\n                children: (() => {\n                  const FileCard = require(\"../../common/FileCard\").default;\n\n                  // Generate metadata for the file\n                  const fileMetadata = generateFileMetadata(selectedFile);\n                  return /*#__PURE__*/_jsx(FileCard, {\n                    file: selectedFile,\n                    showActions: false,\n                    showPreview: false,\n                    variant: \"outlined\"\n                  });\n                })()\n              }), /*#__PURE__*/_jsxs(Grid, {\n                item: true,\n                xs: 12,\n                md: 6,\n                children: [/*#__PURE__*/_jsx(Typography, {\n                  variant: \"subtitle2\",\n                  gutterBottom: true,\n                  children: \"File Details\"\n                }), /*#__PURE__*/_jsxs(Box, {\n                  sx: {\n                    mb: 2\n                  },\n                  children: [/*#__PURE__*/_jsxs(Typography, {\n                    variant: \"body2\",\n                    sx: {\n                      display: 'flex',\n                      justifyContent: 'space-between'\n                    },\n                    children: [/*#__PURE__*/_jsx(\"span\", {\n                      children: \"File name:\"\n                    }), /*#__PURE__*/_jsx(\"span\", {\n                      style: {\n                        fontWeight: 'medium'\n                      },\n                      children: selectedFile.name\n                    })]\n                  }), /*#__PURE__*/_jsxs(Typography, {\n                    variant: \"body2\",\n                    sx: {\n                      display: 'flex',\n                      justifyContent: 'space-between'\n                    },\n                    children: [/*#__PURE__*/_jsx(\"span\", {\n                      children: \"Size:\"\n                    }), /*#__PURE__*/_jsx(\"span\", {\n                      children: formatFileSize(selectedFile.size)\n                    })]\n                  }), /*#__PURE__*/_jsxs(Typography, {\n                    variant: \"body2\",\n                    sx: {\n                      display: 'flex',\n                      justifyContent: 'space-between'\n                    },\n                    children: [/*#__PURE__*/_jsx(\"span\", {\n                      children: \"Type:\"\n                    }), /*#__PURE__*/_jsx(\"span\", {\n                      children: selectedFile.type || 'Unknown'\n                    })]\n                  }), /*#__PURE__*/_jsxs(Typography, {\n                    variant: \"body2\",\n                    sx: {\n                      display: 'flex',\n                      justifyContent: 'space-between'\n                    },\n                    children: [/*#__PURE__*/_jsx(\"span\", {\n                      children: \"Last modified:\"\n                    }), /*#__PURE__*/_jsx(\"span\", {\n                      children: new Date(selectedFile.lastModified).toLocaleString()\n                    })]\n                  })]\n                }), (() => {\n                  const {\n                    isPreviewSupported,\n                    getFileTypeDescription\n                  } = require(\"../../../utils/fileTypeUtils\");\n                  const mimeType = selectedFile.type;\n                  const isSupported = isPreviewSupported(mimeType);\n                  return /*#__PURE__*/_jsx(Box, {\n                    sx: {\n                      mb: 2\n                    },\n                    children: isSupported ? /*#__PURE__*/_jsxs(Alert, {\n                      severity: \"success\",\n                      icon: /*#__PURE__*/_jsx(CheckCircleIcon, {}),\n                      children: [\"This file type (\", getFileTypeDescription(mimeType), \") is fully supported.\"]\n                    }) : /*#__PURE__*/_jsxs(Alert, {\n                      severity: \"warning\",\n                      children: [/*#__PURE__*/_jsx(AlertTitle, {\n                        children: \"Limited Support\"\n                      }), \"This file type may have limited preview capabilities in the system.\"]\n                    })\n                  });\n                })(), /*#__PURE__*/_jsx(Button, {\n                  fullWidth: true,\n                  variant: \"outlined\",\n                  color: \"error\",\n                  startIcon: /*#__PURE__*/_jsx(CloseIcon, {}),\n                  onClick: () => setSelectedFile(null),\n                  sx: {\n                    mt: 1\n                  },\n                  children: \"Remove File\"\n                })]\n              })]\n            })\n          }), uploadProgress > 0 && /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              mt: 2,\n              mb: 2\n            },\n            children: [/*#__PURE__*/_jsxs(Typography, {\n              variant: \"subtitle2\",\n              gutterBottom: true,\n              display: \"flex\",\n              justifyContent: \"space-between\",\n              children: [/*#__PURE__*/_jsx(\"span\", {\n                children: \"Upload Progress\"\n              }), /*#__PURE__*/_jsxs(\"span\", {\n                children: [uploadProgress, \"%\"]\n              })]\n            }), /*#__PURE__*/_jsx(LinearProgress, {\n              variant: \"determinate\",\n              value: uploadProgress,\n              sx: {\n                height: 10,\n                borderRadius: 5,\n                mb: 1\n              }\n            }), /*#__PURE__*/_jsx(Typography, {\n              variant: \"caption\",\n              color: \"textSecondary\",\n              children: uploadProgress < 100 ? `Uploading ${selectedFile.name}...` : `Successfully uploaded ${selectedFile.name}`\n            }), filesToUpload.length > 1 && /*#__PURE__*/_jsxs(Box, {\n              sx: {\n                mt: 1,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'space-between'\n              },\n              children: [/*#__PURE__*/_jsxs(Typography, {\n                variant: \"caption\",\n                color: \"textSecondary\",\n                children: [\"File \", currentUploadIndex + 1, \" of \", filesToUpload.length]\n              }), /*#__PURE__*/_jsxs(Box, {\n                sx: {\n                  display: 'flex',\n                  alignItems: 'center'\n                },\n                children: [Array.from({\n                  length: Math.min(filesToUpload.length, 5)\n                }).map((_, index) => {\n                  // Calculate status for this dot\n                  let color = 'grey.300'; // default - not started\n                  if (index < currentUploadIndex) {\n                    color = 'success.main'; // completed\n                  } else if (index === currentUploadIndex) {\n                    color = uploadProgress === 100 ? 'success.main' : 'primary.main'; // in progress\n                  }\n                  return /*#__PURE__*/_jsx(Box, {\n                    sx: {\n                      width: 8,\n                      height: 8,\n                      borderRadius: '50%',\n                      bgcolor: color,\n                      mx: 0.5\n                    }\n                  }, index);\n                }), filesToUpload.length > 5 && /*#__PURE__*/_jsxs(Typography, {\n                  variant: \"caption\",\n                  color: \"textSecondary\",\n                  sx: {\n                    ml: 1\n                  },\n                  children: [\"+\", filesToUpload.length - 5, \" more\"]\n                })]\n              })]\n            })]\n          }), /*#__PURE__*/_jsxs(Box, {\n            sx: {\n              mt: 3\n            },\n            children: [/*#__PURE__*/_jsx(Typography, {\n              variant: \"subtitle2\",\n              gutterBottom: true,\n              children: \"Upload Options\"\n            }), /*#__PURE__*/_jsx(FormControlLabel, {\n              control: /*#__PURE__*/_jsx(Checkbox, {\n                checked: uploadOptions.overwriteExisting,\n                onChange: () => setUploadOptions(prev => ({\n                  ...prev,\n                  overwriteExisting: !prev.overwriteExisting\n                })),\n                name: \"overwriteExisting\"\n              }),\n              label: \"Overwrite if file already exists\"\n            }), /*#__PURE__*/_jsx(FormControlLabel, {\n              control: /*#__PURE__*/_jsx(Checkbox, {\n                checked: uploadOptions.makePublic,\n                onChange: () => setUploadOptions(prev => ({\n                  ...prev,\n                  makePublic: !prev.makePublic\n                })),\n                name: \"makePublic\"\n              }),\n              label: \"Make file publicly accessible\"\n            }), filesToUpload.length > 1 && /*#__PURE__*/_jsxs(Box, {\n              sx: {\n                mt: 2,\n                p: 1,\n                bgcolor: 'info.lightest',\n                borderRadius: 1\n              },\n              children: [/*#__PURE__*/_jsxs(Typography, {\n                variant: \"body2\",\n                gutterBottom: true,\n                sx: {\n                  fontWeight: 'medium',\n                  color: 'info.main',\n                  display: 'flex',\n                  alignItems: 'center'\n                },\n                children: [/*#__PURE__*/_jsx(InfoIcon, {\n                  fontSize: \"small\",\n                  sx: {\n                    mr: 0.5\n                  }\n                }), \"Batch Upload Information\"]\n              }), /*#__PURE__*/_jsxs(Typography, {\n                variant: \"body2\",\n                children: [filesToUpload.length, \" files selected for upload (\", formatFileSize(filesToUpload.reduce((total, file) => total + file.size, 0)), \")\"]\n              }), /*#__PURE__*/_jsx(Button, {\n                size: \"small\",\n                variant: \"text\",\n                color: \"primary\",\n                onClick: () => {\n                  setFilesToUpload([]);\n                  setSelectedFile(null);\n                },\n                sx: {\n                  mt: 1\n                },\n                startIcon: /*#__PURE__*/_jsx(CloseIcon, {\n                  fontSize: \"small\"\n                }),\n                children: \"Clear Batch Selection\"\n              })]\n            })]\n          })]\n        })]\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        sx: {\n          px: 3,\n          py: 2\n        },\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => {\n            setFileUploadDialogOpen(false);\n            setSelectedFile(null);\n            setUploadProgress(0);\n          },\n          disabled: loading,\n          children: \"Cancel\"\n        }), /*#__PURE__*/_jsx(Button, {\n          onClick: uploadFile,\n          variant: \"contained\",\n          color: \"primary\",\n          disabled: loading || !selectedFile || uploadProgress > 0,\n          startIcon: loading ? /*#__PURE__*/_jsx(CircularProgress, {\n            size: 20\n          }) : /*#__PURE__*/_jsx(UploadIcon, {}),\n          children: loading ? 'Uploading...' : filesToUpload.length > 1 ? `Upload ${filesToUpload.length} Files` : 'Upload File'\n        })]\n      })]\n    }), /*#__PURE__*/_jsxs(Dialog, {\n      open: fileViewerOpen,\n      onClose: () => setFileViewerOpen(false),\n      fullWidth: true,\n      maxWidth: \"lg\",\n      children: [/*#__PURE__*/_jsx(DialogContent, {\n        dividers: true,\n        sx: {\n          p: 0\n        },\n        children: renderFilePreview(fileViewUrl, fileViewType)\n      }), /*#__PURE__*/_jsxs(DialogActions, {\n        children: [/*#__PURE__*/_jsx(Button, {\n          onClick: () => setFileViewerOpen(false),\n          children: \"Close\"\n        }), selectedItem && selectedItem.type === 'file' && /*#__PURE__*/_jsxs(_Fragment, {\n          children: [/*#__PURE__*/_jsx(Button, {\n            onClick: () => {\n              downloadObject(selectedItem);\n            },\n            startIcon: /*#__PURE__*/_jsx(DownloadIcon, {}),\n            children: \"Download\"\n          }), /*#__PURE__*/_jsx(Button, {\n            onClick: () => {\n              onSelectObject({\n                bucketName: selectedBucket,\n                prefix: currentPrefix,\n                key: selectedItem.key,\n                size: selectedItem.size,\n                lastModified: selectedItem.lastModified,\n                contentType: selectedItem.contentType\n              });\n              setFileViewerOpen(false);\n            },\n            variant: \"contained\",\n            color: \"primary\",\n            startIcon: /*#__PURE__*/_jsx(CheckCircleIcon, {}),\n            children: \"Select This File\"\n          })]\n        })]\n      })]\n    })]\n  });\n};\nexport default S3BucketBrowser;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}