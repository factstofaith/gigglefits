{"ast":null,"code":"/**\n * Accessibility Announcement Hook\n * \n * A custom hook for managing accessibility announcements for screen readers.\n * Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yAnnouncement\n */\n\nimport { useState, useCallback, useEffect, useRef } from 'react';\n\n/**\n * Enum for announcement politeness levels\n */\nexport const PolitenessLevel = {\n  POLITE: 'polite',\n  ASSERTIVE: 'assertive'\n};\n\n/**\n * Custom hook for managing screen reader announcements\n * \n * @param {Object} options - Configuration options\n * @param {number} [options.maxQueue=10] - Maximum queue size\n * @param {boolean} [options.clearOnUnmount=true] - Whether to clear announcements on unmount\n * @returns {Object} Object containing announcement functions and state\n */\nconst useA11yAnnouncement = function () {\n  let {\n    maxQueue = 10,\n    clearOnUnmount = true\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Store announcements in a queue\n  const [announcements, setAnnouncements] = useState([]);\n\n  // Track whether the component is mounted\n  const isMounted = useRef(true);\n\n  // Store announcement elements for direct access\n  const politeAnnouncementRef = useRef(null);\n  const assertiveAnnouncementRef = useRef(null);\n\n  /**\n   * Create a unique ID for announcement elements\n   */\n  const getUniqueId = useCallback(() => {\n    return `announcement-${Math.random().toString(36).substring(2, 11)}`;\n  }, []);\n\n  /**\n   * Generate the announcement element IDs if not already set\n   */\n  const politeAnnouncementId = useRef(getUniqueId());\n  const assertiveAnnouncementId = useRef(getUniqueId());\n\n  /**\n   * Add an announcement to the queue\n   */\n  const announce = useCallback(function (message) {\n    let politeness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PolitenessLevel.POLITE;\n    if (!message || typeof message !== 'string') return;\n    setAnnouncements(prev => {\n      // Add new announcement to the queue\n      const newQueue = [...prev, {\n        id: getUniqueId(),\n        message,\n        politeness,\n        timestamp: new Date().getTime()\n      }];\n\n      // Limit queue size\n      return newQueue.slice(-maxQueue);\n    });\n  }, [maxQueue, getUniqueId]);\n\n  /**\n   * Convenience method for polite announcements\n   */\n  const announcePolite = useCallback(message => {\n    announce(message, PolitenessLevel.POLITE);\n  }, [announce]);\n\n  /**\n   * Convenience method for assertive announcements\n   */\n  const announceAssertive = useCallback(message => {\n    announce(message, PolitenessLevel.ASSERTIVE);\n  }, [announce]);\n\n  /**\n   * Process the announcement queue\n   */\n  useEffect(() => {\n    if (announcements.length === 0) return;\n\n    // Get the latest announcement\n    const latestAnnouncement = announcements[announcements.length - 1];\n\n    // Find the appropriate element\n    const element = latestAnnouncement.politeness === PolitenessLevel.ASSERTIVE ? assertiveAnnouncementRef.current : politeAnnouncementRef.current;\n\n    // Update the announcement text\n    if (element) {\n      // Clear first, then set (required for some screen readers)\n      element.textContent = '';\n\n      // Use a timeout to ensure screen readers recognize the change\n      setTimeout(() => {\n        if (isMounted.current && element) {\n          element.textContent = latestAnnouncement.message;\n        }\n      }, 50);\n    }\n  }, [announcements]);\n\n  /**\n   * Create the announcement elements if they don't exist\n   */\n  useEffect(() => {\n    // Create elements if they don't exist\n    if (!politeAnnouncementRef.current) {\n      const politeElement = document.getElementById(politeAnnouncementId.current);\n      if (politeElement) {\n        politeAnnouncementRef.current = politeElement;\n      } else {\n        const newElement = document.createElement('div');\n        newElement.id = politeAnnouncementId.current;\n        newElement.className = 'sr-only';\n        newElement.setAttribute('aria-live', 'polite');\n        newElement.setAttribute('aria-atomic', 'true');\n        document.body.appendChild(newElement);\n        politeAnnouncementRef.current = newElement;\n      }\n    }\n    if (!assertiveAnnouncementRef.current) {\n      const assertiveElement = document.getElementById(assertiveAnnouncementId.current);\n      if (assertiveElement) {\n        assertiveAnnouncementRef.current = assertiveElement;\n      } else {\n        const newElement = document.createElement('div');\n        newElement.id = assertiveAnnouncementId.current;\n        newElement.className = 'sr-only';\n        newElement.setAttribute('aria-live', 'assertive');\n        newElement.setAttribute('aria-atomic', 'true');\n        document.body.appendChild(newElement);\n        assertiveAnnouncementRef.current = newElement;\n      }\n    }\n    return () => {\n      isMounted.current = false;\n\n      // Clean up announcement elements if clearOnUnmount is true\n      if (clearOnUnmount) {\n        if (politeAnnouncementRef.current) {\n          politeAnnouncementRef.current.textContent = '';\n        }\n        if (assertiveAnnouncementRef.current) {\n          assertiveAnnouncementRef.current.textContent = '';\n        }\n      }\n    };\n  }, [clearOnUnmount, politeAnnouncementId, assertiveAnnouncementId]);\n\n  /**\n   * Clear all announcements\n   */\n  const clearAnnouncements = useCallback(() => {\n    setAnnouncements([]);\n    if (politeAnnouncementRef.current) {\n      politeAnnouncementRef.current.textContent = '';\n    }\n    if (assertiveAnnouncementRef.current) {\n      assertiveAnnouncementRef.current.textContent = '';\n    }\n  }, []);\n  return {\n    announce,\n    announcePolite,\n    announceAssertive,\n    clearAnnouncements,\n    announcements,\n    politeAnnouncementId: politeAnnouncementId.current,\n    assertiveAnnouncementId: assertiveAnnouncementId.current\n  };\n};\nexport default useA11yAnnouncement;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}