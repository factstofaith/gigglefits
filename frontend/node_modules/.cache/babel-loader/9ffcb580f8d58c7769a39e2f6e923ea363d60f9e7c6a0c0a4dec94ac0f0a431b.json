{"ast":null,"code":"/**\n * Accessibility Keyboard Hook\n * \n * A custom hook for managing keyboard interactions and focus management\n * in an accessible way. Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yKeyboard\n */\n\nimport { useCallback, useRef, useEffect } from 'react';\n\n/**\n * Custom hook for managing keyboard navigation in an accessible way\n * \n * @param {Object} options - Configuration options\n * @param {Array<HTMLElement|React.RefObject>} [options.elements] - Array of elements or refs to include in keyboard navigation\n * @param {boolean} [options.trapFocus=false] - Whether to trap focus within the elements\n * @param {boolean} [options.autoFocus=true] - Whether to auto-focus the first element when elements change\n * @param {boolean} [options.loop=true] - Whether to loop from last to first element and vice versa\n * @param {Function} [options.onEscape] - Callback to call when Escape key is pressed\n * @param {string} [options.focusClass='a11y-keyboard-focus'] - CSS class to apply to elements focused via keyboard\n * @returns {Object} Object containing focus management functions and keyboard handlers\n */\nconst useA11yKeyboard = function () {\n  let {\n    elements = [],\n    trapFocus = false,\n    autoFocus = true,\n    loop = true,\n    onEscape = null,\n    focusClass = 'a11y-keyboard-focus'\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Reference to track the current focus index\n  const currentIndexRef = useRef(-1);\n\n  // Reference to track if the focus was triggered by keyboard\n  const keyboardFocusRef = useRef(false);\n\n  // Store the element references for access in event handlers\n  const elementsRef = useRef([]);\n\n  // Store the initial active element to restore focus when unmounting\n  const initialActiveElement = useRef(null);\n\n  /**\n   * Get the actual DOM elements from the elements array\n   * which could contain React refs or direct DOM elements\n   */\n  const getDOMElements = useCallback(() => {\n    return elements.map(element => {\n      // If it's a React ref, get the current value\n      if (element && typeof element === 'object' && 'current' in element) {\n        return element.current;\n      }\n      return element;\n    }).filter(Boolean); // Filter out null/undefined\n  }, [elements]);\n\n  /**\n   * Updates the stored elements array\n   */\n  useEffect(() => {\n    elementsRef.current = getDOMElements();\n  }, [getDOMElements]);\n\n  /**\n   * Focus an element at a specific index\n   */\n  const focusElementAt = useCallback(index => {\n    const domElements = elementsRef.current;\n    if (domElements.length === 0) return;\n\n    // Handle index out of bounds based on loop setting\n    if (index < 0) {\n      index = loop ? domElements.length - 1 : 0;\n    } else if (index >= domElements.length) {\n      index = loop ? 0 : domElements.length - 1;\n    }\n\n    // Update current index and focus the element\n    currentIndexRef.current = index;\n    keyboardFocusRef.current = true;\n    const elementToFocus = domElements[index];\n    if (elementToFocus && typeof elementToFocus.focus === 'function') {\n      elementToFocus.focus();\n\n      // Apply focus styling for keyboard navigation\n      elementToFocus.classList.add(focusClass);\n\n      // Remove the class when focus is lost\n      const handleBlur = () => {\n        elementToFocus.classList.remove(focusClass);\n        elementToFocus.removeEventListener('blur', handleBlur);\n      };\n      elementToFocus.addEventListener('blur', handleBlur);\n    }\n  }, [loop, focusClass]);\n\n  /**\n   * Handle focusing the next element in the sequence\n   */\n  const focusNext = useCallback(() => {\n    focusElementAt(currentIndexRef.current + 1);\n  }, [focusElementAt]);\n\n  /**\n   * Handle focusing the previous element in the sequence\n   */\n  const focusPrevious = useCallback(() => {\n    focusElementAt(currentIndexRef.current - 1);\n  }, [focusElementAt]);\n\n  /**\n   * Focus the first element in the sequence\n   */\n  const focusFirst = useCallback(() => {\n    focusElementAt(0);\n  }, [focusElementAt]);\n\n  /**\n   * Focus the last element in the sequence\n   */\n  const focusLast = useCallback(() => {\n    const domElements = elementsRef.current;\n    focusElementAt(domElements.length - 1);\n  }, [focusElementAt]);\n\n  /**\n   * Handle keydown events for keyboard navigation\n   */\n  const handleKeyDown = useCallback(event => {\n    const {\n      key,\n      shiftKey\n    } = event;\n\n    // Handle tab key for focus management\n    if (key === 'Tab') {\n      // If focus should be trapped within the component\n      if (trapFocus) {\n        event.preventDefault();\n        if (shiftKey) {\n          focusPrevious();\n        } else {\n          focusNext();\n        }\n      }\n      // Otherwise, let Tab work normally, but keep track of the currently focused element\n      else {\n        const domElements = elementsRef.current;\n        const currentFocusedElement = document.activeElement;\n        const newIndex = domElements.findIndex(el => el === currentFocusedElement);\n        if (newIndex !== -1) {\n          currentIndexRef.current = newIndex;\n        }\n      }\n    }\n    // Arrow key navigation\n    else if (key === 'ArrowDown' || key === 'ArrowRight') {\n      event.preventDefault();\n      focusNext();\n    } else if (key === 'ArrowUp' || key === 'ArrowLeft') {\n      event.preventDefault();\n      focusPrevious();\n    } else if (key === 'Home') {\n      event.preventDefault();\n      focusFirst();\n    } else if (key === 'End') {\n      event.preventDefault();\n      focusLast();\n    } else if (key === 'Escape' && onEscape) {\n      event.preventDefault();\n      onEscape(event);\n    }\n  }, [trapFocus, focusNext, focusPrevious, focusFirst, focusLast, onEscape]);\n\n  /**\n   * Set up auto-focus on initial render and when elements change\n   */\n  useEffect(() => {\n    const domElements = getDOMElements();\n    elementsRef.current = domElements;\n    if (autoFocus && domElements.length > 0 && currentIndexRef.current === -1) {\n      // Store the initially focused element to restore later\n      initialActiveElement.current = document.activeElement;\n\n      // Focus the first element in the sequence\n      focusFirst();\n    }\n    return () => {\n      // If nothing is focused now or if the currently focused element is in our list,\n      // return focus to the initially active element when unmounting\n      const currentFocused = document.activeElement;\n      const isElementInList = elementsRef.current.includes(currentFocused);\n      if (initialActiveElement.current && (currentFocused === document.body || isElementInList)) {\n        try {\n          initialActiveElement.current.focus();\n        } catch (e) {\n          // Ignore focus errors (element might be gone)\n        }\n      }\n    };\n  }, [elements, autoFocus, getDOMElements, focusFirst]);\n\n  /**\n   * Create an event handler that can be directly attached to an element\n   */\n  const createKeyDownHandler = useCallback(() => {\n    return event => handleKeyDown(event);\n  }, [handleKeyDown]);\n  return {\n    focusNext,\n    focusPrevious,\n    focusFirst,\n    focusLast,\n    focusElementAt,\n    handleKeyDown,\n    createKeyDownHandler,\n    currentIndex: currentIndexRef.current,\n    isKeyboardFocus: keyboardFocusRef.current\n  };\n};\nexport default useA11yKeyboard;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}