{"ast":null,"code":"/**\n * Accessibility Keyboard Hook\n * \n * A custom hook for managing keyboard interactions and focus management\n * in an accessible way. Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yKeyboard\n */import{useCallback,useRef,useEffect}from'react';/**\n * Custom hook for managing keyboard navigation in an accessible way\n * \n * @param {Object} options - Configuration options\n * @param {Array<HTMLElement|React.RefObject>} [options.elements] - Array of elements or refs to include in keyboard navigation\n * @param {boolean} [options.trapFocus=false] - Whether to trap focus within the elements\n * @param {boolean} [options.autoFocus=true] - Whether to auto-focus the first element when elements change\n * @param {boolean} [options.loop=true] - Whether to loop from last to first element and vice versa\n * @param {Function} [options.onEscape] - Callback to call when Escape key is pressed\n * @param {string} [options.focusClass='a11y-keyboard-focus'] - CSS class to apply to elements focused via keyboard\n * @returns {Object} Object containing focus management functions and keyboard handlers\n */const useA11yKeyboard=function(){let{elements=[],trapFocus=false,autoFocus=true,loop=true,onEscape=null,focusClass='a11y-keyboard-focus'}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// Reference to track the current focus index\nconst currentIndexRef=useRef(-1);// Reference to track if the focus was triggered by keyboard\nconst keyboardFocusRef=useRef(false);// Store the element references for access in event handlers\nconst elementsRef=useRef([]);// Store the initial active element to restore focus when unmounting\nconst initialActiveElement=useRef(null);/**\n   * Get the actual DOM elements from the elements array\n   * which could contain React refs or direct DOM elements\n   */const getDOMElements=useCallback(()=>{return elements.map(element=>{// If it's a React ref, get the current value\nif(element&&typeof element==='object'&&'current'in element){return element.current;}return element;}).filter(Boolean);// Filter out null/undefined\n},[elements]);/**\n   * Updates the stored elements array\n   */useEffect(()=>{elementsRef.current=getDOMElements();},[getDOMElements]);/**\n   * Focus an element at a specific index\n   */const focusElementAt=useCallback(index=>{const domElements=elementsRef.current;if(domElements.length===0)return;// Handle index out of bounds based on loop setting\nif(index<0){index=loop?domElements.length-1:0;}else if(index>=domElements.length){index=loop?0:domElements.length-1;}// Update current index and focus the element\ncurrentIndexRef.current=index;keyboardFocusRef.current=true;const elementToFocus=domElements[index];if(elementToFocus&&typeof elementToFocus.focus==='function'){elementToFocus.focus();// Apply focus styling for keyboard navigation\nelementToFocus.classList.add(focusClass);// Remove the class when focus is lost\nconst handleBlur=()=>{elementToFocus.classList.remove(focusClass);elementToFocus.removeEventListener('blur',handleBlur);};elementToFocus.addEventListener('blur',handleBlur);}},[loop,focusClass]);/**\n   * Handle focusing the next element in the sequence\n   */const focusNext=useCallback(()=>{focusElementAt(currentIndexRef.current+1);},[focusElementAt]);/**\n   * Handle focusing the previous element in the sequence\n   */const focusPrevious=useCallback(()=>{focusElementAt(currentIndexRef.current-1);},[focusElementAt]);/**\n   * Focus the first element in the sequence\n   */const focusFirst=useCallback(()=>{focusElementAt(0);},[focusElementAt]);/**\n   * Focus the last element in the sequence\n   */const focusLast=useCallback(()=>{const domElements=elementsRef.current;focusElementAt(domElements.length-1);},[focusElementAt]);/**\n   * Handle keydown events for keyboard navigation\n   */const handleKeyDown=useCallback(event=>{const{key,shiftKey}=event;// Handle tab key for focus management\nif(key==='Tab'){// If focus should be trapped within the component\nif(trapFocus){event.preventDefault();if(shiftKey){focusPrevious();}else{focusNext();}}// Otherwise, let Tab work normally, but keep track of the currently focused element\nelse{const domElements=elementsRef.current;const currentFocusedElement=document.activeElement;const newIndex=domElements.findIndex(el=>el===currentFocusedElement);if(newIndex!==-1){currentIndexRef.current=newIndex;}}}// Arrow key navigation\nelse if(key==='ArrowDown'||key==='ArrowRight'){event.preventDefault();focusNext();}else if(key==='ArrowUp'||key==='ArrowLeft'){event.preventDefault();focusPrevious();}else if(key==='Home'){event.preventDefault();focusFirst();}else if(key==='End'){event.preventDefault();focusLast();}else if(key==='Escape'&&onEscape){event.preventDefault();onEscape(event);}},[trapFocus,focusNext,focusPrevious,focusFirst,focusLast,onEscape]);/**\n   * Set up auto-focus on initial render and when elements change\n   */useEffect(()=>{const domElements=getDOMElements();elementsRef.current=domElements;if(autoFocus&&domElements.length>0&&currentIndexRef.current===-1){// Store the initially focused element to restore later\ninitialActiveElement.current=document.activeElement;// Focus the first element in the sequence\nfocusFirst();}return()=>{// If nothing is focused now or if the currently focused element is in our list,\n// return focus to the initially active element when unmounting\nconst currentFocused=document.activeElement;const isElementInList=elementsRef.current.includes(currentFocused);if(initialActiveElement.current&&(currentFocused===document.body||isElementInList)){try{initialActiveElement.current.focus();}catch(e){// Ignore focus errors (element might be gone)\n}}};},[elements,autoFocus,getDOMElements,focusFirst]);/**\n   * Create an event handler that can be directly attached to an element\n   */const createKeyDownHandler=useCallback(()=>{return event=>handleKeyDown(event);},[handleKeyDown]);/**\n   * Get a handler for arrow key navigation with a custom navigation map\n   */const getArrowKeyHandler=useCallback((currentId,connectionMap,onNavigate)=>{return event=>{const{key}=event;if(!connectionMap||!currentId)return;let nextId=null;if(key==='ArrowRight'){// Navigate to right connection if exists\nconst rightConnections=connectionMap[currentId]||[];if(rightConnections.length>0){nextId=rightConnections[0];}}else if(key==='ArrowLeft'){// Find element that connects to current\nfor(const[sourceId,targets]of Object.entries(connectionMap)){if(targets.includes(currentId)){nextId=sourceId;break;}}}else if(key==='ArrowDown'||key==='ArrowUp'){// This depends on the structure of your visualization\n// For many visualizations, you might want to go to siblings\nconst allIds=Object.keys(connectionMap);const currentIndex=allIds.indexOf(currentId);if(currentIndex!==-1){const nextIndex=key==='ArrowDown'?(currentIndex+1)%allIds.length:(currentIndex-1+allIds.length)%allIds.length;nextId=allIds[nextIndex];}}if(nextId&&onNavigate){onNavigate(nextId);}};},[]);return{focusNext,focusPrevious,focusFirst,focusLast,focusElementAt,handleKeyDown,createKeyDownHandler,getArrowKeyHandler,currentIndex:currentIndexRef.current,isKeyboardFocus:keyboardFocusRef.current};};export default useA11yKeyboard;","map":{"version":3,"names":["useCallback","useRef","useEffect","useA11yKeyboard","elements","trapFocus","autoFocus","loop","onEscape","focusClass","arguments","length","undefined","currentIndexRef","keyboardFocusRef","elementsRef","initialActiveElement","getDOMElements","map","element","current","filter","Boolean","focusElementAt","index","domElements","elementToFocus","focus","classList","add","handleBlur","remove","removeEventListener","addEventListener","focusNext","focusPrevious","focusFirst","focusLast","handleKeyDown","event","key","shiftKey","preventDefault","currentFocusedElement","document","activeElement","newIndex","findIndex","el","currentFocused","isElementInList","includes","body","e","createKeyDownHandler","getArrowKeyHandler","currentId","connectionMap","onNavigate","nextId","rightConnections","sourceId","targets","Object","entries","allIds","keys","currentIndex","indexOf","nextIndex","isKeyboardFocus"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/frontend/src/hooks/a11y/useA11yKeyboard.js"],"sourcesContent":["/**\n * Accessibility Keyboard Hook\n * \n * A custom hook for managing keyboard interactions and focus management\n * in an accessible way. Part of the zero technical debt accessibility implementation.\n * \n * @module hooks/a11y/useA11yKeyboard\n */\n\nimport { useCallback, useRef, useEffect } from 'react';\n\n/**\n * Custom hook for managing keyboard navigation in an accessible way\n * \n * @param {Object} options - Configuration options\n * @param {Array<HTMLElement|React.RefObject>} [options.elements] - Array of elements or refs to include in keyboard navigation\n * @param {boolean} [options.trapFocus=false] - Whether to trap focus within the elements\n * @param {boolean} [options.autoFocus=true] - Whether to auto-focus the first element when elements change\n * @param {boolean} [options.loop=true] - Whether to loop from last to first element and vice versa\n * @param {Function} [options.onEscape] - Callback to call when Escape key is pressed\n * @param {string} [options.focusClass='a11y-keyboard-focus'] - CSS class to apply to elements focused via keyboard\n * @returns {Object} Object containing focus management functions and keyboard handlers\n */\nconst useA11yKeyboard = ({\n  elements = [],\n  trapFocus = false,\n  autoFocus = true,\n  loop = true,\n  onEscape = null,\n  focusClass = 'a11y-keyboard-focus'\n} = {}) => {\n  // Reference to track the current focus index\n  const currentIndexRef = useRef(-1);\n  \n  // Reference to track if the focus was triggered by keyboard\n  const keyboardFocusRef = useRef(false);\n  \n  // Store the element references for access in event handlers\n  const elementsRef = useRef([]);\n  \n  // Store the initial active element to restore focus when unmounting\n  const initialActiveElement = useRef(null);\n  \n  /**\n   * Get the actual DOM elements from the elements array\n   * which could contain React refs or direct DOM elements\n   */\n  const getDOMElements = useCallback(() => {\n    return elements.map(element => {\n      // If it's a React ref, get the current value\n      if (element && typeof element === 'object' && 'current' in element) {\n        return element.current;\n      }\n      return element;\n    }).filter(Boolean); // Filter out null/undefined\n  }, [elements]);\n  \n  /**\n   * Updates the stored elements array\n   */\n  useEffect(() => {\n    elementsRef.current = getDOMElements();\n  }, [getDOMElements]);\n  \n  /**\n   * Focus an element at a specific index\n   */\n  const focusElementAt = useCallback((index) => {\n    const domElements = elementsRef.current;\n    \n    if (domElements.length === 0) return;\n    \n    // Handle index out of bounds based on loop setting\n    if (index < 0) {\n      index = loop ? domElements.length - 1 : 0;\n    } else if (index >= domElements.length) {\n      index = loop ? 0 : domElements.length - 1;\n    }\n    \n    // Update current index and focus the element\n    currentIndexRef.current = index;\n    keyboardFocusRef.current = true;\n    \n    const elementToFocus = domElements[index];\n    if (elementToFocus && typeof elementToFocus.focus === 'function') {\n      elementToFocus.focus();\n      \n      // Apply focus styling for keyboard navigation\n      elementToFocus.classList.add(focusClass);\n      \n      // Remove the class when focus is lost\n      const handleBlur = () => {\n        elementToFocus.classList.remove(focusClass);\n        elementToFocus.removeEventListener('blur', handleBlur);\n      };\n      \n      elementToFocus.addEventListener('blur', handleBlur);\n    }\n  }, [loop, focusClass]);\n  \n  /**\n   * Handle focusing the next element in the sequence\n   */\n  const focusNext = useCallback(() => {\n    focusElementAt(currentIndexRef.current + 1);\n  }, [focusElementAt]);\n  \n  /**\n   * Handle focusing the previous element in the sequence\n   */\n  const focusPrevious = useCallback(() => {\n    focusElementAt(currentIndexRef.current - 1);\n  }, [focusElementAt]);\n  \n  /**\n   * Focus the first element in the sequence\n   */\n  const focusFirst = useCallback(() => {\n    focusElementAt(0);\n  }, [focusElementAt]);\n  \n  /**\n   * Focus the last element in the sequence\n   */\n  const focusLast = useCallback(() => {\n    const domElements = elementsRef.current;\n    focusElementAt(domElements.length - 1);\n  }, [focusElementAt]);\n  \n  /**\n   * Handle keydown events for keyboard navigation\n   */\n  const handleKeyDown = useCallback((event) => {\n    const { key, shiftKey } = event;\n    \n    // Handle tab key for focus management\n    if (key === 'Tab') {\n      // If focus should be trapped within the component\n      if (trapFocus) {\n        event.preventDefault();\n        \n        if (shiftKey) {\n          focusPrevious();\n        } else {\n          focusNext();\n        }\n      }\n      // Otherwise, let Tab work normally, but keep track of the currently focused element\n      else {\n        const domElements = elementsRef.current;\n        const currentFocusedElement = document.activeElement;\n        \n        const newIndex = domElements.findIndex(el => el === currentFocusedElement);\n        if (newIndex !== -1) {\n          currentIndexRef.current = newIndex;\n        }\n      }\n    }\n    // Arrow key navigation\n    else if (key === 'ArrowDown' || key === 'ArrowRight') {\n      event.preventDefault();\n      focusNext();\n    }\n    else if (key === 'ArrowUp' || key === 'ArrowLeft') {\n      event.preventDefault();\n      focusPrevious();\n    }\n    else if (key === 'Home') {\n      event.preventDefault();\n      focusFirst();\n    }\n    else if (key === 'End') {\n      event.preventDefault();\n      focusLast();\n    }\n    else if (key === 'Escape' && onEscape) {\n      event.preventDefault();\n      onEscape(event);\n    }\n  }, [trapFocus, focusNext, focusPrevious, focusFirst, focusLast, onEscape]);\n  \n  /**\n   * Set up auto-focus on initial render and when elements change\n   */\n  useEffect(() => {\n    const domElements = getDOMElements();\n    elementsRef.current = domElements;\n    \n    if (autoFocus && domElements.length > 0 && currentIndexRef.current === -1) {\n      // Store the initially focused element to restore later\n      initialActiveElement.current = document.activeElement;\n      \n      // Focus the first element in the sequence\n      focusFirst();\n    }\n    \n    return () => {\n      // If nothing is focused now or if the currently focused element is in our list,\n      // return focus to the initially active element when unmounting\n      const currentFocused = document.activeElement;\n      const isElementInList = elementsRef.current.includes(currentFocused);\n      \n      if (initialActiveElement.current && \n          (currentFocused === document.body || isElementInList)) {\n        try {\n          initialActiveElement.current.focus();\n        } catch (e) {\n          // Ignore focus errors (element might be gone)\n        }\n      }\n    };\n  }, [elements, autoFocus, getDOMElements, focusFirst]);\n  \n  /**\n   * Create an event handler that can be directly attached to an element\n   */\n  const createKeyDownHandler = useCallback(() => {\n    return (event) => handleKeyDown(event);\n  }, [handleKeyDown]);\n  \n  /**\n   * Get a handler for arrow key navigation with a custom navigation map\n   */\n  const getArrowKeyHandler = useCallback((currentId, connectionMap, onNavigate) => {\n    return (event) => {\n      const { key } = event;\n      \n      if (!connectionMap || !currentId) return;\n      \n      let nextId = null;\n      \n      if (key === 'ArrowRight') {\n        // Navigate to right connection if exists\n        const rightConnections = connectionMap[currentId] || [];\n        if (rightConnections.length > 0) {\n          nextId = rightConnections[0];\n        }\n      } else if (key === 'ArrowLeft') {\n        // Find element that connects to current\n        for (const [sourceId, targets] of Object.entries(connectionMap)) {\n          if (targets.includes(currentId)) {\n            nextId = sourceId;\n            break;\n          }\n        }\n      } else if (key === 'ArrowDown' || key === 'ArrowUp') {\n        // This depends on the structure of your visualization\n        // For many visualizations, you might want to go to siblings\n        const allIds = Object.keys(connectionMap);\n        const currentIndex = allIds.indexOf(currentId);\n        \n        if (currentIndex !== -1) {\n          const nextIndex = key === 'ArrowDown' \n            ? (currentIndex + 1) % allIds.length \n            : (currentIndex - 1 + allIds.length) % allIds.length;\n          nextId = allIds[nextIndex];\n        }\n      }\n      \n      if (nextId && onNavigate) {\n        onNavigate(nextId);\n      }\n    };\n  }, []);\n\n  return {\n    focusNext,\n    focusPrevious,\n    focusFirst,\n    focusLast,\n    focusElementAt,\n    handleKeyDown,\n    createKeyDownHandler,\n    getArrowKeyHandler,\n    currentIndex: currentIndexRef.current,\n    isKeyboardFocus: keyboardFocusRef.current\n  };\n};\n\nexport default useA11yKeyboard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}