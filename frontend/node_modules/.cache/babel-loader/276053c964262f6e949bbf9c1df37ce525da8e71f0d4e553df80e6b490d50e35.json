{"ast":null,"code":"/**\n * Flow Canvas Component\n *\n * A drag-and-drop canvas for building integration flows using React Flow.\n * This component provides the foundation for the flow-based integration\n * interface, allowing users to add, connect, and configure nodes visually.\n *\n * @component\n */\n\nimport React, { useState, useRef, useCallback, useEffect } from 'react';\nimport ReactFlow, { Background, Controls, MiniMap, addEdge, applyEdgeChanges, applyNodeChanges, isNode, isEdge, ReactFlowProvider, useReactFlow } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { Box, Paper, Toolbar, IconButton, Tooltip, Divider, Button, Menu, MenuItem, Typography, Snackbar, Alert } from '@mui/material';\nimport { ZoomIn as ZoomInIcon, ZoomOut as ZoomOutIcon, Add as AddIcon, Delete as DeleteIcon, SaveAlt as SaveIcon, Undo as UndoIcon, Redo as RedoIcon, FitScreen as FitScreenIcon, Lock as LockIcon, LockOpen as LockOpenIcon, Create as CreateIcon, PlayArrow as PlayIcon, Settings as SettingsIcon, MoreVert as MoreVertIcon } from '@mui/icons-material';\n\n// Node types will be imported and registered here\nimport SourceNode from \"./nodes/SourceNode\";\nimport DestinationNode from \"./nodes/DestinationNode\";\nimport TransformationNode from \"./nodes/TransformationNode\";\nimport FilterNode from \"./nodes/FilterNode\";\n\n// Custom edge\nimport FlowEdge from \"./edges/FlowEdge\";\n\n// Import validation utilities\nimport { validateConnection, validateFlow, validateFlowForExecution } from \"./validation/connection-validation\";\n\n// Default flow styling\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst defaultFlowStyle = {\n  background: '#f7f7f7'\n};\n\n// Register custom node types\nconst nodeTypes = {\n  sourceNode: SourceNode,\n  destinationNode: DestinationNode,\n  transformationNode: TransformationNode,\n  filterNode: FilterNode\n};\n\n// Register custom edge types\nconst edgeTypes = {\n  flowEdge: FlowEdge\n};\n\n// Default node configuration\nconst DEFAULT_NODE = {\n  sourceNode: {\n    type: 'sourceNode',\n    data: {\n      label: 'Source',\n      sourceType: 'default',\n      config: {}\n    }\n  },\n  destinationNode: {\n    type: 'destinationNode',\n    data: {\n      label: 'Destination',\n      destinationType: 'default',\n      config: {}\n    }\n  },\n  transformationNode: {\n    type: 'transformationNode',\n    data: {\n      label: 'Transform',\n      transformationType: 'default',\n      config: {}\n    }\n  },\n  filterNode: {\n    type: 'filterNode',\n    data: {\n      label: 'Filter',\n      filterType: 'default',\n      config: {}\n    }\n  }\n};\n\n/**\n * Flow Canvas component\n *\n * @param {Object} props - Component props\n * @param {Array} props.initialElements - Initial flow elements (nodes and edges)\n * @param {boolean} props.readOnly - Whether the canvas is read-only\n * @param {Function} props.onChange - Callback when flow elements change\n * @param {Function} props.onSave - Callback when flow is saved\n * @param {Function} props.onNodeSelect - Callback when a node is selected\n * @param {Function} props.onEdgeSelect - Callback when an edge is selected\n * @param {Function} props.onValidate - Callback to validate the flow\n * @param {Object} props.validationErrors - Validation errors for elements\n * @returns {JSX.Element} The FlowCanvas component\n */\nconst FlowCanvasContent = _ref => {\n  let {\n    initialElements = [],\n    readOnly = false,\n    onChange,\n    onSave,\n    onNodeSelect,\n    onEdgeSelect,\n    onValidate,\n    validationErrors = {}\n  } = _ref;\n  // Separate state for nodes and edges\n  const [nodes, setNodes] = useState(initialElements.filter(el => isNode(el)));\n  const [edges, setEdges] = useState(initialElements.filter(el => isEdge(el)));\n\n  // State for selected elements\n  const [selectedElements, setSelectedElements] = useState([]);\n\n  // History for undo/redo\n  const [historyIndex, setHistoryIndex] = useState(0);\n  const [history, setHistory] = useState([{\n    nodes: initialElements.filter(el => isNode(el)),\n    edges: initialElements.filter(el => isEdge(el)),\n    timestamp: new Date().toISOString(),\n    action: 'Initial state'\n  }]);\n\n  // State for node menu\n  const [nodeMenuAnchorEl, setNodeMenuAnchorEl] = useState(null);\n  const [nodeMenuPosition, setNodeMenuPosition] = useState({\n    x: 0,\n    y: 0\n  });\n\n  // State for notifications\n  const [notification, setNotification] = useState({\n    open: false,\n    message: '',\n    severity: 'info'\n  });\n\n  // Reference to the flow wrapper for calculating drop positions\n  const reactFlowWrapper = useRef(null);\n\n  // Get reactFlow instance helpers\n  const reactFlowInstance = useReactFlow();\n\n  // Combine nodes and edges for backward compatibility\n  const elements = [...nodes, ...edges];\n\n  // Update history when nodes or edges change\n  useEffect(() => {\n    if (onChange) {\n      onChange([...nodes, ...edges]);\n    }\n  }, [nodes, edges, onChange]);\n\n  /**\n   * Add a new state to the history with a descriptive action name\n   * @param {Array} currentNodes - The current nodes state\n   * @param {Array} currentEdges - The current edges state\n   * @param {string} actionName - Description of the action\n   */\n  const addToHistory = useCallback((currentNodes, currentEdges, actionName) => {\n    // Create a history record with metadata\n    const historyRecord = {\n      nodes: [...currentNodes],\n      edges: [...currentEdges],\n      timestamp: new Date().toISOString(),\n      action: actionName || 'Unknown action'\n    };\n\n    // Update history by removing any future history entries (if we're not at the end)\n    const newHistory = history.slice(0, historyIndex + 1);\n    newHistory.push(historyRecord);\n\n    // Limit history size to prevent memory issues (keep last 50 states)\n    const trimmedHistory = newHistory.length > 50 ? newHistory.slice(newHistory.length - 50) : newHistory;\n    setHistory(trimmedHistory);\n    setHistoryIndex(trimmedHistory.length - 1);\n\n    // For debugging\n    console.log(`History: ${actionName} (${trimmedHistory.length} states)`);\n  }, [history, historyIndex]);\n\n  /**\n   * Add a new element to the flow and update history\n   * @param {Object} newElement - The new element to add\n   */\n  const addElement = useCallback(newElement => {\n    if (isNode(newElement)) {\n      setNodes(nds => {\n        const newNodes = [...nds, newElement];\n        // Add to history\n        addToHistory(newNodes, edges, `Added ${newElement.type}`);\n        return newNodes;\n      });\n    } else if (isEdge(newElement)) {\n      setEdges(edgs => {\n        const newEdges = [...edgs, newElement];\n        // Add to history\n        addToHistory(nodes, newEdges, `Added connection`);\n        return newEdges;\n      });\n    }\n  }, [addToHistory, nodes, edges]);\n\n  /**\n   * Handle undo operation\n   */\n  const handleUndo = useCallback(() => {\n    if (historyIndex > 0) {\n      const newIndex = historyIndex - 1;\n      const historyRecord = history[newIndex];\n      if (historyRecord && historyRecord.nodes && historyRecord.edges) {\n        setHistoryIndex(newIndex);\n        setNodes(historyRecord.nodes);\n        setEdges(historyRecord.edges);\n        setNotification({\n          open: true,\n          message: `Undo: ${historyRecord.action}`,\n          severity: 'info'\n        });\n      } else {\n        console.error('History record is invalid', historyRecord);\n      }\n    }\n  }, [history, historyIndex]);\n\n  /**\n   * Handle redo operation\n   */\n  const handleRedo = useCallback(() => {\n    if (historyIndex < history.length - 1) {\n      const newIndex = historyIndex + 1;\n      const historyRecord = history[newIndex];\n      if (historyRecord && historyRecord.nodes && historyRecord.edges) {\n        setHistoryIndex(newIndex);\n        setNodes(historyRecord.nodes);\n        setEdges(historyRecord.edges);\n        setNotification({\n          open: true,\n          message: `Redo: ${historyRecord.action}`,\n          severity: 'info'\n        });\n      } else {\n        console.error('History record is invalid', historyRecord);\n      }\n    }\n  }, [history, historyIndex]);\n\n  /**\n   * Handle flow element selection\n   * @param {Object} event - The selection event\n   */\n  const onElementsSelect = useCallback(event => {\n    setSelectedElements(event);\n\n    // Call appropriate callbacks based on element type\n    if (event.length === 1) {\n      const selected = event[0];\n      if (isNode(selected) && onNodeSelect) {\n        onNodeSelect(selected);\n      } else if (isEdge(selected) && onEdgeSelect) {\n        onEdgeSelect(selected);\n      }\n    }\n  }, [onNodeSelect, onEdgeSelect]);\n\n  /**\n   * Handle element removal (nodes or edges)\n   */\n  const onElementsRemove = useCallback(elementsToRemove => {\n    // Separate nodes and edges to remove\n    const nodesToRemove = elementsToRemove.filter(el => isNode(el));\n    const edgesToRemove = elementsToRemove.filter(el => isEdge(el));\n\n    // Generate meaningful action name for history\n    const actionName = elementsToRemove.length === 1 ? `Removed ${isNode(elementsToRemove[0]) ? 'node' : 'edge'} ${elementsToRemove[0].id}` : `Removed ${elementsToRemove.length} elements`;\n\n    // Create changes object for each node to remove\n    if (nodesToRemove.length > 0) {\n      const nodeChanges = nodesToRemove.map(node => ({\n        id: node.id,\n        type: 'remove'\n      }));\n      setNodes(nds => {\n        const updatedNodes = applyNodeChanges(nodeChanges, nds);\n\n        // If we're also removing edges, we'll add to history after that\n        if (edgesToRemove.length === 0) {\n          addToHistory(updatedNodes, edges, actionName);\n        }\n        return updatedNodes;\n      });\n    }\n\n    // Create changes object for each edge to remove\n    if (edgesToRemove.length > 0) {\n      const edgeChanges = edgesToRemove.map(edge => ({\n        id: edge.id,\n        type: 'remove'\n      }));\n      setEdges(edgs => {\n        const updatedEdges = applyEdgeChanges(edgeChanges, edgs);\n\n        // Add to history after both nodes and edges are removed\n        if (nodesToRemove.length > 0) {\n          // We need to use the latest nodes state\n          const updatedNodes = nodes.filter(node => !nodesToRemove.some(nodeToRemove => nodeToRemove.id === node.id));\n          addToHistory(updatedNodes, updatedEdges, actionName);\n        } else {\n          addToHistory(nodes, updatedEdges, actionName);\n        }\n        return updatedEdges;\n      });\n    }\n  }, [nodes, edges, addToHistory]);\n\n  /**\n   * Handle connection (edge) creation\n   * @param {Object} params - Connection parameters\n   */\n  const onConnect = useCallback(params => {\n    // Get source and target nodes to validate connection\n    const sourceNode = nodes.find(node => node.id === params.source);\n    const targetNode = nodes.find(node => node.id === params.target);\n    if (!sourceNode || !targetNode) {\n      setNotification({\n        open: true,\n        message: 'Cannot create connection: Source or target node not found',\n        severity: 'error'\n      });\n      return;\n    }\n\n    // Create connection object for validation\n    const newConnection = {\n      ...params,\n      id: `edge-${params.source}-${params.target}-${Date.now()}`,\n      source: params.source,\n      target: params.target,\n      sourceHandle: params.sourceHandle,\n      targetHandle: params.targetHandle\n    };\n\n    // Validate the connection\n    const validation = validateConnection(newConnection, nodes, edges);\n\n    // Create a custom edge with a unique ID and validation result\n    const connection = {\n      ...params,\n      id: `edge-${params.source}-${params.target}-${Date.now()}`,\n      type: 'flowEdge',\n      animated: true,\n      data: {\n        label: 'Connection',\n        validation: validation,\n        connectionType: 'DATA',\n        // Default to data connection type\n        onDelete: edgeId => {\n          const edgeToRemove = edges.find(el => el.id === edgeId);\n          if (edgeToRemove) {\n            onElementsRemove([edgeToRemove]);\n          }\n        },\n        onLabelEdit: edgeId => {\n          // Implementation will be added for label editing\n          console.log('Edit label for', edgeId);\n        },\n        onConnectionTypeChange: (edgeId, connectionType) => {\n          // Implementation for changing connection type\n          setEdges(edgs => {\n            const newEdges = edgs.map(edge => {\n              if (edge.id === edgeId) {\n                return {\n                  ...edge,\n                  animated: connectionType === 'DATA',\n                  data: {\n                    ...edge.data,\n                    connectionType\n                  }\n                };\n              }\n              return edge;\n            });\n\n            // Add to history\n            addToHistory(nodes, newEdges, `Changed connection type to ${connectionType}`);\n            return newEdges;\n          });\n        },\n        onPriorityChange: (edgeId, priority) => {\n          // Implementation for changing priority\n          setEdges(edgs => {\n            const newEdges = edgs.map(edge => {\n              if (edge.id === edgeId) {\n                return {\n                  ...edge,\n                  data: {\n                    ...edge.data,\n                    priority\n                  }\n                };\n              }\n              return edge;\n            });\n\n            // Add to history\n            addToHistory(nodes, newEdges, `Changed connection priority to ${priority}`);\n            return newEdges;\n          });\n        },\n        onTest: edgeId => {\n          // Implementation for testing connection\n          setNotification({\n            open: true,\n            message: 'Testing connection...',\n            severity: 'info'\n          });\n        },\n        onAddBreakpoint: edgeId => {\n          // Implementation for adding breakpoint\n          setEdges(edgs => {\n            const newEdges = edgs.map(edge => {\n              if (edge.id === edgeId) {\n                var _edge$data;\n                const hasBreakpoint = !!((_edge$data = edge.data) !== null && _edge$data !== void 0 && _edge$data.breakpoint);\n                return {\n                  ...edge,\n                  data: {\n                    ...edge.data,\n                    breakpoint: !hasBreakpoint // Toggle breakpoint\n                  }\n                };\n              }\n              return edge;\n            });\n\n            // Add to history\n            addToHistory(nodes, newEdges, `Toggled breakpoint on connection ${edgeId}`);\n            return newEdges;\n          });\n        },\n        onValidate: params => {\n          // Implementation for validating connection\n          return validateConnection(params, nodes, edges);\n        }\n      }\n    };\n\n    // Set notification based on validation\n    if (!validation.isValid) {\n      setNotification({\n        open: true,\n        message: validation.message,\n        severity: validation.hasError ? 'error' : 'warning'\n      });\n\n      // If it's a warning, allow the connection; if it's an error, prevent it\n      if (validation.hasError) {\n        return;\n      }\n    }\n\n    // Add the new edge\n    setEdges(edgs => {\n      var _sourceNode$data, _targetNode$data;\n      const newEdges = addEdge(connection, edgs);\n\n      // Get source and target node labels for the history\n      const sourceLabel = (sourceNode === null || sourceNode === void 0 ? void 0 : (_sourceNode$data = sourceNode.data) === null || _sourceNode$data === void 0 ? void 0 : _sourceNode$data.label) || params.source;\n      const targetLabel = (targetNode === null || targetNode === void 0 ? void 0 : (_targetNode$data = targetNode.data) === null || _targetNode$data === void 0 ? void 0 : _targetNode$data.label) || params.target;\n\n      // Add to history\n      addToHistory(nodes, newEdges, `Connected ${sourceLabel} to ${targetLabel}`);\n      return newEdges;\n    });\n  }, [nodes, edges, addToHistory, onElementsRemove]);\n\n  /**\n   * Handle node dragging\n   * @param {Event} event - The drag event\n   */\n  const onDragOver = useCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'move';\n  }, []);\n\n  /**\n   * Handle node dropping onto the canvas\n   * @param {Event} event - The drop event\n   */\n  const onDrop = useCallback(event => {\n    event.preventDefault();\n\n    // Get the drop position in the canvas coordinates\n    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();\n    const nodeType = event.dataTransfer.getData('application/reactflow/type');\n\n    // Check if we have this node type\n    if (typeof nodeType === 'undefined' || !nodeType || !DEFAULT_NODE[nodeType]) {\n      return;\n    }\n\n    // Calculate the position where the node was dropped\n    const position = reactFlowInstance.screenToFlowPosition({\n      x: event.clientX - reactFlowBounds.left,\n      y: event.clientY - reactFlowBounds.top\n    });\n\n    // Get node template based on the type\n    const newNode = {\n      ...DEFAULT_NODE[nodeType],\n      position,\n      id: `${nodeType}-${Date.now()}`\n    };\n\n    // Add the new node\n    addElement(newNode);\n\n    // Show notification\n    setNotification({\n      open: true,\n      message: `Added new ${nodeType.replace('Node', '')} node`,\n      severity: 'success'\n    });\n  }, [reactFlowInstance, addElement]);\n\n  /**\n   * Handle saving the flow\n   */\n  const handleSave = useCallback(() => {\n    if (onSave) {\n      // Combine nodes and edges for backward compatibility\n      onSave([...nodes, ...edges]);\n\n      // Show notification\n      setNotification({\n        open: true,\n        message: 'Flow saved successfully',\n        severity: 'success'\n      });\n    }\n  }, [nodes, edges, onSave]);\n\n  /**\n   * Handle validating the flow\n   */\n  const handleValidate = useCallback(() => {\n    // Run flow validation\n    const validationResult = validateFlow(nodes, edges);\n\n    // Update notifications with validation results\n    if (validationResult.isValid) {\n      setNotification({\n        open: true,\n        message: 'Flow validation passed successfully',\n        severity: 'success'\n      });\n    } else {\n      // Get the first error or warning message to display\n      const message = validationResult.hasErrors ? validationResult.errors[0] : validationResult.hasWarnings ? validationResult.warnings[0] : 'Flow validation failed';\n      setNotification({\n        open: true,\n        message,\n        severity: validationResult.hasErrors ? 'error' : 'warning'\n      });\n    }\n\n    // Update node styles with validation results\n    setNodes(nds => {\n      return nds.map(node => {\n        // Apply validation results to nodes\n        if (validationResult.nodeValidation[node.id]) {\n          return {\n            ...node,\n            data: {\n              ...node.data,\n              validation: validationResult.nodeValidation[node.id]\n            }\n          };\n        }\n        return node;\n      });\n    });\n\n    // Update edge styles with validation results\n    setEdges(edgs => {\n      return edgs.map(edge => {\n        // Apply validation results to edges\n        if (validationResult.edgeValidation[edge.id]) {\n          return {\n            ...edge,\n            data: {\n              ...edge.data,\n              validation: validationResult.edgeValidation[edge.id]\n            }\n          };\n        }\n        return edge;\n      });\n    });\n\n    // If there's an external validation handler, call it with the result\n    if (onValidate) {\n      onValidate([...nodes, ...edges], validationResult);\n    }\n    return validationResult.isValid;\n  }, [nodes, edges, onValidate]);\n\n  /**\n   * Delete selected elements\n   */\n  const handleDelete = useCallback(() => {\n    if (selectedElements.length > 0) {\n      onElementsRemove(selectedElements);\n      setSelectedElements([]);\n\n      // Show notification\n      setNotification({\n        open: true,\n        message: `Deleted ${selectedElements.length} element(s)`,\n        severity: 'info'\n      });\n    }\n  }, [selectedElements, onElementsRemove]);\n\n  /**\n   * Show node menu at canvas position\n   * @param {Event} event - The context menu event\n   */\n  const handleContextMenu = useCallback(event => {\n    event.preventDefault();\n\n    // Calculate position relative to canvas\n    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();\n    const position = reactFlowInstance.screenToFlowPosition({\n      x: event.clientX - reactFlowBounds.left,\n      y: event.clientY - reactFlowBounds.top\n    });\n    setNodeMenuPosition(position);\n    setNodeMenuAnchorEl(event.currentTarget);\n  }, [reactFlowInstance]);\n\n  /**\n   * Close node menu\n   */\n  const handleCloseNodeMenu = useCallback(() => {\n    setNodeMenuAnchorEl(null);\n  }, []);\n\n  /**\n   * Add a new node from the context menu\n   * @param {string} nodeType - Type of node to add\n   */\n  const handleAddNode = useCallback(nodeType => {\n    // Check if we have this node type\n    if (!DEFAULT_NODE[nodeType]) {\n      return;\n    }\n\n    // Create a new node at the menu position\n    const newNode = {\n      ...DEFAULT_NODE[nodeType],\n      position: nodeMenuPosition,\n      id: `${nodeType}-${Date.now()}`\n    };\n\n    // Add the new node\n    addElement(newNode);\n\n    // Close menu\n    handleCloseNodeMenu();\n\n    // Show notification\n    setNotification({\n      open: true,\n      message: `Added new ${nodeType.replace('Node', '')} node`,\n      severity: 'success'\n    });\n  }, [nodeMenuPosition, addElement, handleCloseNodeMenu]);\n\n  /**\n   * Close notification\n   */\n  const handleCloseNotification = useCallback(() => {\n    setNotification({\n      ...notification,\n      open: false\n    });\n  }, [notification]);\n  return /*#__PURE__*/_jsxs(Box, {\n    sx: {\n      height: '100%',\n      width: '100%',\n      display: 'flex',\n      flexDirection: 'column'\n    },\n    children: [/*#__PURE__*/_jsx(Paper, {\n      elevation: 1,\n      sx: {\n        width: '100%'\n      },\n      children: /*#__PURE__*/_jsxs(Toolbar, {\n        variant: \"dense\",\n        children: [/*#__PURE__*/_jsx(Tooltip, {\n          title: \"Add Node\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            onClick: e => setNodeMenuAnchorEl(e.currentTarget),\n            disabled: readOnly,\n            children: /*#__PURE__*/_jsx(AddIcon, {})\n          })\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Delete Selected\",\n          children: /*#__PURE__*/_jsx(\"span\", {\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: handleDelete,\n              disabled: readOnly || selectedElements.length === 0,\n              children: /*#__PURE__*/_jsx(DeleteIcon, {})\n            })\n          })\n        }), /*#__PURE__*/_jsx(Divider, {\n          orientation: \"vertical\",\n          flexItem: true,\n          sx: {\n            mx: 1\n          }\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Undo\",\n          children: /*#__PURE__*/_jsx(\"span\", {\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: handleUndo,\n              disabled: readOnly || historyIndex === 0,\n              children: /*#__PURE__*/_jsx(UndoIcon, {})\n            })\n          })\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Redo\",\n          children: /*#__PURE__*/_jsx(\"span\", {\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: handleRedo,\n              disabled: readOnly || historyIndex === history.length - 1,\n              children: /*#__PURE__*/_jsx(RedoIcon, {})\n            })\n          })\n        }), /*#__PURE__*/_jsx(Divider, {\n          orientation: \"vertical\",\n          flexItem: true,\n          sx: {\n            mx: 1\n          }\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Save Flow\",\n          children: /*#__PURE__*/_jsx(\"span\", {\n            children: /*#__PURE__*/_jsx(IconButton, {\n              onClick: handleSave,\n              disabled: readOnly,\n              color: \"primary\",\n              children: /*#__PURE__*/_jsx(SaveIcon, {})\n            })\n          })\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Validate Flow\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            onClick: handleValidate,\n            color: \"secondary\",\n            children: /*#__PURE__*/_jsx(PlayIcon, {})\n          })\n        }), /*#__PURE__*/_jsx(Box, {\n          sx: {\n            flexGrow: 1\n          }\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: readOnly ? \"Read Only Mode\" : \"Edit Mode\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            color: readOnly ? \"error\" : \"success\",\n            children: readOnly ? /*#__PURE__*/_jsx(LockIcon, {}) : /*#__PURE__*/_jsx(LockOpenIcon, {})\n          })\n        }), /*#__PURE__*/_jsx(Tooltip, {\n          title: \"Flow Settings\",\n          children: /*#__PURE__*/_jsx(IconButton, {\n            children: /*#__PURE__*/_jsx(SettingsIcon, {})\n          })\n        })]\n      })\n    }), /*#__PURE__*/_jsx(Box, {\n      ref: reactFlowWrapper,\n      sx: {\n        flexGrow: 1,\n        width: '100%',\n        height: 'calc(100% - 48px)',\n        '& .react-flow__node': {\n          cursor: readOnly ? 'default' : 'move'\n        }\n      },\n      children: /*#__PURE__*/_jsxs(ReactFlow, {\n        nodes: nodes,\n        edges: edges,\n        nodeTypes: nodeTypes,\n        edgeTypes: edgeTypes,\n        onNodesChange: changes => {\n          setNodes(nds => {\n            const updatedNodes = applyNodeChanges(changes, nds);\n            return updatedNodes;\n          });\n        },\n        onEdgesChange: changes => {\n          setEdges(edgs => {\n            const updatedEdges = applyEdgeChanges(changes, edgs);\n            return updatedEdges;\n          });\n        },\n        onConnect: onConnect,\n        onSelectionChange: onElementsSelect,\n        deleteKeyCode: 46 // Delete key\n        ,\n        onInit: instance => {\n          // Center the graph after loading\n          instance.fitView({\n            padding: 0.2\n          });\n        },\n        onDragOver: onDragOver,\n        onDrop: onDrop,\n        onContextMenu: handleContextMenu,\n        snapToGrid: true,\n        snapGrid: [15, 15],\n        defaultZoom: 1,\n        minZoom: 0.1,\n        maxZoom: 1.5,\n        style: defaultFlowStyle,\n        selectionOnDrag: false,\n        multiSelectionKeyCode: \"Control\",\n        selectionMode: 1,\n        elementsSelectable: !readOnly,\n        nodesDraggable: !readOnly,\n        nodesConnectable: !readOnly,\n        children: [/*#__PURE__*/_jsx(Background, {\n          variant: \"dots\",\n          gap: 12,\n          size: 1\n        }), /*#__PURE__*/_jsx(Controls, {\n          showInteractive: false\n        }), /*#__PURE__*/_jsx(MiniMap, {\n          nodeColor: node => {\n            // Color nodes based on their type\n            if (node.type === 'sourceNode') return '#00c853';\n            if (node.type === 'destinationNode') return '#2196f3';\n            if (node.type === 'transformationNode') return '#ff9800';\n            if (node.type === 'filterNode') return '#9c27b0';\n            return '#999';\n          }\n        })]\n      })\n    }), /*#__PURE__*/_jsxs(Menu, {\n      anchorEl: nodeMenuAnchorEl,\n      open: Boolean(nodeMenuAnchorEl),\n      onClose: handleCloseNodeMenu,\n      children: [/*#__PURE__*/_jsx(MenuItem, {\n        onClick: () => handleAddNode('sourceNode'),\n        children: \"Add Source\"\n      }), /*#__PURE__*/_jsx(MenuItem, {\n        onClick: () => handleAddNode('destinationNode'),\n        children: \"Add Destination\"\n      }), /*#__PURE__*/_jsx(MenuItem, {\n        onClick: () => handleAddNode('transformationNode'),\n        children: \"Add Transformation\"\n      }), /*#__PURE__*/_jsx(MenuItem, {\n        onClick: () => handleAddNode('filterNode'),\n        children: \"Add Filter\"\n      })]\n    }), /*#__PURE__*/_jsx(Snackbar, {\n      open: notification.open,\n      autoHideDuration: 4000,\n      onClose: handleCloseNotification,\n      anchorOrigin: {\n        vertical: 'bottom',\n        horizontal: 'left'\n      },\n      children: /*#__PURE__*/_jsx(Alert, {\n        onClose: handleCloseNotification,\n        severity: notification.severity,\n        variant: \"filled\",\n        children: notification.message\n      })\n    })]\n  });\n};\n/**\n * Flow Canvas wrapper with ReactFlowProvider\n */\nconst FlowCanvas = props => {\n  return /*#__PURE__*/_jsx(ReactFlowProvider, {\n    children: /*#__PURE__*/_jsx(FlowCanvasContent, {\n      ...props\n    })\n  });\n};\nexport default FlowCanvas;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}