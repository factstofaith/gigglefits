{"ast":null,"code":"/**\n * Connection Validation Service\n * \n * This service provides validation for connections between nodes in the flow canvas.\n * It handles type compatibility, data format validation, and connection constraints.\n */// Node type definitions\nconst NODE_TYPES={sourceNode:{outputs:['data'],maxOutputConnections:null,// unlimited\ndescription:'Source node providing data'},destinationNode:{inputs:['data'],maxInputConnections:10,description:'Destination node receiving data'},transformationNode:{inputs:['data'],outputs:['data'],maxInputConnections:5,maxOutputConnections:10,description:'Transformation node processing data'},filterNode:{inputs:['data'],outputs:['data','filtered'],maxInputConnections:5,maxOutputConnections:10,description:'Filter node routing data based on conditions'}};// Data type compatibility matrix\n// This defines which data types can be connected to which\nconst DATA_TYPE_COMPATIBILITY={'string':['string','any'],'number':['number','any'],'boolean':['boolean','any'],'date':['date','string','any'],'object':['object','any'],'array':['array','any'],'any':['string','number','boolean','date','object','array','any']};/**\n * Checks if a node of sourceType can connect to a node of targetType\n * \n * @param {string} sourceType - The type of the source node\n * @param {string} targetType - The type of the target node\n * @returns {Object} Validation result with isValid flag and message\n */export const validateNodeTypeConnection=(sourceType,targetType)=>{// Check if node types exist in our definitions\nif(!NODE_TYPES[sourceType]){return{isValid:false,hasError:true,message:`Invalid source node type: ${sourceType}`};}if(!NODE_TYPES[targetType]){return{isValid:false,hasError:true,message:`Invalid target node type: ${targetType}`};}// Check if source node has outputs\nif(!NODE_TYPES[sourceType].outputs||NODE_TYPES[sourceType].outputs.length===0){return{isValid:false,hasError:true,message:`Source node type ${sourceType} has no outputs`};}// Check if target node has inputs\nif(!NODE_TYPES[targetType].inputs||NODE_TYPES[targetType].inputs.length===0){return{isValid:false,hasError:true,message:`Target node type ${targetType} has no inputs`};}// For now, let's assume all defined connections are valid if both have I/O\nreturn{isValid:true,message:`Connection from ${sourceType} to ${targetType} is valid`};};/**\n * Validates a connection between nodes based on handles and data types\n * \n * @param {Object} source - The source node\n * @param {Object} target - The target node\n * @param {string} sourceHandle - The source handle ID\n * @param {string} targetHandle - The target handle ID\n * @returns {Object} Validation result with isValid flag and message\n */export const validateHandleConnection=(source,target,sourceHandle,targetHandle)=>{var _source$data,_source$data$outputs,_source$data$outputs$,_target$data,_target$data$inputs,_target$data$inputs$t;// Get the data types from handles\nconst sourceDataType=(source===null||source===void 0?void 0:(_source$data=source.data)===null||_source$data===void 0?void 0:(_source$data$outputs=_source$data.outputs)===null||_source$data$outputs===void 0?void 0:(_source$data$outputs$=_source$data$outputs[sourceHandle])===null||_source$data$outputs$===void 0?void 0:_source$data$outputs$.type)||'any';const targetDataType=(target===null||target===void 0?void 0:(_target$data=target.data)===null||_target$data===void 0?void 0:(_target$data$inputs=_target$data.inputs)===null||_target$data$inputs===void 0?void 0:(_target$data$inputs$t=_target$data$inputs[targetHandle])===null||_target$data$inputs$t===void 0?void 0:_target$data$inputs$t.type)||'any';// Check if data types are compatible\nconst compatibleTypes=DATA_TYPE_COMPATIBILITY[sourceDataType]||[];if(!compatibleTypes.includes(targetDataType)){return{isValid:false,hasError:true,message:`Incompatible data types: ${sourceDataType} cannot connect to ${targetDataType}`};}return{isValid:true,message:`Data types ${sourceDataType} and ${targetDataType} are compatible`};};/**\n * Validates connection count constraints\n * \n * @param {Object} node - The node to check\n * @param {Array} connections - All existing connections\n * @param {string} connectionType - Either 'input' or 'output'\n * @returns {Object} Validation result with isValid flag and message\n */export const validateConnectionCount=(node,connections,connectionType)=>{const nodeType=node.type;const nodeTypeInfo=NODE_TYPES[nodeType];if(!nodeTypeInfo){return{isValid:true,// Skip constraint validation for unknown node types\nmessage:'Unknown node type, skipping constraint validation'};}// Count existing connections for this node\nconst connectionCount=connections.filter(conn=>{if(connectionType==='input'){return conn.target===node.id;}else{return conn.source===node.id;}}).length;// Check against max connection constraints\nconst maxConnections=connectionType==='input'?nodeTypeInfo.maxInputConnections:nodeTypeInfo.maxOutputConnections;if(maxConnections!==null&&connectionCount>=maxConnections){return{isValid:false,hasWarning:true,message:`Maximum ${connectionType} connections (${maxConnections}) reached for ${nodeType}`};}return{isValid:true,message:`${connectionType} connection count is valid (${connectionCount}/${maxConnections||'âˆž'})`};};/**\n * Detect cycles in the flow graph\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */export const detectCycles=(nodes,edges)=>{// Create an adjacency list representation of the graph\nconst graph={};nodes.forEach(node=>{graph[node.id]=[];});edges.forEach(edge=>{if(edge.source&&edge.target){graph[edge.source].push(edge.target);}});// DFS to detect cycles\nconst visited={};const recStack={};function dfsUtil(nodeId,visited,recStack){if(!visited[nodeId]){visited[nodeId]=true;recStack[nodeId]=true;const neighbors=graph[nodeId]||[];for(const neighbor of neighbors){if(!visited[neighbor]&&dfsUtil(neighbor,visited,recStack)){return true;}else if(recStack[neighbor]){return true;}}}recStack[nodeId]=false;return false;}// Check each node as a starting point\nfor(const nodeId in graph){if(!visited[nodeId]){if(dfsUtil(nodeId,visited,recStack)){return{isValid:false,hasError:true,message:'Cycle detected in flow. This may cause infinite loops.'};}}}return{isValid:true,message:'No cycles detected in flow.'};};/**\n * Validates a connection as a whole\n * \n * @param {Object} connection - The connection to validate\n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */export const validateConnection=(connection,nodes,edges)=>{// Find source and target nodes\nconst sourceNode=nodes.find(node=>node.id===connection.source);const targetNode=nodes.find(node=>node.id===connection.target);if(!sourceNode||!targetNode){return{isValid:false,hasError:true,message:'Source or target node not found'};}// Validate node type compatibility\nconst nodeTypeValidation=validateNodeTypeConnection(sourceNode.type,targetNode.type);if(!nodeTypeValidation.isValid){return nodeTypeValidation;}// Validate handle data type compatibility\nconst handleValidation=validateHandleConnection(sourceNode,targetNode,connection.sourceHandle,connection.targetHandle);if(!handleValidation.isValid){return handleValidation;}// Validate source output connection count\nconst sourceOutputValidation=validateConnectionCount(sourceNode,edges,'output');if(!sourceOutputValidation.isValid){return sourceOutputValidation;}// Validate target input connection count\nconst targetInputValidation=validateConnectionCount(targetNode,edges,'input');if(!targetInputValidation.isValid){return targetInputValidation;}// Check for cycles when adding this connection\nconst allEdges=[...edges,connection].filter(e=>// Filter out the existing version of this connection if we're updating\n!(e.id!==connection.id&&e.source===connection.source&&e.target===connection.target));const cycleValidation=detectCycles(nodes,allEdges);if(!cycleValidation.isValid){return cycleValidation;}// All validations passed\nreturn{isValid:true,message:'Connection is valid'};};/**\n * Validates a full flow\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation results with isValid flag, error list, and node/edge specific validation\n */export const validateFlow=(nodes,edges)=>{const result={isValid:true,hasErrors:false,hasWarnings:false,errors:[],warnings:[],nodeValidation:{},edgeValidation:{}};// Check if there's at least one source node\nconst sourceNodes=nodes.filter(node=>node.type==='sourceNode');if(sourceNodes.length===0){result.isValid=false;result.hasErrors=true;result.errors.push('Flow must have at least one source node');}// Check if there's at least one destination node\nconst destinationNodes=nodes.filter(node=>node.type==='destinationNode');if(destinationNodes.length===0){result.isValid=false;result.hasErrors=true;result.errors.push('Flow must have at least one destination node');}// Check if each source node is connected\nsourceNodes.forEach(node=>{const hasOutgoingConnections=edges.some(edge=>edge.source===node.id);if(!hasOutgoingConnections){var _node$data;result.hasWarnings=true;result.warnings.push(`Source node ${((_node$data=node.data)===null||_node$data===void 0?void 0:_node$data.label)||node.id} is not connected to any destination`);result.nodeValidation[node.id]={isValid:true,hasWarning:true,message:'Source node not connected'};}});// Check if each destination node is connected\ndestinationNodes.forEach(node=>{const hasIncomingConnections=edges.some(edge=>edge.target===node.id);if(!hasIncomingConnections){var _node$data2;result.hasWarnings=true;result.warnings.push(`Destination node ${((_node$data2=node.data)===null||_node$data2===void 0?void 0:_node$data2.label)||node.id} has no incoming connections`);result.nodeValidation[node.id]={isValid:true,hasWarning:true,message:'Destination node not connected'};}});// Validate all connections\nedges.forEach(edge=>{const edgeValidation=validateConnection(edge,nodes,edges);result.edgeValidation[edge.id]=edgeValidation;if(!edgeValidation.isValid){if(edgeValidation.hasError){result.isValid=false;result.hasErrors=true;result.errors.push(`Invalid connection: ${edgeValidation.message}`);}else if(edgeValidation.hasWarning){result.hasWarnings=true;result.warnings.push(`Warning for connection: ${edgeValidation.message}`);}}});// Detect unreachable nodes\nconst reachableNodes=new Set();// Start with source nodes\nsourceNodes.forEach(node=>{reachableNodes.add(node.id);});// Follow the connections\nlet newNodesAdded=true;while(newNodesAdded){newNodesAdded=false;edges.forEach(edge=>{if(reachableNodes.has(edge.source)&&!reachableNodes.has(edge.target)){reachableNodes.add(edge.target);newNodesAdded=true;}});}// Check for unreachable nodes\nnodes.forEach(node=>{if(!reachableNodes.has(node.id)&&node.type!=='sourceNode'){var _node$data3;result.hasWarnings=true;result.warnings.push(`Node ${((_node$data3=node.data)===null||_node$data3===void 0?void 0:_node$data3.label)||node.id} is unreachable from any source`);result.nodeValidation[node.id]={isValid:true,hasWarning:true,message:'Node is unreachable'};}});return result;};/**\n * Deep validation for a flow before execution\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Promise<Object>} Validation results with detailed checks\n */export const validateFlowForExecution=async(nodes,edges)=>{// Start with basic validation\nconst baseValidation=validateFlow(nodes,edges);// If the basic validation failed with errors, no need to continue\nif(!baseValidation.isValid){return baseValidation;}// Perform deep validation for each node\nconst result={...baseValidation,nodeConfig:{}};// Check node configuration completeness\nawait Promise.all(nodes.map(async node=>{var _node$data4;// Skip if node has no validate function\nif(!((_node$data4=node.data)!==null&&_node$data4!==void 0&&_node$data4.validate)){return;}try{const nodeValidation=await node.data.validate();result.nodeConfig[node.id]=nodeValidation;if(!nodeValidation.isValid){if(nodeValidation.hasError){var _node$data5;result.isValid=false;result.hasErrors=true;result.errors.push(`Node ${((_node$data5=node.data)===null||_node$data5===void 0?void 0:_node$data5.label)||node.id}: ${nodeValidation.message}`);}else if(nodeValidation.hasWarning){var _node$data6;result.hasWarnings=true;result.warnings.push(`Node ${((_node$data6=node.data)===null||_node$data6===void 0?void 0:_node$data6.label)||node.id}: ${nodeValidation.message}`);}}}catch(error){var _node$data7;result.isValid=false;result.hasErrors=true;result.errors.push(`Error validating node ${((_node$data7=node.data)===null||_node$data7===void 0?void 0:_node$data7.label)||node.id}: ${error.message}`);}}));return result;};export default{validateNodeTypeConnection,validateHandleConnection,validateConnectionCount,detectCycles,validateConnection,validateFlow,validateFlowForExecution};","map":{"version":3,"names":["NODE_TYPES","sourceNode","outputs","maxOutputConnections","description","destinationNode","inputs","maxInputConnections","transformationNode","filterNode","DATA_TYPE_COMPATIBILITY","validateNodeTypeConnection","sourceType","targetType","isValid","hasError","message","length","validateHandleConnection","source","target","sourceHandle","targetHandle","_source$data","_source$data$outputs","_source$data$outputs$","_target$data","_target$data$inputs","_target$data$inputs$t","sourceDataType","data","type","targetDataType","compatibleTypes","includes","validateConnectionCount","node","connections","connectionType","nodeType","nodeTypeInfo","connectionCount","filter","conn","id","maxConnections","hasWarning","detectCycles","nodes","edges","graph","forEach","edge","push","visited","recStack","dfsUtil","nodeId","neighbors","neighbor","validateConnection","connection","find","targetNode","nodeTypeValidation","handleValidation","sourceOutputValidation","targetInputValidation","allEdges","e","cycleValidation","validateFlow","result","hasErrors","hasWarnings","errors","warnings","nodeValidation","edgeValidation","sourceNodes","destinationNodes","hasOutgoingConnections","some","_node$data","label","hasIncomingConnections","_node$data2","reachableNodes","Set","add","newNodesAdded","has","_node$data3","validateFlowForExecution","baseValidation","nodeConfig","Promise","all","map","_node$data4","validate","_node$data5","_node$data6","error","_node$data7"],"sources":["/home/ai-dev/Desktop/tap-integration-platform/frontend/src/components/integration/flow/validation/connection-validation.js"],"sourcesContent":["/**\n * Connection Validation Service\n * \n * This service provides validation for connections between nodes in the flow canvas.\n * It handles type compatibility, data format validation, and connection constraints.\n */\n\n// Node type definitions\nconst NODE_TYPES = {\n  sourceNode: {\n    outputs: ['data'],\n    maxOutputConnections: null, // unlimited\n    description: 'Source node providing data',\n  },\n  destinationNode: {\n    inputs: ['data'],\n    maxInputConnections: 10,\n    description: 'Destination node receiving data',\n  },\n  transformationNode: {\n    inputs: ['data'],\n    outputs: ['data'],\n    maxInputConnections: 5,\n    maxOutputConnections: 10,\n    description: 'Transformation node processing data',\n  },\n  filterNode: {\n    inputs: ['data'],\n    outputs: ['data', 'filtered'],\n    maxInputConnections: 5,\n    maxOutputConnections: 10,\n    description: 'Filter node routing data based on conditions',\n  }\n};\n\n// Data type compatibility matrix\n// This defines which data types can be connected to which\nconst DATA_TYPE_COMPATIBILITY = {\n  'string': ['string', 'any'],\n  'number': ['number', 'any'],\n  'boolean': ['boolean', 'any'],\n  'date': ['date', 'string', 'any'],\n  'object': ['object', 'any'],\n  'array': ['array', 'any'],\n  'any': ['string', 'number', 'boolean', 'date', 'object', 'array', 'any'],\n};\n\n/**\n * Checks if a node of sourceType can connect to a node of targetType\n * \n * @param {string} sourceType - The type of the source node\n * @param {string} targetType - The type of the target node\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateNodeTypeConnection = (sourceType, targetType) => {\n  // Check if node types exist in our definitions\n  if (!NODE_TYPES[sourceType]) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Invalid source node type: ${sourceType}`,\n    };\n  }\n  \n  if (!NODE_TYPES[targetType]) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Invalid target node type: ${targetType}`,\n    };\n  }\n  \n  // Check if source node has outputs\n  if (!NODE_TYPES[sourceType].outputs || NODE_TYPES[sourceType].outputs.length === 0) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Source node type ${sourceType} has no outputs`,\n    };\n  }\n  \n  // Check if target node has inputs\n  if (!NODE_TYPES[targetType].inputs || NODE_TYPES[targetType].inputs.length === 0) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Target node type ${targetType} has no inputs`,\n    };\n  }\n  \n  // For now, let's assume all defined connections are valid if both have I/O\n  return {\n    isValid: true,\n    message: `Connection from ${sourceType} to ${targetType} is valid`,\n  };\n};\n\n/**\n * Validates a connection between nodes based on handles and data types\n * \n * @param {Object} source - The source node\n * @param {Object} target - The target node\n * @param {string} sourceHandle - The source handle ID\n * @param {string} targetHandle - The target handle ID\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateHandleConnection = (source, target, sourceHandle, targetHandle) => {\n  // Get the data types from handles\n  const sourceDataType = source?.data?.outputs?.[sourceHandle]?.type || 'any';\n  const targetDataType = target?.data?.inputs?.[targetHandle]?.type || 'any';\n  \n  // Check if data types are compatible\n  const compatibleTypes = DATA_TYPE_COMPATIBILITY[sourceDataType] || [];\n  if (!compatibleTypes.includes(targetDataType)) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: `Incompatible data types: ${sourceDataType} cannot connect to ${targetDataType}`,\n    };\n  }\n  \n  return {\n    isValid: true,\n    message: `Data types ${sourceDataType} and ${targetDataType} are compatible`,\n  };\n};\n\n/**\n * Validates connection count constraints\n * \n * @param {Object} node - The node to check\n * @param {Array} connections - All existing connections\n * @param {string} connectionType - Either 'input' or 'output'\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateConnectionCount = (node, connections, connectionType) => {\n  const nodeType = node.type;\n  const nodeTypeInfo = NODE_TYPES[nodeType];\n  \n  if (!nodeTypeInfo) {\n    return {\n      isValid: true, // Skip constraint validation for unknown node types\n      message: 'Unknown node type, skipping constraint validation',\n    };\n  }\n  \n  // Count existing connections for this node\n  const connectionCount = connections.filter(conn => {\n    if (connectionType === 'input') {\n      return conn.target === node.id;\n    } else {\n      return conn.source === node.id;\n    }\n  }).length;\n  \n  // Check against max connection constraints\n  const maxConnections = connectionType === 'input' \n    ? nodeTypeInfo.maxInputConnections \n    : nodeTypeInfo.maxOutputConnections;\n  \n  if (maxConnections !== null && connectionCount >= maxConnections) {\n    return {\n      isValid: false,\n      hasWarning: true,\n      message: `Maximum ${connectionType} connections (${maxConnections}) reached for ${nodeType}`,\n    };\n  }\n  \n  return {\n    isValid: true,\n    message: `${connectionType} connection count is valid (${connectionCount}/${maxConnections || 'âˆž'})`,\n  };\n};\n\n/**\n * Detect cycles in the flow graph\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const detectCycles = (nodes, edges) => {\n  // Create an adjacency list representation of the graph\n  const graph = {};\n  nodes.forEach(node => {\n    graph[node.id] = [];\n  });\n  \n  edges.forEach(edge => {\n    if (edge.source && edge.target) {\n      graph[edge.source].push(edge.target);\n    }\n  });\n  \n  // DFS to detect cycles\n  const visited = {};\n  const recStack = {};\n  \n  function dfsUtil(nodeId, visited, recStack) {\n    if (!visited[nodeId]) {\n      visited[nodeId] = true;\n      recStack[nodeId] = true;\n      \n      const neighbors = graph[nodeId] || [];\n      for (const neighbor of neighbors) {\n        if (!visited[neighbor] && dfsUtil(neighbor, visited, recStack)) {\n          return true;\n        } else if (recStack[neighbor]) {\n          return true;\n        }\n      }\n    }\n    \n    recStack[nodeId] = false;\n    return false;\n  }\n  \n  // Check each node as a starting point\n  for (const nodeId in graph) {\n    if (!visited[nodeId]) {\n      if (dfsUtil(nodeId, visited, recStack)) {\n        return {\n          isValid: false,\n          hasError: true,\n          message: 'Cycle detected in flow. This may cause infinite loops.',\n        };\n      }\n    }\n  }\n  \n  return {\n    isValid: true,\n    message: 'No cycles detected in flow.',\n  };\n};\n\n/**\n * Validates a connection as a whole\n * \n * @param {Object} connection - The connection to validate\n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation result with isValid flag and message\n */\nexport const validateConnection = (connection, nodes, edges) => {\n  // Find source and target nodes\n  const sourceNode = nodes.find(node => node.id === connection.source);\n  const targetNode = nodes.find(node => node.id === connection.target);\n  \n  if (!sourceNode || !targetNode) {\n    return {\n      isValid: false,\n      hasError: true,\n      message: 'Source or target node not found',\n    };\n  }\n  \n  // Validate node type compatibility\n  const nodeTypeValidation = validateNodeTypeConnection(\n    sourceNode.type,\n    targetNode.type\n  );\n  \n  if (!nodeTypeValidation.isValid) {\n    return nodeTypeValidation;\n  }\n  \n  // Validate handle data type compatibility\n  const handleValidation = validateHandleConnection(\n    sourceNode,\n    targetNode,\n    connection.sourceHandle,\n    connection.targetHandle\n  );\n  \n  if (!handleValidation.isValid) {\n    return handleValidation;\n  }\n  \n  // Validate source output connection count\n  const sourceOutputValidation = validateConnectionCount(\n    sourceNode,\n    edges,\n    'output'\n  );\n  \n  if (!sourceOutputValidation.isValid) {\n    return sourceOutputValidation;\n  }\n  \n  // Validate target input connection count\n  const targetInputValidation = validateConnectionCount(\n    targetNode,\n    edges,\n    'input'\n  );\n  \n  if (!targetInputValidation.isValid) {\n    return targetInputValidation;\n  }\n  \n  // Check for cycles when adding this connection\n  const allEdges = [...edges, connection].filter(e => \n    // Filter out the existing version of this connection if we're updating\n    !(e.id !== connection.id && e.source === connection.source && e.target === connection.target)\n  );\n  \n  const cycleValidation = detectCycles(nodes, allEdges);\n  if (!cycleValidation.isValid) {\n    return cycleValidation;\n  }\n  \n  // All validations passed\n  return {\n    isValid: true,\n    message: 'Connection is valid',\n  };\n};\n\n/**\n * Validates a full flow\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Object} Validation results with isValid flag, error list, and node/edge specific validation\n */\nexport const validateFlow = (nodes, edges) => {\n  const result = {\n    isValid: true,\n    hasErrors: false,\n    hasWarnings: false,\n    errors: [],\n    warnings: [],\n    nodeValidation: {},\n    edgeValidation: {},\n  };\n  \n  // Check if there's at least one source node\n  const sourceNodes = nodes.filter(node => node.type === 'sourceNode');\n  if (sourceNodes.length === 0) {\n    result.isValid = false;\n    result.hasErrors = true;\n    result.errors.push('Flow must have at least one source node');\n  }\n  \n  // Check if there's at least one destination node\n  const destinationNodes = nodes.filter(node => node.type === 'destinationNode');\n  if (destinationNodes.length === 0) {\n    result.isValid = false;\n    result.hasErrors = true;\n    result.errors.push('Flow must have at least one destination node');\n  }\n  \n  // Check if each source node is connected\n  sourceNodes.forEach(node => {\n    const hasOutgoingConnections = edges.some(edge => edge.source === node.id);\n    if (!hasOutgoingConnections) {\n      result.hasWarnings = true;\n      result.warnings.push(`Source node ${node.data?.label || node.id} is not connected to any destination`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Source node not connected',\n      };\n    }\n  });\n  \n  // Check if each destination node is connected\n  destinationNodes.forEach(node => {\n    const hasIncomingConnections = edges.some(edge => edge.target === node.id);\n    if (!hasIncomingConnections) {\n      result.hasWarnings = true;\n      result.warnings.push(`Destination node ${node.data?.label || node.id} has no incoming connections`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Destination node not connected',\n      };\n    }\n  });\n  \n  // Validate all connections\n  edges.forEach(edge => {\n    const edgeValidation = validateConnection(edge, nodes, edges);\n    result.edgeValidation[edge.id] = edgeValidation;\n    \n    if (!edgeValidation.isValid) {\n      if (edgeValidation.hasError) {\n        result.isValid = false;\n        result.hasErrors = true;\n        result.errors.push(`Invalid connection: ${edgeValidation.message}`);\n      } else if (edgeValidation.hasWarning) {\n        result.hasWarnings = true;\n        result.warnings.push(`Warning for connection: ${edgeValidation.message}`);\n      }\n    }\n  });\n  \n  // Detect unreachable nodes\n  const reachableNodes = new Set();\n  \n  // Start with source nodes\n  sourceNodes.forEach(node => {\n    reachableNodes.add(node.id);\n  });\n  \n  // Follow the connections\n  let newNodesAdded = true;\n  while (newNodesAdded) {\n    newNodesAdded = false;\n    edges.forEach(edge => {\n      if (reachableNodes.has(edge.source) && !reachableNodes.has(edge.target)) {\n        reachableNodes.add(edge.target);\n        newNodesAdded = true;\n      }\n    });\n  }\n  \n  // Check for unreachable nodes\n  nodes.forEach(node => {\n    if (!reachableNodes.has(node.id) && node.type !== 'sourceNode') {\n      result.hasWarnings = true;\n      result.warnings.push(`Node ${node.data?.label || node.id} is unreachable from any source`);\n      result.nodeValidation[node.id] = {\n        isValid: true,\n        hasWarning: true,\n        message: 'Node is unreachable',\n      };\n    }\n  });\n  \n  return result;\n};\n\n/**\n * Deep validation for a flow before execution\n * \n * @param {Array} nodes - All nodes in the flow\n * @param {Array} edges - All edges in the flow\n * @returns {Promise<Object>} Validation results with detailed checks\n */\nexport const validateFlowForExecution = async (nodes, edges) => {\n  // Start with basic validation\n  const baseValidation = validateFlow(nodes, edges);\n  \n  // If the basic validation failed with errors, no need to continue\n  if (!baseValidation.isValid) {\n    return baseValidation;\n  }\n  \n  // Perform deep validation for each node\n  const result = {\n    ...baseValidation,\n    nodeConfig: {},\n  };\n  \n  // Check node configuration completeness\n  await Promise.all(nodes.map(async (node) => {\n    // Skip if node has no validate function\n    if (!node.data?.validate) {\n      return;\n    }\n    \n    try {\n      const nodeValidation = await node.data.validate();\n      result.nodeConfig[node.id] = nodeValidation;\n      \n      if (!nodeValidation.isValid) {\n        if (nodeValidation.hasError) {\n          result.isValid = false;\n          result.hasErrors = true;\n          result.errors.push(`Node ${node.data?.label || node.id}: ${nodeValidation.message}`);\n        } else if (nodeValidation.hasWarning) {\n          result.hasWarnings = true;\n          result.warnings.push(`Node ${node.data?.label || node.id}: ${nodeValidation.message}`);\n        }\n      }\n    } catch (error) {\n      result.isValid = false;\n      result.hasErrors = true;\n      result.errors.push(`Error validating node ${node.data?.label || node.id}: ${error.message}`);\n    }\n  }));\n  \n  return result;\n};\n\nexport default {\n  validateNodeTypeConnection,\n  validateHandleConnection,\n  validateConnectionCount,\n  detectCycles,\n  validateConnection,\n  validateFlow,\n  validateFlowForExecution,\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}